// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// BCS validation helpers to ensure complete consumption of serialized data.
module account_protocol::bcs_validation;

use sui::bcs::BCS;

// === Imports ===

// === Errors ===

const ETrailingActionData: u64 = 0;

// === Public Functions ===

/// Validates that all bytes in the BCS reader have been consumed
/// This prevents attacks where extra data is appended to actions
public fun validate_all_bytes_consumed(reader: BCS) {
    // Check if there are any remaining bytes
    let remaining = reader.into_remainder_bytes();
    assert!(remaining.is_empty(), ETrailingActionData);
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Unified registry for packages and their action decoders
///
/// This module combines package whitelisting and decoder registration into a single
/// coherent system, ensuring packages and their UI representations are always in sync.
///
/// Key improvements over separate Extensions + ActionDecoderRegistry:
/// - Atomic operations: Can't add package without declaring action types
/// - Single admin cap: Unified governance
/// - Enforced invariants: Package metadata always includes action types
/// - Better discoverability: Query which packages provide which actions
module account_protocol::package_registry;

use std::string::String;
use sui::event;
use sui::object::{Self, UID};
use sui::table::{Self, Table};
use sui::transfer;
use sui::tx_context::TxContext;

// === Errors ===

const EPackageNotFound: u64 = 0;
const EPackageAlreadyExists: u64 = 1;
const EActionTypeNotFound: u64 = 2;
const EActionTypeAlreadyRegistered: u64 = 3;
const EVersionNotMonotonic: u64 = 4;
const EEmptyVersionHistory: u64 = 5;

// === Events ===

public struct PackageAdded has copy, drop {
    name: String,
    addr: address,
    version: u64,
    num_action_types: u64,
    category: String,
}

public struct PackageRemoved has copy, drop {
    name: String,
}

public struct PackageVersionAdded has copy, drop {
    name: String,
    addr: address,
    version: u64,
}

public struct PackageVersionRemoved has copy, drop {
    name: String,
    addr: address,
    version: u64,
}

public struct PackageMetadataUpdated has copy, drop {
    name: String,
    num_action_types: u64,
    category: String,
}

// === Structs ===

/// Unified registry for packages and decoders
public struct PackageRegistry has key {
    id: UID,
    // Package tracking (name -> metadata)
    packages: Table<String, PackageMetadata>,
    // Reverse lookup (addr -> name)
    by_addr: Table<address, String>,
    // Active versions for O(1) validation (addr -> version)
    active_versions: Table<address, u64>,
    // Action type tracking (action type name -> package that provides it)
    action_to_package: Table<String, String>,
    // Account creation pause (governance-controllable)
    account_creation_paused: bool,
}

/// Metadata for a registered package
public struct PackageMetadata has store {
    // Version history (addr, version pairs)
    versions: vector<PackageVersion>,
    // Action types provided by this package (stored as String for serialization)
    action_types: vector<String>,
    // Package category (e.g., "core", "governance", "defi")
    category: String,
    // Optional description
    description: String,
}

/// A package version entry
public struct PackageVersion has copy, drop, store {
    addr: address,
    version: u64,
}

/// Single admin capability for the unified registry
public struct PackageAdminCap has key, store {
    id: UID,
}

/// Human-readable field for decoder output
public struct HumanReadableField has copy, drop, store {
    name: String,
    value: String,
    type_name: String,
}

// === Init ===

fun init(ctx: &mut TxContext) {
    transfer::transfer(PackageAdminCap { id: object::new(ctx) }, ctx.sender());
    transfer::share_object(PackageRegistry {
        id: object::new(ctx),
        packages: table::new(ctx),
        by_addr: table::new(ctx),
        active_versions: table::new(ctx),
        action_to_package: table::new(ctx),
        account_creation_paused: false,
    });
}

// === Admin Functions ===

/// Add a new package to the registry with its action types
/// This is an atomic operation - package and action type metadata are added together
///
/// Authorization: Requires &mut PackageRegistry, which can only be obtained by the registry owner.
/// This is enforced by Move's type system - no additional capability check needed.
public fun add_package(
    registry: &mut PackageRegistry,
    name: String,
    addr: address,
    version: u64,
    action_types: vector<String>,
    category: String,
    description: String,
) {
    assert!(!registry.packages.contains(name), EPackageAlreadyExists);
    assert!(!registry.by_addr.contains(addr), EPackageAlreadyExists);

    // Register action types -> package mapping
    // CRITICAL FIX: Assert on duplicates instead of silent skip
    let mut i = 0;
    while (i < action_types.length()) {
        let action_type = &action_types[i];
        assert!(!registry.action_to_package.contains(*action_type), EActionTypeAlreadyRegistered);
        registry.action_to_package.add(*action_type, name);
        i = i + 1;
    };

    // Create package metadata
    let metadata = PackageMetadata {
        versions: vector[PackageVersion { addr, version }],
        action_types,
        category,
        description,
    };

    // Add to registry
    registry.packages.add(name, metadata);
    registry.by_addr.add(addr, name);
    registry.active_versions.add(addr, version);

    // Emit event
    event::emit(PackageAdded {
        name,
        addr,
        version,
        num_action_types: action_types.length(),
        category,
    });
}

/// Remove a package from the registry
/// Also removes all its action type mappings
///
/// Authorization: Requires &mut PackageRegistry (type-system enforced)
public fun remove_package(
    registry: &mut PackageRegistry,
    name: String,
) {
    assert!(registry.packages.contains(name), EPackageNotFound);

    // Get package metadata to clean up action types
    let metadata = registry.packages.borrow(name);
    let action_types = &metadata.action_types;

    // Remove action type mappings
    let mut i = 0;
    while (i < action_types.length()) {
        let action_type = &action_types[i];
        if (registry.action_to_package.contains(*action_type)) {
            registry.action_to_package.remove(*action_type);
        };
        i = i + 1;
    };

    // Remove version history addresses
    let metadata = registry.packages.remove(name);
    let versions = &metadata.versions;
    let mut j = 0;
    while (j < versions.length()) {
        let pkg_version = &versions[j];
        if (registry.by_addr.contains(pkg_version.addr) &&
            *registry.by_addr.borrow(pkg_version.addr) == name) {
            registry.by_addr.remove(pkg_version.addr);
            registry.active_versions.remove(pkg_version.addr);
        };
        j = j + 1;
    };

    // Destroy metadata
    let PackageMetadata { action_types: _, category: _, description: _, versions: _ } = metadata;

    // Emit event
    event::emit(PackageRemoved { name });
}

/// Add a new version to an existing package
/// Version must be greater than all existing versions (monotonic)
/// Update package version (add a new version)
///
/// Authorization: Requires &mut PackageRegistry (type-system enforced)
public fun update_package_version(
    registry: &mut PackageRegistry,
    name: String,
    addr: address,
    version: u64,
) {
    assert!(registry.packages.contains(name), EPackageNotFound);
    assert!(!registry.by_addr.contains(addr), EPackageAlreadyExists);

    // Get package metadata and validate version monotonicity
    let metadata = registry.packages.borrow_mut(name);
    assert!(metadata.versions.length() > 0, EEmptyVersionHistory);

    let latest = &metadata.versions[metadata.versions.length() - 1];
    assert!(version > latest.version, EVersionNotMonotonic);

    // Add new version
    metadata.versions.push_back(PackageVersion { addr, version });

    // Update lookups
    registry.by_addr.add(addr, name);
    registry.active_versions.add(addr, version);

    // Emit event
    event::emit(PackageVersionAdded { name, addr, version });
}

/// Remove a specific version from a package's history
public fun remove_package_version(
    registry: &mut PackageRegistry,
    _cap: &PackageAdminCap,
    name: String,
    addr: address,
    version: u64,
) {
    assert!(registry.packages.contains(name), EPackageNotFound);

    let metadata = registry.packages.borrow_mut(name);
    let versions = &mut metadata.versions;

    // Find and remove the version
    let mut i = 0;
    let mut found = false;
    while (i < versions.length()) {
        let pkg_version = &versions[i];
        if (pkg_version.addr == addr && pkg_version.version == version) {
            versions.remove(i);
            found = true;
            break
        };
        i = i + 1;
    };

    assert!(found, EPackageNotFound);

    // CRITICAL FIX: Only remove lookups if address is no longer used by any version
    let metadata_ref = registry.packages.borrow(name);
    let mut address_still_in_use = false;
    let mut k = 0;
    while (k < metadata_ref.versions.length()) {
        if (metadata_ref.versions[k].addr == addr) {
            address_still_in_use = true;
            break
        };
        k = k + 1;
    };

    if (!address_still_in_use) {
        if (registry.by_addr.contains(addr)) {
            registry.by_addr.remove(addr);
        };
        if (registry.active_versions.contains(addr)) {
            registry.active_versions.remove(addr);
        };
    };

    // Emit event
    event::emit(PackageVersionRemoved { name, addr, version });
}

/// Update package metadata (category, description, action types)
///
/// Authorization: Requires &mut PackageRegistry (type-system enforced)
public fun update_package_metadata(
    registry: &mut PackageRegistry,
    name: String,
    new_action_types: vector<String>,
    new_category: String,
    new_description: String,
) {
    assert!(registry.packages.contains(name), EPackageNotFound);

    let metadata = registry.packages.borrow_mut(name);

    // Remove old action type mappings
    let old_action_types = &metadata.action_types;
    let mut i = 0;
    while (i < old_action_types.length()) {
        let action_type = &old_action_types[i];
        if (registry.action_to_package.contains(*action_type)) {
            registry.action_to_package.remove(*action_type);
        };
        i = i + 1;
    };

    // Add new action type mappings
    // CRITICAL FIX: Assert on duplicates instead of silent skip
    let mut j = 0;
    while (j < new_action_types.length()) {
        let action_type = &new_action_types[j];
        assert!(!registry.action_to_package.contains(*action_type), EActionTypeAlreadyRegistered);
        registry.action_to_package.add(*action_type, name);
        j = j + 1;
    };

    // Update metadata
    metadata.action_types = new_action_types;
    metadata.category = new_category;
    metadata.description = new_description;

    // Emit event
    event::emit(PackageMetadataUpdated {
        name,
        num_action_types: new_action_types.length(),
        category: new_category,
    });
}

/// Pause account creation system-wide
/// Requires PackageAdminCap to authorize
/// When paused, all calls to account::new() will abort
///
/// For governance use: Lock the PackageAdminCap in the DAO account first using
/// access_control::lock_cap(), then borrow it in governance actions
public fun pause_account_creation(
    registry: &mut PackageRegistry,
    _cap: &PackageAdminCap,
) {
    registry.account_creation_paused = true;
}

/// Pause account creation system-wide (without cap check)
/// IMPORTANT: Authorization must be verified by caller before calling this function
/// This is an internal API for governance actions where the cap check is done separately
/// to avoid borrow checker conflicts
public fun pause_account_creation_authorized(
    registry: &mut PackageRegistry,
) {
    registry.account_creation_paused = true;
}

/// Unpause account creation system-wide
/// Requires PackageAdminCap to authorize
///
/// For governance use: Lock the PackageAdminCap in the DAO account first using
/// access_control::lock_cap(), then borrow it in governance actions
public fun unpause_account_creation(
    registry: &mut PackageRegistry,
    _cap: &PackageAdminCap,
) {
    registry.account_creation_paused = false;
}

/// Unpause account creation system-wide (without cap check)
/// IMPORTANT: Authorization must be verified by caller before calling this function
/// This is an internal API for governance actions where the cap check is done separately
/// to avoid borrow checker conflicts
public fun unpause_account_creation_authorized(
    registry: &mut PackageRegistry,
) {
    registry.account_creation_paused = false;
}

// === View Functions ===

/// Check if a package exists
public fun has_package(registry: &PackageRegistry, name: String): bool {
    registry.packages.contains(name)
}

/// Check if an action type has a registered package
public fun has_action_type(registry: &PackageRegistry, action_type: String): bool {
    registry.action_to_package.contains(action_type)
}

/// Get which package provides an action type
public fun get_package_for_action(registry: &PackageRegistry, action_type: String): String {
    assert!(registry.action_to_package.contains(action_type), EActionTypeNotFound);
    *registry.action_to_package.borrow(action_type)
}

/// Get package metadata
public fun get_package_metadata(registry: &PackageRegistry, name: String): &PackageMetadata {
    assert!(registry.packages.contains(name), EPackageNotFound);
    registry.packages.borrow(name)
}

/// Get latest version for a package
public fun get_latest_version(registry: &PackageRegistry, name: String): (address, u64) {
    assert!(registry.packages.contains(name), EPackageNotFound);
    let metadata = registry.packages.borrow(name);
    let versions = &metadata.versions;
    assert!(versions.length() > 0, EEmptyVersionHistory);

    let latest = &versions[versions.length() - 1];
    (latest.addr, latest.version)
}

/// Check if a specific (name, addr, version) triple is valid
/// This is the compatibility function for Extensions::is_extension
public fun is_valid_package(
    registry: &PackageRegistry,
    name: String,
    addr: address,
    version: u64,
): bool {
    if (!registry.packages.contains(name)) return false;
    if (!registry.active_versions.contains(addr)) return false;
    if (!registry.by_addr.contains(addr)) return false;

    // CRITICAL FIX: Use borrow() to avoid panic
    *registry.by_addr.borrow(addr) == name && *registry.active_versions.borrow(addr) == version
}

/// Check if a package address exists in the registry
public fun contains_package_addr(registry: &PackageRegistry, addr: address): bool {
    registry.by_addr.contains(addr)
}

/// Get package name from address
public fun get_package_name(registry: &PackageRegistry, addr: address): String {
    assert!(registry.by_addr.contains(addr), EPackageNotFound);
    *registry.by_addr.borrow(addr)
}

/// Get all action types for a package
public fun get_action_types(registry: &PackageRegistry, name: String): &vector<String> {
    assert!(registry.packages.contains(name), EPackageNotFound);
    let metadata = registry.packages.borrow(name);
    &metadata.action_types
}

/// Get package category
public fun get_category(registry: &PackageRegistry, name: String): &String {
    assert!(registry.packages.contains(name), EPackageNotFound);
    let metadata = registry.packages.borrow(name);
    &metadata.category
}

/// Get package description
public fun get_description(registry: &PackageRegistry, name: String): &String {
    assert!(registry.packages.contains(name), EPackageNotFound);
    let metadata = registry.packages.borrow(name);
    &metadata.description
}

/// Get version history for a package
public fun get_versions(registry: &PackageRegistry, name: String): &vector<PackageVersion> {
    assert!(registry.packages.contains(name), EPackageNotFound);
    let metadata = registry.packages.borrow(name);
    &metadata.versions
}

/// Get registry ID for dynamic field access (decoders)
public fun registry_id(registry: &PackageRegistry): &UID {
    &registry.id
}

/// Get mutable registry ID for adding decoders
public fun registry_id_mut(registry: &mut PackageRegistry): &mut UID {
    &mut registry.id
}

/// Check if account creation is currently paused
public fun is_account_creation_paused(registry: &PackageRegistry): bool {
    registry.account_creation_paused
}

// === PackageMetadata Accessors ===

/// Get action types from metadata
public fun metadata_action_types(metadata: &PackageMetadata): &vector<String> {
    &metadata.action_types
}

/// Get category from metadata
public fun metadata_category(metadata: &PackageMetadata): &String {
    &metadata.category
}

/// Get description from metadata
public fun metadata_description(metadata: &PackageMetadata): &String {
    &metadata.description
}

/// Get versions from metadata
public fun metadata_versions(metadata: &PackageMetadata): &vector<PackageVersion> {
    &metadata.versions
}

// === Helper Functions ===

/// Create a human-readable field for decoder output
public fun new_field(name: String, value: String, type_name: String): HumanReadableField {
    HumanReadableField { name, value, type_name }
}

/// Get field name
public fun field_name(field: &HumanReadableField): &String {
    &field.name
}

/// Get field value
public fun field_value(field: &HumanReadableField): &String {
    &field.value
}

/// Get field type
public fun field_type(field: &HumanReadableField): &String {
    &field.type_name
}

/// Check if decoder exists for action type (via dynamic object field)
/// Action type should be the full type name as a string
public fun has_package_decoder(registry: &PackageRegistry, action_type: String): bool {
    // For dynamic field lookup, we need to convert string to TypeName
    // This is a simplified check - actual decoder attachment happens externally
    registry.action_to_package.contains(action_type)
}

// === PackageVersion Accessors ===

public fun version_addr(version: &PackageVersion): address {
    version.addr
}

public fun version_number(version: &PackageVersion): u64 {
    version.version
}

public fun new_package_version(addr: address, version: u64): PackageVersion {
    PackageVersion { addr, version }
}

// === Test-Only Functions ===

#[test_only]
public fun init_for_testing(ctx: &mut TxContext) {
    init(ctx);
}

#[test_only]
public fun new_for_testing(ctx: &mut TxContext): PackageRegistry {
    PackageRegistry {
        id: object::new(ctx),
        packages: table::new(ctx),
        by_addr: table::new(ctx),
        active_versions: table::new(ctx),
        action_to_package: table::new(ctx),
        account_creation_paused: false,
    }
}

#[test_only]
public fun new_admin_cap_for_testing(ctx: &mut TxContext): PackageAdminCap {
    PackageAdminCap { id: object::new(ctx) }
}

#[test_only]
public fun add_for_testing(
    registry: &mut PackageRegistry,
    name: String,
    addr: address,
    version: u64,
) {
    add_package(
        registry,
        name,
        addr,
        version,
        vector[], // empty action types for testing
        b"test".to_string(),
        b"test package".to_string(),
    );
}

#[test_only]
public fun remove_for_testing(registry: &mut PackageRegistry, name: String) {
    remove_package(
        registry,
        name,
    );
}

#[test_only]
public fun update_for_testing(
    registry: &mut PackageRegistry,
    name: String,
    addr: address,
    version: u64,
) {
    update_package_version(
        registry,
        name,
        addr,
        version,
    );
}

#[test_only]
public fun share_for_testing(registry: PackageRegistry) {
    transfer::share_object(registry);
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

// ============================================================================
// Action Type Validation Helper Module
// ============================================================================
// This module provides a centralized type validation helper for action handlers.
// It ensures type safety by verifying that action specs match expected types
// before deserialization, preventing type confusion vulnerabilities.
//
// SECURITY: This is a critical security module that prevents wrong actions
// from being executed by wrong handlers.
// ============================================================================

module account_protocol::action_validation;

// === Imports ===

use std::type_name::{Self, TypeName};
use account_protocol::intents::{Self, ActionSpec};

// === Errors ===

const EWrongActionType: u64 = 0;

// === Public Functions ===

/// Assert that an ActionSpec has the expected action type.
/// This MUST be called before deserializing action data in any do_* function.
///
/// # Type Parameters
/// * `T` - The expected action type (must have `drop`)
///
/// # Arguments
/// * `spec` - The ActionSpec to validate
///
/// # Aborts
/// * `EWrongActionType` - If the action type doesn't match the expected type
///
/// # Example
/// ```move
/// public fun do_spend<...>(...) {
///     let spec = specs.borrow(executable.action_idx());
///     action_validation::assert_action_type<VaultSpend>(spec);
///     // Now safe to deserialize
///     let action_data = intents::action_spec_data(spec);
/// }
/// ```
public fun assert_action_type<T: drop>(spec: &ActionSpec) {
    let expected_type = type_name::with_defining_ids<T>();
    assert!(
        intents::action_spec_type(spec) == expected_type,
        EWrongActionType
    );
}

/// Assert that an ActionSpec has the expected action type with custom error.
/// Useful when modules want to use their own error codes.
///
/// # Type Parameters
/// * `T` - The expected action type (must have `drop`)
///
/// # Arguments
/// * `spec` - The ActionSpec to validate
/// * `error_code` - Custom error code to use if validation fails
///
/// # Aborts
/// * Custom error code if the action type doesn't match
public fun assert_action_type_with_error<T: drop>(
    spec: &ActionSpec,
    error_code: u64
) {
    let expected_type = type_name::with_defining_ids<T>();
    assert!(
        intents::action_spec_type(spec) == expected_type,
        error_code
    );
}

/// Check if an ActionSpec matches the expected type without aborting.
/// Returns true if types match, false otherwise.
///
/// # Type Parameters
/// * `T` - The expected action type (must have `drop`)
///
/// # Arguments
/// * `spec` - The ActionSpec to check
///
/// # Returns
/// * `bool` - true if action type matches, false otherwise
public fun is_action_type<T: drop>(spec: &ActionSpec): bool {
    let expected_type = type_name::with_defining_ids<T>();
    intents::action_spec_type(spec) == expected_type
}

/// Get the TypeName for a given action type.
/// Useful for modules that need to work with TypeNames directly.
///
/// # Type Parameters
/// * `T` - The action type (must have `drop`)
///
/// # Returns
/// * `TypeName` - The TypeName of the action type
public fun get_action_type_name<T: drop>(): TypeName {
    type_name::with_defining_ids<T>()
}

// === Test Functions ===

#[test_only]
public struct TestAction has drop {}

#[test_only]
fun create_test_action_spec<T>(): ActionSpec {
    use account_protocol::intents;
    intents::new_action_spec<T>(vector::empty(), 1)
}

#[test_only]
public struct WrongAction has drop {}

#[test]
fun test_assert_action_type_success() {
    let spec = create_test_action_spec<TestAction>();
    assert_action_type<TestAction>(&spec);
    // Should not abort
}

#[test]
#[expected_failure(abort_code = EWrongActionType)]
fun test_assert_action_type_failure() {
    let spec = create_test_action_spec<TestAction>();
    assert_action_type<WrongAction>(&spec);
    // Should abort with EWrongActionType
}

#[test]
fun test_is_action_type() {
    let spec = create_test_action_spec<TestAction>();
    assert!(is_action_type<TestAction>(&spec));
    assert!(!is_action_type<WrongAction>(&spec));
}

#[test]
#[expected_failure(abort_code = 999)]
fun test_assert_action_type_with_custom_error() {
    let spec = create_test_action_spec<TestAction>();
    assert_action_type_with_error<WrongAction>(&spec, 999);
    // Should abort with custom error 999
}// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

// Portions of this file are derived from the account.tech Move Framework project.
// Those portions remain licensed under the Apache License, Version 2.0.

/// This is the core module managing the account Account.
/// It provides the apis to create, approve and execute intents with actions.
///
/// The flow is as follows:
///   1. An intent is created by stacking actions into it.
///      Actions are pushed from first to last, they must be executed then destroyed in the same order.
///   2. When the intent is resolved (threshold reached, quorum reached, etc), it can be executed.
///      This returns an Executable hot potato constructed from certain fields of the validated Intent.
///      It is directly passed into action functions to enforce account approval for an action to be executed.
///   3. The module that created the intent must destroy all of the actions and the Executable after execution
///      by passing the same witness that was used for instantiation.
///      This prevents the actions or the intent to be stored instead of executed.
///
/// Dependencies can create and manage dynamic fields for an account.
/// They should use custom types as keys to enable access only via the accessors defined.
///
/// Functions related to authentication, intent resolution, state of intents and config for an account type
/// must be called from the module that defines the config of the account.
/// They necessitate a config_witness to ensure the caller is a dependency of the account.
///
/// The rest of the functions manipulating the common state of accounts are only called within this package.

module account_protocol::account;

use account_protocol::package_registry;
use account_protocol::deps::{Self, Deps};
use account_protocol::executable::{Self, Executable};
use account_protocol::intents::{Self, Intents, Intent, Expired, Params};
use account_protocol::metadata::{Self, Metadata};
use account_protocol::version;
use account_protocol::version_witness::{Self, VersionWitness};
use std::option::Option;
use std::string::String;
use std::type_name::{Self, TypeName};
use sui::clock::Clock;
use sui::dynamic_field as df;
use sui::dynamic_object_field as dof;
use sui::event;
use sui::package;
use sui::transfer::Receiving;
use sui::vec_set::{Self, VecSet};

// === Imports ===

// === Errors ===

const ECantBeRemovedYet: u64 = 1;
const EHasntExpired: u64 = 2;
const ECantBeExecutedYet: u64 = 3;
const EWrongAccount: u64 = 4;
const ENotCalledFromConfigModule: u64 = 5;
const EActionsRemaining: u64 = 6;
const EManagedDataAlreadyExists: u64 = 7;
const EManagedDataDoesntExist: u64 = 8;
const EManagedAssetAlreadyExists: u64 = 9;
const EManagedAssetDoesntExist: u64 = 10;
const EDepositsDisabled: u64 = 11;
const EObjectCountUnderflow: u64 = 12;
const EWhitelistTooLarge: u64 = 13;
const EObjectLimitReached: u64 = 14;
const EMaxObjectsReached: u64 = 14;
const EWrongConfigType: u64 = 15;
const ENotConfigModule: u64 = 16;
const EAccountCreationPaused: u64 = 17;

// === Structs ===

public struct ACCOUNT has drop {}

/// Shared multisig Account object.
/// Config is stored as a dynamic field to allow runtime config migration
public struct Account has key, store {
    id: UID,
    // arbitrary data that can be proposed and added by members
    // first field is a human readable name to differentiate the multisig accounts
    metadata: Metadata,
    // ids and versions of the packages this account is using
    // idx 0: account_protocol, idx 1: account_actions optionally
    // Note: registry_id is now stored within Deps
    deps: Deps,
    // open intents, key should be a unique descriptive name
    intents: Intents,
    // config: Config,  ‚Üê MOVED TO DYNAMIC FIELD (see ConfigKey below)
}

/// Object tracking state stored as dynamic field
/// Separate struct to allow extensions to interact without circular deps
public struct ObjectTracker has copy, drop, store {}

public struct ObjectTrackerState has copy, store {
    // Current object count (excluding coins)
    object_count: u128,
    // Whether permissionless deposits are enabled
    deposits_open: bool,
    // Maximum objects before auto-disabling deposits
    max_objects: u128,
    // Whitelisted types that bypass restrictions (O(1) lookups with VecSet)
    // Store canonical string representation for serializability
    whitelisted_types: VecSet<String>,
}

// === Dynamic Field Keys for Config Storage ===

/// Key for storing config as a dynamic field
public struct ConfigKey has copy, drop, store {}

/// Key for storing config type name (for runtime validation)
public struct ConfigTypeKey has copy, drop, store {}

// === Events ===

/// Protected type ensuring provenance, authenticate an address to an account.
public struct Auth {
    // address of the account that created the auth
    account_addr: address,
}

// === Upgradeable Configuration Functions ===
// These are functions (not constants) so they can be changed in package upgrades

/// Maximum whitelist size - can be changed in future upgrades
public fun max_whitelist_size(): u64 {
    50 // Reasonable limit - can increase in upgrades if needed
}

/// Default max objects - can be changed in future upgrades
public fun default_max_objects(): u128 {
    10000 // Adjust this in future upgrades if needed
}

//**************************************************************************************************//
// Public functions                                                                                //
//**************************************************************************************************//

fun init(otw: ACCOUNT, ctx: &mut TxContext) {
    package::claim_and_keep(otw, ctx); // to create Display objects in the future
}

/// Initialize object tracking for an account (called during account creation)
public(package) fun init_object_tracker(account: &mut Account, max_objects: u128) {
    if (!df::exists_(&account.id, ObjectTracker {})) {
        df::add(
            &mut account.id,
            ObjectTracker {},
            ObjectTrackerState {
                object_count: 0,
                deposits_open: true,
                max_objects: if (max_objects > 0) max_objects else default_max_objects(),
                whitelisted_types: vec_set::empty(),
            },
        );
    }
}

/// Get or create object tracker state
public(package) fun ensure_object_tracker(
    account: &mut Account,
): &mut ObjectTrackerState {
    if (!df::exists_(&account.id, ObjectTracker {})) {
        init_object_tracker(account, default_max_objects());
    };
    df::borrow_mut(&mut account.id, ObjectTracker {})
}

/// Apply deposit configuration changes
public(package) fun apply_deposit_config(
    account: &mut Account,
    enable: bool,
    new_max: Option<u128>,
    reset_counter: bool,
) {
    let tracker = ensure_object_tracker(account);
    tracker.deposits_open = enable;

    if (new_max.is_some()) {
        tracker.max_objects = *new_max.borrow();
    };

    if (reset_counter) {
        tracker.object_count = 0;
    };
}

/// Apply whitelist changes
public(package) fun apply_whitelist_changes(
    account: &mut Account,
    add_types: &vector<String>,
    remove_types: &vector<String>,
) {
    let tracker = ensure_object_tracker(account);

    // Remove types first
    let mut i = 0;
    while (i < remove_types.length()) {
        let type_str = &remove_types[i];
        vec_set::remove(&mut tracker.whitelisted_types, type_str);
        i = i + 1;
    };

    // Add new types with size check
    i = 0;
    while (i < add_types.length()) {
        let type_str = add_types[i];
        if (!vec_set::contains(&tracker.whitelisted_types, &type_str)) {
            assert!(
                vec_set::size(&tracker.whitelisted_types) < max_whitelist_size(),
                EWhitelistTooLarge,
            );
            vec_set::insert(&mut tracker.whitelisted_types, type_str);
        };
        i = i + 1;
    };

    // Whitelist updated
}

/// Verifies all actions have been processed and destroys the executable.
/// Called to complete the intent execution.
public fun confirm_execution<Outcome: drop + store>(
    account: &mut Account,
    executable: Executable<Outcome>,
) {
    let actions_length = executable.intent().action_specs().length();
    assert!(executable.action_idx() == actions_length, EActionsRemaining);

    let intent = executable.destroy();
    intent.assert_is_account(account.addr());

    account.intents.add_intent(intent);
}

/// Destroys an intent if it has no remaining execution.
/// Expired needs to be emptied by deleting each action in the bag within their own module.
public fun destroy_empty_intent<Outcome: store + drop>(
    account: &mut Account,
    key: String,
    ctx: &mut TxContext,
): Expired {
    assert!(account.intents.get<Outcome>(key).execution_times().is_empty(), ECantBeRemovedYet);
    account.intents.destroy_intent<Outcome>(key, ctx)
}

/// Destroys an intent if it has expired.
/// Expired needs to be emptied by deleting each action in the bag within their own module.
public fun delete_expired_intent<Outcome: store + drop>(
    account: &mut Account,
    key: String,
    clock: &Clock,
    ctx: &mut TxContext,
): Expired {
    assert!(
        clock.timestamp_ms() >= account.intents.get<Outcome>(key).expiration_time(),
        EHasntExpired,
    );
    account.intents.destroy_intent<Outcome>(key, ctx)
}

/// Asserts that the function is called from the module defining the config of the account.
/// Static version: validate witness matches config type (no account needed)
fun assert_is_config_module_static<Config, CW: drop>() {
    let config_type = type_name::with_defining_ids<Config>();
    let witness_type = type_name::with_defining_ids<CW>();
    assert!(
        config_type.address_string() == witness_type.address_string() &&
        config_type.module_string() == witness_type.module_string(),
        ENotConfigModule,
    );
}

/// Runtime version: validate witness matches stored config type
public(package) fun assert_is_config_module<Config: store, CW: drop>(
    account: &Account,
    _config_witness: CW,
) {
    // First check the stored type matches requested type
    let stored_type = df::borrow<ConfigTypeKey, TypeName>(&account.id, ConfigTypeKey {});
    let requested_type = type_name::get<Config>();
    assert!(&requested_type == stored_type, EWrongConfigType);

    // Then validate witness package/module matches config
    assert_is_config_module_static<Config, CW>();
}

/// Witness-only version: validate witness matches stored config type (no explicit Config needed)
public(package) fun assert_is_config_module_witness<CW: drop>(
    account: &Account,
    _config_witness: CW,
) {
    // Get the stored config type
    let stored_type = df::borrow<ConfigTypeKey, TypeName>(&account.id, ConfigTypeKey {});
    let witness_type = type_name::with_defining_ids<CW>();

    // Validate witness package/module matches stored config package/module
    assert!(
        stored_type.address_string() == witness_type.address_string() &&
        stored_type.module_string() == witness_type.module_string(),
        ENotConfigModule,
    );
}

/// Cancel an active intent and return its Expired bag for GC draining.
///
/// Security:
/// - `config_witness` gates **authority**: only the Config module may cancel.
/// - `deps_witness` gates **compatibility**: caller must be compiled against the
///   same `account_protocol` package identity/version the Account expects.
///   This prevents mismatched callers from older/newer packages.
public fun cancel_intent<Config: store, Outcome: store + drop, CW: drop>(
    account: &mut Account,
    key: String,
    deps_witness: VersionWitness,
    config_witness: CW,
    ctx: &mut TxContext,
): Expired {
    // deps_witness validation removed - not needed for destroy_empty_intent
    // Only the config module may cancel
    assert_is_config_module_witness(account, config_witness);
    // Convert to Expired - deleters will handle unlocking during drain
    account.intents.destroy_intent<Outcome>(key, ctx)
}

/// Helper function to transfer an object to the account with tracking.
/// Excludes Coin types and whitelisted types from restrictions.
public fun keep<T: key + store>(account: &mut Account, obj: T, ctx: &TxContext) {
    let type_name = type_name::with_defining_ids<T>();
    let is_coin = is_coin_type(type_name);

    // Check if type is whitelisted
    let is_whitelisted = {
        let tracker = ensure_object_tracker(account);
        let ascii_str = type_name::into_string(type_name);
        let type_str = ascii_str.to_string();
        vec_set::contains(&tracker.whitelisted_types, &type_str)
    };

    // Only apply restrictions to non-coin, non-whitelisted types
    if (!is_coin && !is_whitelisted) {
        // Get tracker state for checking
        let (deposits_open, sender_is_self) = {
            let tracker = ensure_object_tracker(account);
            (tracker.deposits_open, ctx.sender() == account.addr())
        };

        // Check if deposits are allowed
        if (!deposits_open) {
            // Allow self-deposits even when closed
            assert!(sender_is_self, EDepositsDisabled);
        };

        // Now update tracker state
        let tracker = ensure_object_tracker(account);

        // Increment counter only for restricted types
        tracker.object_count = tracker.object_count + 1;

        // Auto-disable if hitting threshold
        if (tracker.object_count >= tracker.max_objects) {
            tracker.deposits_open = false;
            // Auto-disabled deposits at threshold
        };
    };

    transfer::public_transfer(obj, account.addr());
}

/// Unpacks and verifies the Auth matches the account.
public fun verify(account: &Account, auth: Auth) {
    let Auth { account_addr } = auth;

    assert!(account.addr() == account_addr, EWrongAccount);
}

/// Returns the account address from Auth.
public fun auth_account_addr(auth: &Auth): address {
    auth.account_addr
}

//**************************************************************************************************//
// Deps-only functions                                                                              //
//**************************************************************************************************//

/// The following functions are used to compose intents in external modules and packages.
///
/// The proper instantiation and execution of an intent is ensured by an intent witness.
/// This is a drop only type defined in the intent module preventing other modules to misuse the intent.
///
/// Additionally, these functions require a version witness which is a protected type for the protocol.
/// It is checked against the dependencies of the account to ensure the package being called is authorized.
/// VersionWitness is a wrapper around a type defined in the version of the package being called.
/// It behaves like a witness but it is usable in the entire package instead of in a single module.

/// Creates a new intent. Can only be called from a dependency of the account.
public fun create_intent<Outcome: store, IW: drop>(
    account: &Account,
    registry: &package_registry::PackageRegistry,
    params: Params,
    outcome: Outcome, // resolution settings
    managed_name: String, // managed struct/object name for the role
    version_witness: VersionWitness, // proof of the package address that creates the intent
    intent_witness: IW, // intent witness
    ctx: &mut TxContext,
): Intent<Outcome> {
    // ensures the package address is a dependency for this account OR in the global whitelist
    account.deps().check(version_witness, registry);

    params.new_intent(
        outcome,
        managed_name,
        account.addr(),
        intent_witness,
        ctx,
    )
}

/// Adds an intent to the account. Can only be called from a dependency of the account.
public fun insert_intent<Outcome: store, IW: drop>(
    account: &mut Account,
    registry: &package_registry::PackageRegistry,
    intent: Intent<Outcome>,
    version_witness: VersionWitness,
    intent_witness: IW,
) {
    // ensures the package address is a dependency for this account
    account.deps().check(version_witness, registry);
    // ensures the right account is passed
    intent.assert_is_account(account.addr());
    // ensures the intent is created by the same package that creates the action
    intent.assert_is_witness(intent_witness);

    account.intents.add_intent(intent);
}

/// Managed data and assets:
/// Data structs and Assets objects attached as dynamic fields to the account object.
/// They are separated to improve objects discoverability on frontends and indexers.
/// Keys must be custom types defined in the same module where the function is implemented.

/// Adds a managed data struct to the account.
public fun add_managed_data<Key: copy + drop + store, Data: store>(
    account: &mut Account,
    registry: &package_registry::PackageRegistry,
    key: Key,
    data: Data,
    version_witness: VersionWitness,
) {
    assert!(!has_managed_data(account, key), EManagedDataAlreadyExists);
    account.deps().check(version_witness, registry);
    df::add(&mut account.id, key, data);
}

/// Checks if a managed data struct exists in the account.
public fun has_managed_data<Key: copy + drop + store>(
    account: &Account,
    key: Key,
): bool {
    df::exists_(&account.id, key)
}

/// Borrows a managed data struct from the account.
public fun borrow_managed_data<Key: copy + drop + store, Data: store>(
    account: &Account,
    registry: &package_registry::PackageRegistry,
    key: Key,
    version_witness: VersionWitness,
): &Data {
    assert!(has_managed_data(account, key), EManagedDataDoesntExist);
    account.deps().check(version_witness, registry);
    df::borrow(&account.id, key)
}

/// Borrows a managed data struct mutably from the account.
public fun borrow_managed_data_mut<Key: copy + drop + store, Data: store>(
    account: &mut Account,
    registry: &package_registry::PackageRegistry,
    key: Key,
    version_witness: VersionWitness,
): &mut Data {
    assert!(has_managed_data(account, key), EManagedDataDoesntExist);
    account.deps().check(version_witness, registry);
    df::borrow_mut(&mut account.id, key)
}

/// Removes a managed data struct from the account.
public fun remove_managed_data<Key: copy + drop + store, A: store>(
    account: &mut Account,
    registry: &package_registry::PackageRegistry,
    key: Key,
    version_witness: VersionWitness,
): A {
    assert!(has_managed_data(account, key), EManagedDataDoesntExist);
    account.deps().check(version_witness, registry);
    df::remove(&mut account.id, key)
}

/// Adds a managed object to the account.
public fun add_managed_asset<Key: copy + drop + store, Asset: key + store>(
    account: &mut Account,
    registry: &package_registry::PackageRegistry,
    key: Key,
    asset: Asset,
    version_witness: VersionWitness,
) {
    assert!(!has_managed_asset(account, key), EManagedAssetAlreadyExists);
    account.deps().check(version_witness, registry);
    dof::add(&mut account.id, key, asset);
}

/// Checks if a managed object exists in the account.
public fun has_managed_asset<Key: copy + drop + store>(
    account: &Account,
    key: Key,
): bool {
    dof::exists_(&account.id, key)
}

/// Borrows a managed object from the account.
public fun borrow_managed_asset<Key: copy + drop + store, Asset: key + store>(
    account: &Account,
    registry: &package_registry::PackageRegistry,
    key: Key,
    version_witness: VersionWitness,
): &Asset {
    assert!(has_managed_asset(account, key), EManagedAssetDoesntExist);
    account.deps().check(version_witness, registry);
    dof::borrow(&account.id, key)
}

/// Borrows a managed object mutably from the account.
public fun borrow_managed_asset_mut<Key: copy + drop + store, Asset: key + store>(
    account: &mut Account,
    registry: &package_registry::PackageRegistry,
    key: Key,
    version_witness: VersionWitness,
): &mut Asset {
    assert!(has_managed_asset(account, key), EManagedAssetDoesntExist);
    account.deps().check(version_witness, registry);
    dof::borrow_mut(&mut account.id, key)
}

/// Removes a managed object from the account.
public fun remove_managed_asset<Key: copy + drop + store, Asset: key + store>(
    account: &mut Account,
    registry: &package_registry::PackageRegistry,
    key: Key,
    version_witness: VersionWitness,
): Asset {
    assert!(has_managed_asset(account, key), EManagedAssetDoesntExist);
    account.deps().check(version_witness, registry);
    dof::remove(&mut account.id, key)
}

//**************************************************************************************************//
// Config-only functions                                                                            //
//**************************************************************************************************//

/// The following functions are used to define account and intent behavior for a specific account type/config.
///
/// They must be implemented in the module that defines the config of the account, which must be a dependency of the account.
/// We provide higher level macros to facilitate the implementation of these functions.

/// Creates a new account with default dependencies. Can only be called from the config module.
public fun new<Config: store, CW: drop>(
    config: Config,
    deps: Deps,
    registry: &package_registry::PackageRegistry,
    version_witness: VersionWitness,
    config_witness: CW,
    ctx: &mut TxContext,
): Account {
    // Check if account creation is paused
    assert!(!package_registry::is_account_creation_paused(registry), EAccountCreationPaused);

    // Validate witness matches config module at compile time
    assert_is_config_module_static<Config, CW>();

    let mut account = Account {
        id: object::new(ctx),
        metadata: metadata::empty(),
        deps,
        intents: intents::empty(ctx),
    };

    account.deps().check(version_witness, registry);

    // Store config and its type as dynamic fields
    df::add(&mut account.id, ConfigKey {}, config);
    df::add(&mut account.id, ConfigTypeKey {}, type_name::get<Config>());

    account
}

/// Returns an Auth object that can be used to call gated functions. Can only be called from the config module.
public fun new_auth<Config: store, CW: drop>(
    account: &Account,
    registry: &package_registry::PackageRegistry,
    version_witness: VersionWitness,
    config_witness: CW,
): Auth {
    account.deps().check(version_witness, registry);
    assert_is_config_module<Config, CW>(account, config_witness);

    Auth { account_addr: account.addr() }
}

/// Returns a tuple of the outcome that must be validated and the executable. Can only be called from the config module.
public fun create_executable<Config: store, Outcome: store + copy, CW: drop>(
    account: &mut Account,
    registry: &package_registry::PackageRegistry,
    key: String,
    clock: &Clock,
    version_witness: VersionWitness,
    config_witness: CW,
    ctx: &mut TxContext, // Kept for API compatibility
): (Outcome, Executable<Outcome>) {
    account.deps().check(version_witness, registry);
    assert_is_config_module<Config, CW>(account, config_witness);

    let mut intent = account.intents.remove_intent<Outcome>(key);
    let time = intent.pop_front_execution_time();
    assert!(clock.timestamp_ms() >= time, ECantBeExecutedYet);

    (
        *intent.outcome(),
        executable::new(intent, ctx), // ctx no longer used but kept for API compatibility
    )
}

/// Returns a mutable reference to the intents of the account. Can only be called from the config module.
public fun intents_mut<Config: store, CW: drop>(
    account: &mut Account,
    registry: &package_registry::PackageRegistry,
    version_witness: VersionWitness,
    config_witness: CW,
): &mut Intents {
    account.deps().check(version_witness, registry);
    assert_is_config_module<Config, CW>(account, config_witness);

    &mut account.intents
}

/// Returns a mutable reference to the config of the account. Can only be called from the config module.
public fun config_mut<Config: store, CW: drop>(
    account: &mut Account,
    registry: &package_registry::PackageRegistry,
    version_witness: VersionWitness,
    config_witness: CW,
): &mut Config {
    account.deps().check(version_witness, registry);
    assert_is_config_module<Config, CW>(account, config_witness);

    df::borrow_mut<ConfigKey, Config>(&mut account.id, ConfigKey {})
}

/// Migrate account config from one type to another.
///
/// This is a DANGEROUS operation that changes the config type stored in the Account.
/// Should only be called via governance after thorough validation.
///
/// # Type Parameters:
/// * `OldConfig` - Current config type (must match what's stored)
/// * `NewConfig` - New config type to migrate to
///
/// # Arguments:
/// * `account` - The account to migrate
/// * `new_config` - The new config data
/// * `version_witness` - Version witness for dependency checking
///
/// # Returns:
/// The old config (for validation/destruction)
///
/// # Safety:
/// - Checks version witness (ensures caller is approved package)
/// - Validates OldConfig matches stored type
/// - Swaps config dynamic field atomically
/// - Updates type tracking
/// - Returns old config for validation before destruction
///
/// # Aborts:
/// - If OldConfig doesn't match stored config type
/// - If version witness check fails
public(package) fun migrate_config<OldConfig: store, NewConfig: store>(
    account: &mut Account,
    registry: &package_registry::PackageRegistry,
    new_config: NewConfig,
    version_witness: VersionWitness,
): OldConfig {
    // Ensure caller is authorized via deps
    account.deps().check(version_witness, registry);

    // Validate that OldConfig matches what's currently stored
    let stored_type = df::borrow<ConfigTypeKey, TypeName>(&account.id, ConfigTypeKey {});
    let old_type = type_name::get<OldConfig>();
    assert!(&old_type == stored_type, EWrongConfigType);

    // Remove old config from dynamic field
    let old_config: OldConfig = df::remove(&mut account.id, ConfigKey {});

    // Add new config to dynamic field
    df::add(&mut account.id, ConfigKey {}, new_config);

    // Update type tracking
    let _old_type_removed: TypeName = df::remove(&mut account.id, ConfigTypeKey {});
    df::add(&mut account.id, ConfigTypeKey {}, type_name::get<NewConfig>());

    // Return old config for caller to validate/destroy
    old_config
}

//**************************************************************************************************//
// View functions                                                                                   //
//**************************************************************************************************//

/// Returns the address of the account.
public fun addr(account: &Account): address {
    account.id.uid_to_inner().id_to_address()
}

/// Returns the metadata of the account.
public fun metadata(account: &Account): &Metadata {
    &account.metadata
}

/// Returns the dependencies of the account.
public fun deps(account: &Account): &Deps {
    &account.deps
}

/// Returns the intents of the account.
public fun intents(account: &Account): &Intents {
    &account.intents
}

/// Returns the config of the account.
public fun config<Config: store>(account: &Account): &Config {
    df::borrow<ConfigKey, Config>(&account.id, ConfigKey {})
}

/// Returns the type name of the config stored in the account.
/// Useful for migration validation and runtime type checking.
public fun config_type(account: &Account): TypeName {
    *df::borrow<ConfigTypeKey, TypeName>(&account.id, ConfigTypeKey {})
}

/// Returns object tracking stats (count, deposits_open, max)
public fun object_stats(account: &Account): (u128, bool, u128) {
    if (df::exists_(&account.id, ObjectTracker {})) {
        let tracker: &ObjectTrackerState = df::borrow(&account.id, ObjectTracker {});
        (tracker.object_count, tracker.deposits_open, tracker.max_objects)
    } else {
        (0, true, default_max_objects())
    }
}

/// Check if account is accepting object deposits
public fun is_accepting_objects<Config: store>(account: &Account): bool {
    if (df::exists_(&account.id, ObjectTracker {})) {
        let tracker: &ObjectTrackerState = df::borrow(&account.id, ObjectTracker {});
        tracker.deposits_open && tracker.object_count < tracker.max_objects
    } else {
        true // Default open if not initialized
    }
}

/// Configure object deposit settings (requires Auth)
public fun configure_object_deposits<Config: store>(
    auth: Auth,
    account: &mut Account,
    enable: bool,
    new_max: Option<u128>,
    reset_counter: bool,
) {
    account.verify(auth);

    let tracker = ensure_object_tracker(account);
    tracker.deposits_open = enable;

    if (new_max.is_some()) {
        tracker.max_objects = *new_max.borrow();
    };

    if (reset_counter) {
        tracker.object_count = 0;
    };
}

/// Manage whitelist for object types (requires Auth)
public fun manage_type_whitelist<Config: store>(
    auth: Auth,
    account: &mut Account,
    add_types: vector<String>,
    remove_types: vector<String>,
) {
    account.verify(auth);

    let tracker = ensure_object_tracker(account);

    // Remove types first (in case of duplicates in add/remove)
    let mut i = 0;
    while (i < remove_types.length()) {
        let type_str = &remove_types[i];
        vec_set::remove(&mut tracker.whitelisted_types, type_str);
        i = i + 1;
    };

    // Add new types (check size limit)
    i = 0;
    while (i < add_types.length()) {
        let type_str = add_types[i];
        if (!vec_set::contains(&tracker.whitelisted_types, &type_str)) {
            // Check size limit before adding
            assert!(
                vec_set::size(&tracker.whitelisted_types) < max_whitelist_size(),
                EWhitelistTooLarge,
            );
            vec_set::insert(&mut tracker.whitelisted_types, type_str);
        };
        i = i + 1;
    };
    // Whitelist updated
}

/// Get whitelisted types for inspection/debugging
public fun get_whitelisted_types<Config: store>(account: &Account): vector<String> {
    if (df::exists_(&account.id, ObjectTracker {})) {
        let tracker: &ObjectTrackerState = df::borrow(&account.id, ObjectTracker {});
        vec_set::into_keys(tracker.whitelisted_types) // Convert VecSet to vector
    } else {
        vector::empty()
    }
}

/// Check if a specific type is whitelisted
public fun is_type_whitelisted<Config, T>(account: &Account): bool {
    if (df::exists_(&account.id, ObjectTracker {})) {
        let tracker: &ObjectTrackerState = df::borrow(&account.id, ObjectTracker {});
        // Convert TypeName to String for the lookup
        let type_name = type_name::with_defining_ids<T>();
        let ascii_str = type_name::into_string(type_name);
        let type_str = ascii_str.to_string();
        vec_set::contains(&tracker.whitelisted_types, &type_str)
    } else {
        false
    }
}

/// Helper to check if a TypeName represents a Coin type
fun is_coin_type(type_name: TypeName): bool {
    // Check if the type is a Coin type by checking if it starts with
    // the Coin module prefix from the Sui framework
    let type_addr = type_name::address_string(&type_name);

    // Check if this is from the Sui framework and the module is "coin"
    if (
        type_addr == b"0000000000000000000000000000000000000000000000000000000000000002".to_ascii_string()
    ) {
        let module_name = type_name::module_string(&type_name);
        module_name == b"coin".to_ascii_string()
    } else {
        false
    }
}

//**************************************************************************************************//
// Package functions                                                                                //
//**************************************************************************************************//

/// Returns a mutable reference to the metadata of the account.
public(package) fun metadata_mut(
    account: &mut Account,
    registry: &package_registry::PackageRegistry,
    version_witness: VersionWitness,
): &mut Metadata {
    // ensures the package address is a dependency for this account
    account.deps().check(version_witness, registry);
    &mut account.metadata
}

// Deps are no longer mutable - all packages must be in the global registry

/// Receives an object from an account with tracking, only used in owned action lib module.
/// NOTE: This is for WITHDRAWALS - receiving an object FROM the account to return it.
public(package) fun receive<T: key + store>(
    account: &mut Account,
    receiving: Receiving<T>,
): T {
    let type_name = type_name::with_defining_ids<T>();
    let is_coin = is_coin_type(type_name);

    let tracker = ensure_object_tracker(account);
    let ascii_str = type_name::into_string(type_name);
    let type_str = ascii_str.to_string();
    let is_whitelisted = vec_set::contains(&tracker.whitelisted_types, &type_str);

    // Only count non-coin, non-whitelisted types
    if (!is_coin && !is_whitelisted) {
        // This is a WITHDRAWAL, so DECREMENT the counter
        assert!(tracker.object_count > 0, EObjectCountUnderflow);
        tracker.object_count = tracker.object_count - 1;

        // Re-enable deposits if we're back under 50% of threshold
        if (tracker.object_count < tracker.max_objects / 2) {
            tracker.deposits_open = true;
        };
    };

    transfer::public_receive(&mut account.id, receiving)
}

/// Track when an object leaves the account (withdrawal/burn/transfer)
public(package) fun track_object_removal<Config: store>(account: &mut Account, _object_id: ID) {
    let tracker = ensure_object_tracker(account);
    assert!(tracker.object_count > 0, EObjectCountUnderflow);
    tracker.object_count = tracker.object_count - 1;

    // Re-enable deposits if we're back under 50% of threshold
    if (tracker.object_count < tracker.max_objects / 2) {
        tracker.deposits_open = true;
    };
}


//**************************************************************************************************//
// Tests                                                                                            //
//**************************************************************************************************//

// === Test Helpers ===

#[test_only]
public fun init_for_testing(ctx: &mut TxContext) {
    init(ACCOUNT {}, ctx);
}

#[test_only]
public struct Witness has drop {}

#[test_only]
public fun not_config_witness(): Witness {
    Witness {}
}

// === Unit Tests ===

#[test_only]
use sui::test_utils::{assert_eq, destroy};
#[test_only]
public struct TestConfig has copy, drop, store {}
#[test_only]
public struct TestWitness() has drop;

#[test_only]
public struct TestWitness2() has drop;

#[test_only]
public struct WrongWitness() has drop;
#[test_only]
public struct TestKey has copy, drop, store {}
#[test_only]
public struct TestData has copy, drop, store {
    value: u64,
}
#[test_only]
public struct TestAsset has key, store {
    id: UID,
}

#[test]
fun test_addr() {
    let ctx = &mut tx_context::dummy();
    let registry = package_registry::new_for_testing(ctx);
    let deps = deps::new_for_testing(&registry);

    let account = new(TestConfig {}, deps, &registry, version::current(), TestWitness(), ctx);
    let account_addr = addr(&account);

    assert_eq(account_addr, object::id(&account).to_address());
    destroy(account);
    destroy(registry);
}

#[test]
fun test_verify_auth() {
    let ctx = &mut tx_context::dummy();
    let registry = package_registry::new_for_testing(ctx);
    let deps = deps::new_for_testing(&registry);

    let account = new(TestConfig {}, deps, &registry, version::current(), TestWitness(), ctx);
    let auth = Auth { account_addr: account.addr() };

    // Should not abort
    verify(&account, auth);
    destroy(account);
    destroy(registry);
}

#[test, expected_failure(abort_code = EWrongAccount)]
fun test_verify_auth_wrong_account() {
    let ctx = &mut tx_context::dummy();
    let registry = package_registry::new_for_testing(ctx);
    let deps = deps::new_for_testing(&registry);

    let account = new(TestConfig {}, deps, &registry, version::current(), TestWitness(), ctx);
    let auth = Auth { account_addr: @0xBAD };

    verify(&account, auth);
    destroy(account);
    destroy(registry);
}

#[test]
fun test_managed_data_flow() {
    let ctx = &mut tx_context::dummy();
    let registry = package_registry::new_for_testing(ctx);
    let deps = deps::new_for_testing(&registry);

    let mut account = new(TestConfig {}, deps, &registry, version::current(), TestWitness(), ctx);
    let key = TestKey {};
    let data = TestData { value: 42 };

    // Test add
    add_managed_data(&mut account, &registry, key, data, version::current());
    assert!(has_managed_data(&account, key));

    // Test borrow
    let borrowed_data = borrow_managed_data(&account, &registry, key, version::current());
    assert_eq(*borrowed_data, data);

    // Test borrow_mut
    let borrowed_mut_data = borrow_managed_data_mut(&mut account, &registry, key, version::current());
    assert_eq(*borrowed_mut_data, data);

    // Test remove
    let removed_data = remove_managed_data(&mut account, &registry, key, version::current());
    assert_eq(removed_data, data);
    assert!(!has_managed_data(&account, key));
    destroy(account);
    destroy(registry);
}

#[test, expected_failure(abort_code = EManagedDataAlreadyExists)]
fun test_add_managed_data_already_exists() {
    let ctx = &mut tx_context::dummy();
    let registry = package_registry::new_for_testing(ctx);
    let deps = deps::new_for_testing(&registry);

    let mut account = new(TestConfig {}, deps, &registry, version::current(), TestWitness(), ctx);
    let key = TestKey {};
    let data1 = TestData { value: 42 };
    let data2 = TestData { value: 100 };

    add_managed_data(&mut account, &registry, key, data1, version::current());
    add_managed_data(&mut account, &registry, key, data2, version::current());
    destroy(account);
    destroy(registry);
}

#[test, expected_failure(abort_code = EManagedDataDoesntExist)]
fun test_borrow_managed_data_doesnt_exist() {
    let ctx = &mut tx_context::dummy();
    let registry = package_registry::new_for_testing(ctx);
    let deps = deps::new_for_testing(&registry);

    let account = new(TestConfig {}, deps, &registry, version::current(), TestWitness(), ctx);
    let key = TestKey {};

    borrow_managed_data<TestKey, TestData>(&account, &registry, key, version::current());
    destroy(account);
    destroy(registry);
}

#[test, expected_failure(abort_code = EManagedDataDoesntExist)]
fun test_borrow_managed_data_mut_doesnt_exist() {
    let ctx = &mut tx_context::dummy();
    let registry = package_registry::new_for_testing(ctx);
    let deps = deps::new_for_testing(&registry);

    let mut account = new(TestConfig {}, deps, &registry, version::current(), TestWitness(), ctx);
    let key = TestKey {};

    borrow_managed_data_mut<TestKey, TestData>(&mut account, &registry, key, version::current());
    destroy(account);
    destroy(registry);
}

#[test, expected_failure(abort_code = EManagedDataDoesntExist)]
fun test_remove_managed_data_doesnt_exist() {
    let ctx = &mut tx_context::dummy();
    let registry = package_registry::new_for_testing(ctx);
    let deps = deps::new_for_testing(&registry);

    let mut account = new(TestConfig {}, deps, &registry, version::current(), TestWitness(), ctx);
    let key = TestKey {};

    remove_managed_data<TestKey, TestData>(&mut account, &registry, key, version::current());
    destroy(account);
    destroy(registry);
}

#[test]
fun test_managed_asset_flow() {
    let ctx = &mut tx_context::dummy();
    let registry = package_registry::new_for_testing(ctx);
    let deps = deps::new_for_testing(&registry);

    let mut account = new(TestConfig {}, deps, &registry, version::current(), TestWitness(), ctx);
    let key = TestKey {};
    let asset = TestAsset { id: object::new(ctx) };
    let asset_id = object::id(&asset);

    // Test add
    add_managed_asset(&mut account, &registry, key, asset, version::current());
    assert!(has_managed_asset(&account, key), 0);

    // Test borrow
    let borrowed_asset = borrow_managed_asset<TestKey, TestAsset>(
        &account,
        &registry,
        key,
        version::current(),
    );
    let borrowed_asset_id = object::id(borrowed_asset);
    assert_eq(borrowed_asset_id, asset_id);

    // Test remove
    let removed_asset = remove_managed_asset<TestKey, TestAsset>(
        &mut account,
        &registry,
        key,
        version::current(),
    );
    assert_eq(object::id(&removed_asset), asset_id);
    assert!(!has_managed_asset(&account, key));
    destroy(account);
    destroy(removed_asset);
    destroy(registry);
}

#[test]
fun test_has_managed_data_false() {
    let ctx = &mut tx_context::dummy();
    let registry = package_registry::new_for_testing(ctx);
    let deps = deps::new_for_testing(&registry);

    let account = new(TestConfig {}, deps, &registry, version::current(), TestWitness(), ctx);
    let key = TestKey {};

    assert!(!has_managed_data(&account, key));
    destroy(account);
    destroy(registry);
}

#[test]
fun test_has_managed_asset_false() {
    let ctx = &mut tx_context::dummy();
    let registry = package_registry::new_for_testing(ctx);
    let deps = deps::new_for_testing(&registry);

    let account = new(TestConfig {}, deps, &registry, version::current(), TestWitness(), ctx);
    let key = TestKey {};

    assert!(!has_managed_asset(&account, key));
    destroy(account);
    destroy(registry);
}

#[test, expected_failure(abort_code = EManagedAssetAlreadyExists)]
fun test_add_managed_asset_already_exists() {
    let ctx = &mut tx_context::dummy();
    let registry = package_registry::new_for_testing(ctx);
    let deps = deps::new_for_testing(&registry);

    let mut account = new(TestConfig {}, deps, &registry, version::current(), TestWitness(), ctx);
    let key = TestKey {};
    let asset1 = TestAsset { id: object::new(ctx) };
    let asset2 = TestAsset { id: object::new(ctx) };

    add_managed_asset(&mut account, &registry, key, asset1, version::current());
    add_managed_asset(&mut account, &registry, key, asset2, version::current());
    destroy(account);
    destroy(registry);
}

#[test, expected_failure(abort_code = EManagedAssetDoesntExist)]
fun test_borrow_managed_asset_doesnt_exist() {
    let ctx = &mut tx_context::dummy();
    let registry = package_registry::new_for_testing(ctx);
    let deps = deps::new_for_testing(&registry);

    let account = new(TestConfig {}, deps, &registry, version::current(), TestWitness(), ctx);
    let key = TestKey {};

    borrow_managed_asset<TestKey, TestAsset>(&account, &registry, key, version::current());
    destroy(account);
    destroy(registry);
}

#[test, expected_failure(abort_code = EManagedAssetDoesntExist)]
fun test_borrow_managed_asset_mut_doesnt_exist() {
    let ctx = &mut tx_context::dummy();
    let registry = package_registry::new_for_testing(ctx);
    let deps = deps::new_for_testing(&registry);

    let mut account = new(TestConfig {}, deps, &registry, version::current(), TestWitness(), ctx);
    let key = TestKey {};

    borrow_managed_asset_mut<TestKey, TestAsset>(&mut account, &registry, key, version::current());
    destroy(account);
    destroy(registry);
}

#[test, expected_failure(abort_code = EManagedAssetDoesntExist)]
fun test_remove_managed_asset_doesnt_exist() {
    let ctx = &mut tx_context::dummy();
    let registry = package_registry::new_for_testing(ctx);
    let deps = deps::new_for_testing(&registry);

    let mut account = new(TestConfig {}, deps, &registry, version::current(), TestWitness(), ctx);
    let key = TestKey {};

    let removed_asset = remove_managed_asset<TestKey, TestAsset>(
        &mut account,
        &registry,
        key,
        version::current(),
    );
    destroy(removed_asset);
    destroy(account);
    destroy(registry);
}

#[test]
fun test_new_auth() {
    let ctx = &mut tx_context::dummy();
    let registry = package_registry::new_for_testing(ctx);
    let deps = deps::new_for_testing(&registry);

    let account = new(TestConfig {}, deps, &registry, version::current(), TestWitness(), ctx);
    let auth = new_auth<TestConfig, TestWitness>(&account, &registry, version::current(), TestWitness());

    assert_eq(auth.account_addr, account.addr());
    destroy(account);
    destroy(auth);
    destroy(registry);
}

#[test]
fun test_metadata_access() {
    let ctx = &mut tx_context::dummy();
    let registry = package_registry::new_for_testing(ctx);
    let deps = deps::new_for_testing(&registry);

    let account = new(TestConfig {}, deps, &registry, version::current(), TestWitness(), ctx);

    // Should not abort - just testing access
    assert_eq(metadata(&account).size(), 0);
    destroy(account);
    destroy(registry);
}

#[test]
fun test_config_access() {
    let ctx = &mut tx_context::dummy();
    let registry = package_registry::new_for_testing(ctx);
    let deps = deps::new_for_testing(&registry);

    let account = new(TestConfig {}, deps, &registry, version::current(), TestWitness(), ctx);

    // Should not abort - just testing access
    config<TestConfig>(&account);
    destroy(account);
    destroy(registry);
}

#[test]
fun test_assert_is_config_module_correct_witness() {
    let ctx = &mut tx_context::dummy();
    let registry = package_registry::new_for_testing(ctx);
    let deps = deps::new_for_testing(&registry);

    let account = new(TestConfig {}, deps, &registry, version::current(), TestWitness(), ctx);

    // Should not abort
    assert_is_config_module<TestConfig, TestWitness>(&account, TestWitness());
    destroy(account);
    destroy(registry);
}


// === Test Helper Functions ===

#[test_only]
public fun new_for_testing(ctx: &mut TxContext): Account {
    let registry = package_registry::new_for_testing(ctx);
    let deps = deps::new_for_testing(&registry);
    let account = new(TestConfig {}, deps, &registry, version::current(), TestWitness(), ctx);
    destroy(registry);
    account
}

#[test_only]
public fun destroy_for_testing<Config: store>(account: Account) {
    destroy(account);
}

#[test_only]
public fun get_object_tracker<Config: store>(account: &Account): Option<ObjectTrackerState> {
    if (df::exists_(&account.id, ObjectTracker {})) {
        let tracker: &ObjectTrackerState = df::borrow(&account.id, ObjectTracker {});
        option::some(*tracker)
    } else {
        option::none()
    }
}

#[test_only]
public fun track_object_addition<Config: store>(account: &mut Account, id: ID) {
    let tracker = ensure_object_tracker(account);
    tracker.object_count = tracker.object_count + 1;
    if (tracker.object_count >= tracker.max_objects) {
        tracker.deposits_open = false;
    };
}

#[test_only]
public fun set_max_objects_for_testing<Config: store>(account: &mut Account, max: u128) {
    let tracker = ensure_object_tracker(account);
    tracker.max_objects = max;
}

// === Share Functions ===

/// Share an account - can only be called by this module
/// Used during DAO/account initialization after setup is complete
public fun share_account<Config: store>(account: Account) {
    transfer::share_object(account);
}

#[test_only]
public fun enable_deposits_for_testing<Config: store>(account: &mut Account) {
    let tracker = ensure_object_tracker(account);
    tracker.deposits_open = true;
}

#[test_only]
public fun close_deposits_for_testing<Config: store>(account: &mut Account) {
    let tracker = ensure_object_tracker(account);
    tracker.deposits_open = false;
}

#[test_only]
public fun check_can_receive_object<Config, T>(account: &Account) {
    let tracker: &ObjectTrackerState = df::borrow(&account.id, ObjectTracker {});
    let type_name = type_name::with_defining_ids<T>();
    let ascii_str = type_name::into_string(type_name);
    let type_str = ascii_str.to_string();

    assert!(
        tracker.deposits_open || tracker.whitelisted_types.contains(&type_str),
        EDepositsDisabled,
    );

    // For test purposes, we'll treat all objects the same
    // In production, coins don't count against limits but for tests this is fine
    if (!tracker.whitelisted_types.contains(&type_str)) {
        assert!(tracker.object_count < tracker.max_objects, EObjectLimitReached);
    };
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

// Portions of this file are derived from the account.tech Move Framework project.
// Those portions remain licensed under the Apache License, Version 2.0.

/// Dependencies are validated against the global PackageRegistry.
/// Accounts can only execute actions from packages in the registry.
/// This provides a curated whitelist of allowed packages managed by registry admins.

module account_protocol::deps;

use account_protocol::package_registry::{Self, PackageRegistry};
use account_protocol::version_witness::{Self, VersionWitness};
use std::string::String;

// === Errors ===

const ENotDep: u64 = 2;
const ERegistryMismatch: u64 = 7;

// === Structs ===

/// Simplified deps struct - only tracks which registry to use
public struct Deps has copy, drop, store {
    // ID of the PackageRegistry to use for whitelist checking
    registry_id: ID,
}

// === Public functions ===

/// Creates a new Deps struct with reference to the global registry.
/// All package validation is done against this registry.
public fun new(registry: &PackageRegistry): Deps {
    Deps {
        registry_id: sui::object::id(registry),
    }
}

// === View functions ===

/// Checks if a package is in the global PackageRegistry whitelist.
/// This validates that the package address is registered and approved.
///
/// Validates that the registry passed matches the stored registry_id to prevent malicious
/// registries from bypassing the whitelist.
public fun check(deps: &Deps, version_witness: VersionWitness, registry: &PackageRegistry) {
    // SECURITY: Validate registry matches stored ID to prevent fake registries
    assert!(deps.registry_id == sui::object::id(registry), ERegistryMismatch);

    let addr = version_witness.package_addr();

    // Check if it's in the global whitelist
    assert!(registry.contains_package_addr(addr), ENotDep);
}

/// Returns the registry ID
public fun registry_id(deps: &Deps): ID {
    deps.registry_id
}

// === Test only ===

#[test_only]
use sui::test_utils::destroy;

#[test_only]
public fun new_for_testing(registry: &PackageRegistry): Deps {
    Deps {
        registry_id: sui::object::id(registry),
    }
}

#[test_only]
/// Create deps for testing with a shared registry
public fun new_for_testing_with_config_and_registry(
    _config_name: String,
    _config_addr: address,
    registry: &PackageRegistry
): Deps {
    Deps {
        registry_id: sui::object::id(registry),
    }
}

// === Tests ===

#[test]
fun test_new_and_check(ctx: &mut TxContext) {
    let registry = package_registry::new_for_testing(ctx);

    // Add AccountProtocol to registry
    package_registry::add_for_testing(&mut registry, b"AccountProtocol".to_string(), @account_protocol, 1);

    let deps = new_for_testing(&registry);
    let witness = version_witness::new_for_testing(@account_protocol);
    deps.check(witness, &registry);

    destroy(registry);
}

#[test, expected_failure(abort_code = ENotDep)]
fun test_error_assert_is_dep(ctx: &mut TxContext) {
    let registry = package_registry::new_for_testing(ctx);
    let deps = new_for_testing(&registry);
    let witness = version_witness::new_for_testing(@0xDEAD);
    deps.check(witness, &registry);
    destroy(registry);
}

#[test, expected_failure(abort_code = ERegistryMismatch)]
fun test_error_registry_mismatch(ctx: &mut TxContext) {
    let registry1 = package_registry::new_for_testing(ctx);
    let registry2 = package_registry::new_for_testing(ctx);

    let deps = new_for_testing(&registry1);
    let witness = version_witness::new_for_testing(@account_protocol);

    // Try to use different registry - should fail
    deps.check(witness, &registry2);

    destroy(registry1);
    destroy(registry2);
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

// Portions of this file are derived from the account.tech Move Framework project.
// Those portions remain licensed under the Apache License, Version 2.0.

/// This module defines the VersionWitness type used to track the version of the protocol.
/// This type is used as a regular witness, but for an entire package instead of a single module.

module account_protocol::version_witness;

use std::type_name;
use sui::address;
use sui::hex;

// === Imports ===

// === Structs ===

/// Witness to check the version of a package.
public struct VersionWitness has copy, drop, store {
    // package id where the witness has been created
    package_addr: address,
}

/// Creates a new VersionWitness for the package where the Witness is instianted.
public fun new<PW: drop>(_package_witness: PW): VersionWitness {
    let package_type = type_name::with_defining_ids<PW>();
    let package_addr = address::from_bytes(hex::decode(package_type.address_string().into_bytes()));

    VersionWitness { package_addr }
}

// === Public Functions ===

/// Returns the address of the package where the witness has been created.
public fun package_addr(witness: &VersionWitness): address {
    witness.package_addr
}

//**************************************************************************************************//
// Tests                                                                                            //
//**************************************************************************************************//

// === Test Helpers ===

#[test_only]
public fun new_for_testing(package_addr: address): VersionWitness {
    VersionWitness { package_addr }
}

// === Unit Tests ===

#[test_only]
public struct TestPackageWitness() has drop;

#[test]
fun test_new_version_witness() {
    let witness = new(TestPackageWitness());
    // Should not abort - just testing creation and access
    assert!(package_addr(&witness) == @account_protocol, 0);
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

// Portions of this file are derived from the account.tech Move Framework project.
// Those portions remain licensed under the Apache License, Version 2.0.

/// This is the core module managing Intents.
/// It provides the interface to create and execute intents which is used in the `account` module.
/// In the new design, there is no locking - multiple intents can reference the same objects.
/// Conflicts are resolved naturally: if coinA is withdrawn by intent1, intent2 will fail when it tries.

module account_protocol::intents;

// === Imports ===

use std::{
    string::String,
    type_name::{Self, TypeName},
    bcs,
    vector,
};
use sui::{
    bag::{Self, Bag},
    dynamic_field,
    clock::Clock,
    object::{Self, ID},
};

// === Aliases ===

use fun dynamic_field::add as UID.df_add;
use fun dynamic_field::borrow as UID.df_borrow;
use fun dynamic_field::remove as UID.df_remove;
// Type-based action system - no string descriptors

// === Errors ===

const EIntentNotFound: u64 = 0;
const ENoExecutionTime: u64 = 3;
const EExecutionTimesNotAscending: u64 = 4;
const EActionsNotEmpty: u64 = 5;
const EKeyAlreadyExists: u64 = 6;
const EWrongAccount: u64 = 7;
const EWrongWitness: u64 = 8;
const ESingleExecution: u64 = 9;
const EMaxPlaceholdersExceeded: u64 = 10;
const EUnsupportedActionVersion: u64 = 11;
const EActionDataTooLarge: u64 = 12;

// Version constants
const CURRENT_ACTION_VERSION: u8 = 1;

// === Limits ===

/// Maximum number of placeholders allowed in a single intent.
/// Exposed as a function to allow future upgrades to change this value.
public fun max_placeholders(): u64 { 50 }

/// Maximum size for action data in bytes (4KB).
/// Exposed as a function to allow future upgrades to change this value.
/// Prevents excessively large action data that could cause DoS.
public fun max_action_data_size(): u64 { 4096 }

// === Structs ===

/// A blueprint for a single action within an intent.
public struct ActionSpec has store, copy, drop {
    version: u8,                // Version byte for forward compatibility
    action_type: TypeName,      // The type of the action struct
    action_data: vector<u8>,    // The BCS-serialized action struct
}

/// Create a new ActionSpec for testing
public fun new_action_spec<T>(action_data: vector<u8>, version: u8): ActionSpec {
    ActionSpec {
        version,
        action_type: type_name::with_defining_ids<T>(),
        action_data,
    }
}

/// Parent struct protecting the intents
public struct Intents has store {
    // map of intents: key -> Intent<Outcome>
    inner: Bag,
}

/// Child struct, intent owning a sequence of actions requested to be executed
/// Outcome is a custom struct depending on the config
public struct Intent<Outcome> has store {
    // type of the intent, checked against the witness to ensure correct execution
    type_: TypeName,
    // name of the intent, serves as a key, should be unique
    key: String,
    // what this intent aims to do, for informational purpose
    description: String,
    // address of the account that created the intent
    account: address,
    // address of the user that created the intent
    creator: address,
    // timestamp of the intent creation
    creation_time: u64,
    // proposer can add a timestamp_ms before which the intent can't be executed
    // can be used to schedule actions via a backend
    // recurring intents can be executed at these times
    execution_times: vector<u64>,
    // the intent can be deleted from this timestamp
    expiration_time: u64,
    // role for the intent
    role: String,
    // Structured action specifications for type-safe routing (single source of truth)
    action_specs: vector<ActionSpec>,
    // Counter for unique placeholder IDs
    next_placeholder_id: u64,
    // Generic struct storing vote related data, depends on the config
    outcome: Outcome,
}

/// Hot potato wrapping actions from an intent that expired or has been executed
public struct Expired {
    // address of the account that created the intent
    account: address,
    // action specs that expired or were executed
    action_specs: vector<ActionSpec>,
    // NEW: Track which actions were executed for proper destruction
    executed_actions: vector<bool>,
    // intent ID for tracking
    intent_id: ID,
}

/// Params of an intent to reduce boilerplate.
public struct Params has key, store {
    id: UID,
}
/// Fields are a df so it intents can be improved in the future
public struct ParamsFieldsV1 has copy, drop, store {
    key: String,
    description: String,
    creation_time: u64,
    execution_times: vector<u64>,
    expiration_time: u64,
}

// === Public functions ===

/// Reserve a placeholder ID for use during intent creation
public(package) fun reserve_placeholder_id<Outcome>(
    intent: &mut Intent<Outcome>
): u64 {
    let id = intent.next_placeholder_id;
    assert!(id < max_placeholders(), EMaxPlaceholdersExceeded);
    intent.next_placeholder_id = id + 1;
    id
}

/// Add an action specification with pre-serialized bytes (serialize-then-destroy pattern)
public fun add_action_spec<Outcome, T: drop, IW: drop>(
    intent: &mut Intent<Outcome>,
    action_type_witness: T,
    action_data_bytes: vector<u8>,
    intent_witness: IW,
) {
    intent.assert_is_witness(intent_witness);

    // Validate action data size to prevent excessively large actions
    assert!(
        action_data_bytes.length() <= max_action_data_size(),
        EActionDataTooLarge
    );

    // Create and store the action spec with BCS-serialized action
    let spec = ActionSpec {
        version: CURRENT_ACTION_VERSION,
        action_type: type_name::with_defining_ids<T>(),
        action_data: action_data_bytes,
    };
    intent.action_specs.push_back(spec);
}

/// Add action spec with TypeName directly (for replaying stored init intents)
/// This avoids redundant TypeName -> witness -> TypeName conversions when the
/// action type is already known from storage (e.g., InitActionSpecs).
public fun add_action_spec_with_typename<Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    action_type: TypeName,
    action_data_bytes: vector<u8>,
    intent_witness: IW,
) {
    intent.assert_is_witness(intent_witness);

    // Validate action data size to prevent excessively large actions
    assert!(
        action_data_bytes.length() <= max_action_data_size(),
        EActionDataTooLarge
    );

    // Create and store the action spec with TypeName directly
    let spec = ActionSpec {
        version: CURRENT_ACTION_VERSION,
        action_type,
        action_data: action_data_bytes,
    };
    intent.action_specs.push_back(spec);
}

public fun new_params(
    key: String,
    description: String,
    execution_times: vector<u64>,
    expiration_time: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Params {
    assert!(!execution_times.is_empty(), ENoExecutionTime);
    let mut i = 0;
    while (i < vector::length(&execution_times) - 1) {
        assert!(execution_times[i] <= execution_times[i + 1], EExecutionTimesNotAscending);
        i = i + 1;
    };
    
    let fields = ParamsFieldsV1 { 
        key, 
        description, 
        creation_time: clock.timestamp_ms(), 
        execution_times, 
        expiration_time 
    };
    let mut id = object::new(ctx);
    id.df_add(true, fields);

    Params { id }
}

public fun new_params_with_rand_key(
    description: String,
    execution_times: vector<u64>,
    expiration_time: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): (Params, String) {
    let key = ctx.fresh_object_address().to_string();
    let params = new_params(key, description, execution_times, expiration_time, clock, ctx);

    (params, key)
}

/// Add a typed action with pre-serialized bytes (serialize-then-destroy pattern)
/// Callers must serialize the action and then explicitly destroy it
public fun add_typed_action<Outcome, T: drop, IW: drop>(
    intent: &mut Intent<Outcome>,
    action_type: T,
    action_data: vector<u8>,
    intent_witness: IW,
) {
    add_action_spec(intent, action_type, action_data, intent_witness);
}

public fun remove_action_spec(
    expired: &mut Expired,
): ActionSpec {
    // Also mark as not executed when removing
    expired.executed_actions.remove(0);
    expired.action_specs.remove(0)
}

/// Mark an action as executed in the Expired struct
public fun mark_action_executed(
    expired: &mut Expired,
    index: u64,
) {
    let executed = vector::borrow_mut(&mut expired.executed_actions, index);
    *executed = true;
}

/// Check if an action was executed
public fun is_action_executed(
    expired: &Expired,
    index: u64,
): bool {
    *vector::borrow(&expired.executed_actions, index)
}

/// Get the number of actions in the Expired struct
public fun expired_action_count(expired: &Expired): u64 {
    expired.action_specs.length()
}

public use fun destroy_empty_expired as Expired.destroy_empty;
public fun destroy_empty_expired(expired: Expired) {
    let Expired { action_specs, executed_actions, .. } = expired;
    assert!(action_specs.is_empty(), EActionsNotEmpty);
    assert!(executed_actions.is_empty(), EActionsNotEmpty);
    // vectors don't need explicit destroy
}

// === View functions ===

public use fun params_key as Params.key;
public fun params_key(params: &Params): String {
    params.id.df_borrow<_, ParamsFieldsV1>(true).key
}

public use fun params_description as Params.description;
public fun params_description(params: &Params): String {
    params.id.df_borrow<_, ParamsFieldsV1>(true).description
}

public use fun params_creation_time as Params.creation_time;
public fun params_creation_time(params: &Params): u64 {
    params.id.df_borrow<_, ParamsFieldsV1>(true).creation_time
}

public use fun params_execution_times as Params.execution_times;
public fun params_execution_times(params: &Params): vector<u64> {
    params.id.df_borrow<_, ParamsFieldsV1>(true).execution_times
}

public use fun params_expiration_time as Params.expiration_time;
public fun params_expiration_time(params: &Params): u64 {
    params.id.df_borrow<_, ParamsFieldsV1>(true).expiration_time
}

public fun length(intents: &Intents): u64 {
    intents.inner.length()
}

public fun contains(intents: &Intents, key: String): bool {
    intents.inner.contains(key)
}

public fun get<Outcome: store>(intents: &Intents, key: String): &Intent<Outcome> {
    assert!(intents.inner.contains(key), EIntentNotFound);
    intents.inner.borrow(key)
}

public fun get_mut<Outcome: store>(intents: &mut Intents, key: String): &mut Intent<Outcome> {
    assert!(intents.inner.contains(key), EIntentNotFound);
    intents.inner.borrow_mut(key)
}

public fun type_<Outcome>(intent: &Intent<Outcome>): TypeName {
    intent.type_
}

public fun key<Outcome>(intent: &Intent<Outcome>): String {
    intent.key
}

public fun description<Outcome>(intent: &Intent<Outcome>): String {
    intent.description
}

public fun account<Outcome>(intent: &Intent<Outcome>): address {
    intent.account
}

public fun creator<Outcome>(intent: &Intent<Outcome>): address {
    intent.creator
}

public fun creation_time<Outcome>(intent: &Intent<Outcome>): u64 {
    intent.creation_time
}

public fun execution_times<Outcome>(intent: &Intent<Outcome>): vector<u64> {
    intent.execution_times
}

public fun expiration_time<Outcome>(intent: &Intent<Outcome>): u64 {
    intent.expiration_time
}

public fun role<Outcome>(intent: &Intent<Outcome>): String {
    intent.role
}

// Actions are now accessed through action_specs
public fun action_count<Outcome>(intent: &Intent<Outcome>): u64 {
    intent.action_specs.length()
}

public fun outcome<Outcome>(intent: &Intent<Outcome>): &Outcome {
    &intent.outcome
}

public fun outcome_mut<Outcome>(intent: &mut Intent<Outcome>): &mut Outcome {
    &mut intent.outcome
}

public fun action_specs<Outcome>(intent: &Intent<Outcome>): &vector<ActionSpec> {
    &intent.action_specs
}

public fun action_spec_version(spec: &ActionSpec): u8 {
    spec.version
}

public fun action_spec_type(spec: &ActionSpec): TypeName {
    spec.action_type
}

public fun action_spec_data(spec: &ActionSpec): &vector<u8> {
    &spec.action_data
}

public fun action_spec_action_data(spec: ActionSpec): vector<u8> {
    let ActionSpec { version: _, action_data, .. } = spec;
    action_data
}

public use fun expired_account as Expired.account;
public fun expired_account(expired: &Expired): address {
    expired.account
}

// start_index no longer exists in ActionSpec-based design

public use fun expired_action_specs as Expired.action_specs;
public fun expired_action_specs(expired: &Expired): &vector<ActionSpec> {
    &expired.action_specs
}

public fun assert_is_account<Outcome>(
    intent: &Intent<Outcome>,
    account_addr: address,
) {
    assert!(intent.account == account_addr, EWrongAccount);
}

public fun assert_is_witness<Outcome, IW: drop>(
    intent: &Intent<Outcome>,
    _: IW,
) {
    assert!(intent.type_ == type_name::with_defining_ids<IW>(), EWrongWitness);
}

public use fun assert_expired_is_account as Expired.assert_is_account;
public fun assert_expired_is_account(expired: &Expired, account_addr: address) {
    assert!(expired.account == account_addr, EWrongAccount);
}

public fun assert_single_execution(params: &Params) {
    assert!(
        params.id.df_borrow<_, ParamsFieldsV1>(true).execution_times.length() == 1, 
        ESingleExecution
    );
}

// === Package functions ===

/// The following functions are only used in the `account` module

public(package) fun empty(ctx: &mut TxContext): Intents {
    Intents { inner: bag::new(ctx) }
}

public(package) fun new_intent<Outcome, IW: drop>(
    params: Params,
    outcome: Outcome,
    managed_name: String,
    account_addr: address,
    _intent_witness: IW,
    ctx: &mut TxContext
): Intent<Outcome> {
    let Params { mut id } = params;
    
    let ParamsFieldsV1 { 
        key, 
        description, 
        creation_time, 
        execution_times, 
        expiration_time 
    } = id.df_remove(true);
    id.delete();

    Intent<Outcome> {
        type_: type_name::with_defining_ids<IW>(),
        key,
        description,
        account: account_addr,
        creator: ctx.sender(),
        creation_time,
        execution_times,
        expiration_time,
        role: new_role<IW>(managed_name),
        action_specs: vector::empty(),
        next_placeholder_id: 0,
        outcome,
    }
}

public(package) fun add_intent<Outcome: store>(
    intents: &mut Intents,
    intent: Intent<Outcome>,
) {
    assert!(!intents.contains(intent.key), EKeyAlreadyExists);
    intents.inner.add(intent.key, intent);
}

public(package) fun remove_intent<Outcome: store>(
    intents: &mut Intents,
    key: String,
): Intent<Outcome> {
    assert!(intents.contains(key), EIntentNotFound);
    intents.inner.remove(key)
}

public(package) fun pop_front_execution_time<Outcome>(
    intent: &mut Intent<Outcome>,
): u64 {
    intent.execution_times.remove(0)
}

/// Removes an intent being executed if the execution_time is reached
/// Outcome must be validated in AccountMultisig to be destroyed
public(package) fun destroy_intent<Outcome: store + drop>(
    intents: &mut Intents,
    key: String,
    ctx: &mut TxContext,
): Expired {
    let Intent<Outcome> { account, action_specs, key, .. } = intents.inner.remove(key);
    let num_actions = action_specs.length();
    let mut executed_actions = vector::empty<bool>();
    let mut i = 0;
    while (i < num_actions) {
        vector::push_back(&mut executed_actions, false);
        i = i + 1;
    };

    // ‚úÖ PROPER FIX: Use Sui's native UID generation for unique intent tracking
    // - Creates a proper unique ID via object::new(ctx)
    // - Follows Sui best practices for object identification
    // - Enables proper intent tracking in logs and events
    let uid = object::new(ctx);
    let intent_id = uid.to_inner();
    uid.delete();

    Expired { account, action_specs, executed_actions, intent_id }
}

// === Private functions ===

fun new_role<IW: drop>(managed_name: String): String {
    let intent_type = type_name::with_defining_ids<IW>();
    let mut role = intent_type.address_string().to_string();
    role.append_utf8(b"::");
    role.append(intent_type.module_string().to_string());

    if (!managed_name.is_empty()) {
        role.append_utf8(b"::");
        role.append(managed_name);
    };

    role
}

//**************************************************************************************************//
// Tests                                                                                            //
//**************************************************************************************************//

#[test_only]
use sui::test_utils::{assert_eq, destroy};
#[test_only]
use sui::clock;

#[test_only]
public struct TestOutcome has copy, drop, store {}
#[test_only]
public struct TestAction has drop, store {}
#[test_only]
public struct TestActionType has drop {}
#[test_only]
public struct TestIntentWitness() has drop;
#[test_only]
public struct WrongWitness() has drop;

#[test]
fun test_new_params() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    assert_eq(params.key(), b"test_key".to_string());
    assert_eq(params.description(), b"test_description".to_string());
    assert_eq(params.execution_times(), vector[1000]);
    assert_eq(params.expiration_time(), 2000);
    assert_eq(params.creation_time(), 0);
    
    destroy(params);
    destroy(clock);
}

#[test]
fun test_new_params_with_rand_key() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let (params, key) = new_params_with_rand_key(
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    assert_eq(params.key(), key);
    assert_eq(params.description(), b"test_description".to_string());
    assert_eq(params.execution_times(), vector[1000]);
    assert_eq(params.expiration_time(), 2000);
    
    destroy(params);
    destroy(clock);
}

#[test, expected_failure(abort_code = ENoExecutionTime)]
fun test_new_params_empty_execution_times() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[],
        2000,
        &clock,
        ctx
    );
    destroy(params);
    destroy(clock);
}

#[test, expected_failure(abort_code = EExecutionTimesNotAscending)]
fun test_new_params_not_ascending_execution_times() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[2000, 1000],
        3000,
        &clock,
        ctx
    );
    destroy(params);
    destroy(clock);
}

#[test]
fun test_new_intent() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let intent = new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    assert_eq(intent.key(), b"test_key".to_string());
    assert_eq(intent.description(), b"test_description".to_string());
    assert_eq(intent.account(), @0xCAFE);
    assert_eq(intent.creation_time(), clock.timestamp_ms());
    assert_eq(intent.execution_times(), vector[1000]);
    assert_eq(intent.expiration_time(), 2000);
    assert_eq(intent.action_count(), 0);
    
    destroy(intent);
    destroy(clock);
}

#[test]
fun test_add_action() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let mut intent = new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    let action_data1 = bcs::to_bytes(&TestAction {});
    intent.add_typed_action(TestActionType {}, action_data1, TestIntentWitness());
    assert_eq(intent.action_count(), 1);

    let action_data2 = bcs::to_bytes(&TestAction {});
    intent.add_typed_action(TestActionType {}, action_data2, TestIntentWitness());
    assert_eq(intent.action_count(), 2);
    
    destroy(intent);
    destroy(clock);
}

#[test]
fun test_remove_action() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    let mut intents = empty(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let mut intent = new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    let action_data1 = bcs::to_bytes(&TestAction {});
    intent.add_typed_action(TestActionType {}, action_data1, TestIntentWitness());

    let action_data2 = bcs::to_bytes(&TestAction {});
    intent.add_typed_action(TestActionType {}, action_data2, TestIntentWitness());
    add_intent(&mut intents, intent);

    let mut expired = intents.destroy_intent<TestOutcome>(b"test_key".to_string(), ctx);

    let _action1 = expired.remove_action_spec();
    let _action2 = expired.remove_action_spec();

    assert_eq(expired.expired_action_count(), 0);

    expired.destroy_empty();
    destroy(intents);
    destroy(clock);
}

#[test]
fun test_empty_intents() {
    let ctx = &mut tx_context::dummy();
    let intents = empty(ctx);
    
    assert_eq(length(&intents), 0);
    assert!(!contains(&intents, b"test_key".to_string()));
    
    destroy(intents);
}

#[test]
fun test_add_and_remove_intent() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    let mut intents = empty(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let intent = new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    add_intent(&mut intents, intent);
    assert_eq(length(&intents), 1);
    assert!(contains(&intents, b"test_key".to_string()));
    
    let removed_intent = remove_intent<TestOutcome>(&mut intents, b"test_key".to_string());
    assert_eq(length(&intents), 0);
    assert!(!contains(&intents, b"test_key".to_string()));
    
    destroy(removed_intent);
    destroy(intents);
    destroy(clock);
}

#[test, expected_failure(abort_code = EKeyAlreadyExists)]
fun test_add_duplicate_intent() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    let mut intents = empty(ctx);
    
    let params1 = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let params2 = new_params(
        b"test_key".to_string(),
        b"test_description2".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let intent1 = new_intent(
        params1,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    let intent2 = new_intent(
        params2,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    add_intent(&mut intents, intent1);
    add_intent(&mut intents, intent2);
    
    destroy(intents);
    destroy(clock);
}

#[test, expected_failure(abort_code = EIntentNotFound)]
fun test_remove_nonexistent_intent() {
    let ctx = &mut tx_context::dummy();
    let mut intents = empty(ctx);
    
    let removed_intent = remove_intent<TestOutcome>(&mut intents, b"nonexistent_key".to_string());
    
    destroy(removed_intent);
    destroy(intents);
}

#[test]
fun test_pop_front_execution_time() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000, 2000, 3000],
        4000,
        &clock,
        ctx
    );
    
    let mut intent = new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    assert_eq(intent.execution_times(), vector[1000, 2000, 3000]);
    
    let time1 = pop_front_execution_time(&mut intent);
    assert_eq(time1, 1000);
    assert_eq(intent.execution_times(), vector[2000, 3000]);
    
    let time2 = pop_front_execution_time(&mut intent);
    assert_eq(time2, 2000);
    assert_eq(intent.execution_times(), vector[3000]);
    
    destroy(intent);
    destroy(clock);
}

#[test]
fun test_assert_is_account() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let intent = new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    // Should not abort
    assert_is_account(&intent, @0xCAFE);
    
    destroy(intent);
    destroy(clock);
}

#[test, expected_failure(abort_code = EWrongAccount)]
fun test_assert_is_account_wrong() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let intent = new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    assert_is_account(&intent, @0xBAD);
    
    destroy(intent);
    destroy(clock);
}

#[test]
fun test_assert_is_witness() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let intent = new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    // Should not abort
    assert_is_witness(&intent, TestIntentWitness());
    
    destroy(intent);
    destroy(clock);
}

#[test, expected_failure(abort_code = EWrongWitness)]
fun test_assert_is_witness_wrong() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let intent = new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    assert_is_witness(&intent, WrongWitness());
    
    destroy(intent);
    destroy(clock);
}

#[test]
fun test_assert_single_execution() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    // Should not abort
    assert_single_execution(&params);
    
    destroy(params);
    destroy(clock);
}

#[test, expected_failure(abort_code = ESingleExecution)]
fun test_assert_single_execution_multiple() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000, 2000],
        3000,
        &clock,
        ctx
    );
    
    assert_single_execution(&params);
    
    destroy(params);
    destroy(clock);
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

// Portions of this file are derived from the account.tech Move Framework project.
// Those portions remain licensed under the Apache License, Version 2.0.

/// The Executable struct is hot potato constructed from an Intent that has been resolved.
/// It ensures that the actions are executed as intended as it can't be stored.
/// Action index is tracked to ensure each action is executed exactly once.

module account_protocol::executable;

use account_protocol::intents::{Self, Intent};
use std::type_name::{Self, TypeName};

// === Imports ===

// === Structs ===

/// Hot potato ensuring the actions in the intent are executed as intended.
public struct Executable<Outcome: store> {
    // intent to return or destroy (if execution_times empty) after execution
    intent: Intent<Outcome>,
    // current action index for sequential processing
    action_idx: u64,
}

// === View functions ===

/// Returns the issuer of the corresponding intent
public fun intent<Outcome: store>(executable: &Executable<Outcome>): &Intent<Outcome> {
    &executable.intent
}

/// Returns the current action index
public fun action_idx<Outcome: store>(executable: &Executable<Outcome>): u64 {
    executable.action_idx
}

// Actions are now stored as BCS bytes in ActionSpec
// The dispatcher must deserialize them when needed

/// Get the type of the current action
public fun current_action_type<Outcome: store>(executable: &Executable<Outcome>): TypeName {
    let specs = executable.intent().action_specs();
    intents::action_spec_type(specs.borrow(executable.action_idx))
}

/// Check if current action matches a specific type
public fun is_current_action<Outcome: store, T: store + drop + copy>(
    executable: &Executable<Outcome>,
): bool {
    let current_type = current_action_type(executable);
    current_type == type_name::with_defining_ids<T>()
}

/// Get type of action at specific index
public fun action_type_at<Outcome: store>(executable: &Executable<Outcome>, idx: u64): TypeName {
    let specs = executable.intent().action_specs();
    intents::action_spec_type(specs.borrow(idx))
}

/// Increment the action index to mark progress
public fun increment_action_idx<Outcome: store>(executable: &mut Executable<Outcome>) {
    executable.action_idx = executable.action_idx + 1;
}

// === Helper Functions ===

// === Package functions ===

public(package) fun new<Outcome: store>(
    intent: Intent<Outcome>,
    _ctx: &mut TxContext, // No longer needed, kept for API compatibility
): Executable<Outcome> {
    Executable {
        intent,
        action_idx: 0,
    }
}

public(package) fun destroy<Outcome: store>(executable: Executable<Outcome>): Intent<Outcome> {
    let Executable { intent, .. } = executable;
    intent
}

//**************************************************************************************************//
// Tests                                                                                            //
//**************************************************************************************************//

#[test_only]
use sui::test_utils::{assert_eq, destroy as test_destroy};
#[test_only]
use sui::clock;
// intents already imported at top of module

#[test_only]
public struct TestOutcome has copy, drop, store {}
#[test_only]
public struct TestAction has drop, store {}
#[test_only]
public struct TestActionType has drop {}
#[test_only]
public struct TestIntentWitness() has drop;

#[test]
fun test_new_executable() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);

    let params = intents::new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx,
    );

    let intent = intents::new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx,
    );

    let executable = new(intent, ctx);

    assert_eq(action_idx(&executable), 0);
    assert_eq(intent(&executable).key(), b"test_key".to_string());

    test_destroy(executable);
    test_destroy(clock);
}


#[test]
fun test_destroy_executable() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);

    let params = intents::new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx,
    );

    let intent = intents::new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx,
    );

    let executable = new(intent, ctx);
    let recovered_intent = destroy(executable);

    assert_eq(recovered_intent.key(), b"test_key".to_string());
    assert_eq(recovered_intent.description(), b"test_description".to_string());

    test_destroy(recovered_intent);
    test_destroy(clock);
}

#[test]
fun test_executable_with_multiple_actions() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);

    let params = intents::new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx,
    );

    let mut intent = intents::new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx,
    );

    // Actions are now added as serialized bytes via action specs
    // This test focuses on ExecutionContext functionality

    let mut executable = new(intent, ctx);

    assert_eq(action_idx(&executable), 0);
    assert_eq(intent(&executable).action_specs().length(), 0);

    // Actions are now accessed via action specs
    // Incrementing action index to simulate execution
    increment_action_idx(&mut executable);
    assert_eq(action_idx(&executable), 1);
    increment_action_idx(&mut executable);
    assert_eq(action_idx(&executable), 2);
    increment_action_idx(&mut executable);
    assert_eq(action_idx(&executable), 3);

    test_destroy(executable);
    test_destroy(clock);
}

#[test]
fun test_intent_access() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);

    let params = intents::new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx,
    );

    let intent = intents::new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx,
    );

    let executable = new(intent, ctx);
    let intent_ref = intent(&executable);

    assert_eq(intent_ref.key(), b"test_key".to_string());
    assert_eq(intent_ref.description(), b"test_description".to_string());
    assert_eq(intent_ref.account(), @0xCAFE);
    let mut role = @account_protocol.to_string();
    role.append_utf8(b"::executable");
    role.append_utf8(b"::test_role");
    assert_eq(intent_ref.role(), role);

    test_destroy(executable);
    test_destroy(clock);
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

// Portions of this file are derived from the account.tech Move Framework project.
// Those portions remain licensed under the Apache License, Version 2.0.

/// This module manages the metadata field of Account.
/// It provides the interface to create and get the fields of a Metadata struct.

module account_protocol::metadata;

use std::string::String;
use sui::vec_map::{Self, VecMap};

// === Imports ===

// === Errors ===

const EMetadataNotSameLength: u64 = 0;

// === Structs ===

/// Parent struct protecting the metadata
public struct Metadata has copy, drop, store {
    inner: VecMap<String, String>,
}

// === Public functions ===

/// Creates an empty Metadata struct
public fun empty(): Metadata {
    Metadata { inner: vec_map::empty() }
}

/// Creates a new Metadata struct from keys and values.
public fun from_keys_values(keys: vector<String>, values: vector<String>): Metadata {
    assert!(keys.length() == values.length(), EMetadataNotSameLength);
    Metadata {
        inner: vec_map::from_keys_values(keys, values),
    }
}

/// Gets the value for the key.
public fun get(metadata: &Metadata, key: String): String {
    *metadata.inner.get(&key)
}

/// Gets the entry at the index.
public fun get_entry_by_idx(metadata: &Metadata, idx: u64): (String, String) {
    let (key, value) = metadata.inner.get_entry_by_idx(idx);
    (*key, *value)
}

/// Returns the number of entries.
public fun size(metadata: &Metadata): u64 {
    metadata.inner.length()
}

//**************************************************************************************************//
// Tests                                                                                            //
//**************************************************************************************************//

// === Test Helpers ===

#[test_only]
use sui::test_utils::{assert_eq, destroy};

// === Unit Tests ===

#[test]
fun test_empty() {
    let metadata = empty();
    assert_eq(size(&metadata), 0);
    destroy(metadata);
}

#[test]
fun test_from_keys_values() {
    let keys = vector[b"key1".to_string(), b"key2".to_string()];
    let values = vector[b"value1".to_string(), b"value2".to_string()];

    let metadata = from_keys_values(keys, values);
    assert_eq(size(&metadata), 2);
    assert_eq(get(&metadata, b"key1".to_string()), b"value1".to_string());
    assert_eq(get(&metadata, b"key2".to_string()), b"value2".to_string());

    destroy(metadata);
}

#[test, expected_failure(abort_code = EMetadataNotSameLength)]
fun test_from_keys_values_different_lengths() {
    let keys = vector[b"key1".to_string(), b"key2".to_string()];
    let values = vector[b"value1".to_string()];

    let metadata = from_keys_values(keys, values);
    destroy(metadata);
}

#[test]
fun test_get() {
    let keys = vector[b"test_key".to_string()];
    let values = vector[b"test_value".to_string()];

    let metadata = from_keys_values(keys, values);
    let value = get(&metadata, b"test_key".to_string());
    assert_eq(value, b"test_value".to_string());

    destroy(metadata);
}

#[test]
fun test_get_entry_by_idx() {
    let keys = vector[b"key1".to_string(), b"key2".to_string()];
    let values = vector[b"value1".to_string(), b"value2".to_string()];

    let metadata = from_keys_values(keys, values);

    let (key1, value1) = get_entry_by_idx(&metadata, 0);
    let (key2, value2) = get_entry_by_idx(&metadata, 1);

    assert_eq(key1, b"key1".to_string());
    assert_eq(value1, b"value1".to_string());
    assert_eq(key2, b"key2".to_string());
    assert_eq(value2, b"value2".to_string());

    destroy(metadata);
}

#[test]
fun test_size() {
    let metadata = empty();
    assert_eq(size(&metadata), 0);

    let keys = vector[b"key1".to_string()];
    let values = vector[b"value1".to_string()];
    let metadata2 = from_keys_values(keys, values);
    assert_eq(size(&metadata2), 1);

    destroy(metadata);
    destroy(metadata2);
}

#[test]
fun test_multiple_entries() {
    let keys = vector[b"name".to_string(), b"description".to_string(), b"version".to_string()];
    let values = vector[
        b"Test Account".to_string(),
        b"A test account".to_string(),
        b"1.0".to_string(),
    ];

    let metadata = from_keys_values(keys, values);
    assert_eq(size(&metadata), 3);
    assert_eq(get(&metadata, b"name".to_string()), b"Test Account".to_string());
    assert_eq(get(&metadata, b"description".to_string()), b"A test account".to_string());
    assert_eq(get(&metadata, b"version".to_string()), b"1.0".to_string());

    destroy(metadata);
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

// Portions of this file are derived from the account.tech Move Framework project.
// Those portions remain licensed under the Apache License, Version 2.0.

/// This module tracks the version of the package by implementing the version_witness type.
/// A new version type should be defined for each new version of the package.

module account_protocol::version;

use account_protocol::version_witness::{Self, VersionWitness};

// === Imports ===

// === Constants ===

const VERSION: u64 = 1; // bump this when the package is upgraded

// === Structs ===

// define a new version struct for each new version of the package
public struct V1() has drop;

public(package) fun current(): VersionWitness {
    version_witness::new(V1()) // modify with the new version struct
}

// === Public functions ===

public fun get(): u64 {
    VERSION
}

// === Test functions ===

#[test_only]
public struct Witness() has drop;

#[test_only]
public fun witness(): Witness {
    Witness()
}

#[test]
public fun test_get() {
    assert!(get() == 1, 1);
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

// Portions of this file are derived from the account.tech Move Framework project.
// Those portions remain licensed under the Apache License, Version 2.0.

/// This module allows objects owned by the account to be accessed through intents in a secure way.
/// The objects can be taken only via Actions which use Transfer to Object (TTO).
/// This action can't be proposed directly since it wouldn't make sense to withdraw an object without using it.

module account_protocol::owned;

// === Imports ===

use std::{
    string::String,
    type_name,
};
use sui::{
    coin::{Self, Coin},
    transfer::Receiving,
    bcs
};
use account_protocol::{
    action_validation,
    account::{Self, Account, Auth},
    intents::{Self, Expired, Intent},
    executable::Executable,
};

use fun account_protocol::intents::add_typed_action as Intent.add_typed_action;

// === Errors ===

const EWrongObject: u64 = 0;
const EWrongAmount: u64 = 1;
const EWrongCoinType: u64 = 2;
const EUnsupportedActionVersion: u64 = 3;

// === Action Type Markers ===

/// Withdraw owned object by ID
public struct OwnedWithdrawObject has drop {}
/// Withdraw owned coin by type and amount
public struct OwnedWithdrawCoin has drop {}

public fun owned_withdraw_object(): OwnedWithdrawObject { OwnedWithdrawObject {} }
public fun owned_withdraw_coin(): OwnedWithdrawCoin { OwnedWithdrawCoin {} }

// === Structs ===

/// Action guarding access to account owned objects which can only be received via this action
public struct WithdrawObjectAction has drop, store {
    // the owned object we want to access
    object_id: ID,
}

/// Action guarding access to account owned coins which can only be received via this action
public struct WithdrawCoinAction has drop, store {
    // the type of the coin we want to access
    coin_type: String,
    // the amount of the coin we want to access
    coin_amount: u64,
}

// === Destruction Functions ===

/// Destroy a WithdrawObjectAction after serialization
public fun destroy_withdraw_object_action(action: WithdrawObjectAction) {
    let WithdrawObjectAction { object_id: _ } = action;
}

/// Destroy a WithdrawCoinAction after serialization
public fun destroy_withdraw_coin_action(action: WithdrawCoinAction) {
    let WithdrawCoinAction { coin_type: _, coin_amount: _ } = action;
}

// === Public functions ===

/// Creates a new WithdrawObjectAction and add it to an intent
public fun new_withdraw_object<Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    account: &Account,
    object_id: ID,
    intent_witness: IW,
) {
    intent.assert_is_account(account.addr());

    // Create the action struct
    let action = WithdrawObjectAction { object_id };

    // Serialize it
    let action_data = bcs::to_bytes(&action);

    // Add to intent with pre-serialized bytes
    intent.add_typed_action(
        owned_withdraw_object(),
        action_data,
        intent_witness
    );

    // Explicitly destroy the action struct
    destroy_withdraw_object_action(action);
}

/// Executes a WithdrawObjectAction and returns the object
public fun do_withdraw_object<Outcome: store, T: key + store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    receiving: Receiving<T>,
    intent_witness: IW,
): T {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<OwnedWithdrawObject>(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    let action_data = intents::action_spec_data(spec);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let object_id = object::id_from_address(bcs::peel_address(&mut reader));

    // Validate all bytes consumed (prevent trailing data attacks)
    account_protocol::bcs_validation::validate_all_bytes_consumed(reader);

    assert!(receiving.receiving_object_id() == object_id, EWrongObject);

    // Receive the object and increment action index
    let obj = account::receive(account, receiving);
    account_protocol::executable::increment_action_idx(executable);

    obj
}

/// Deletes a WithdrawObjectAction from an expired intent
public fun delete_withdraw_object(expired: &mut Expired, account: &Account) {
    expired.assert_is_account(account.addr());

    let spec = intents::remove_action_spec(expired);
    let action_data = intents::action_spec_data(&spec);
    let mut reader = bcs::new(*action_data);

    // We don't need the value, but we must peel it to consume the bytes
    let WithdrawObjectAction { object_id: _ } = WithdrawObjectAction {
        object_id: object::id_from_bytes(bcs::peel_vec_u8(&mut reader))
    };
}

/// Creates a new WithdrawCoinAction and add it to an intent
public fun new_withdraw_coin<Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    account: &Account,
    coin_type: String,
    coin_amount: u64,
    intent_witness: IW,
) {
    intent.assert_is_account(account.addr());

    // Create the action struct
    let action = WithdrawCoinAction { coin_type, coin_amount };

    // Serialize it
    let action_data = bcs::to_bytes(&action);

    // Add to intent with pre-serialized bytes
    intent.add_typed_action(
        owned_withdraw_coin(),
        action_data,
        intent_witness
    );

    // Explicitly destroy the action struct
    destroy_withdraw_coin_action(action);
}

/// Executes a WithdrawCoinAction and returns the coin
public fun do_withdraw_coin<Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    receiving: Receiving<Coin<CoinType>>,
    intent_witness: IW,
): Coin<CoinType> {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<OwnedWithdrawCoin>(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    let action_data = intents::action_spec_data(spec);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let coin_type = std::string::utf8(bcs::peel_vec_u8(&mut reader));
    let coin_amount = bcs::peel_u64(&mut reader);

    // Validate all bytes consumed (prevent trailing data attacks)
    account_protocol::bcs_validation::validate_all_bytes_consumed(reader);

    // Receive the coin
    let coin = account::receive(account, receiving);

    // Validate coin type and amount
    assert!(coin.value() == coin_amount, EWrongAmount);
    assert!(
        type_name::with_defining_ids<CoinType>().into_string().to_string() == coin_type,
        EWrongCoinType
    );

    // Increment action index
    account_protocol::executable::increment_action_idx(executable);

    coin
}

/// Deletes a WithdrawCoinAction from an expired intent
public fun delete_withdraw_coin(expired: &mut Expired, account: &Account) {
    expired.assert_is_account(account.addr());

    let spec = intents::remove_action_spec(expired);
    let action_data = intents::action_spec_data(&spec);
    let mut reader = bcs::new(*action_data);

    // We don't need the values, but we must peel them to consume the bytes
    let WithdrawCoinAction { coin_type: _, coin_amount: _ } = WithdrawCoinAction {
        coin_type: std::string::utf8(bcs::peel_vec_u8(&mut reader)),
        coin_amount: bcs::peel_u64(&mut reader)
    };
}

// Coin operations

/// Authorized addresses can merge and split coins.
/// Returns the IDs to use in a following intent, conserves the order.
public fun merge_and_split<Config: store, CoinType>(
    auth: Auth,
    account: &mut Account,
    to_merge: vector<Receiving<Coin<CoinType>>>, // there can be only one coin if we just want to split
    to_split: vector<u64>, // there can be no amount if we just want to merge
    ctx: &mut TxContext
): vector<ID> {
    account.verify(auth);
    // receive all coins
    let mut coins = vector::empty();
    to_merge.do!(|item| {
        let coin = account::receive(account, item);
        coins.push_back(coin);
    });

    let coin = merge(coins, ctx);
    let ids = split(account, coin, to_split, ctx);

    ids
}

fun merge<CoinType>(
    coins: vector<Coin<CoinType>>,
    ctx: &mut TxContext
): Coin<CoinType> {
    let mut merged = coin::zero<CoinType>(ctx);
    coins.do!(|coin| {
        merged.join(coin);
    });

    merged
}

fun split<CoinType>(
    account: &mut Account,
    mut coin: Coin<CoinType>,
    amounts: vector<u64>,
    ctx: &mut TxContext
): vector<ID> {
    let ids = amounts.map!(|amount| {
        let split = coin.split(amount, ctx);
        let id = object::id(&split);
        account.keep(split, ctx);
        id
    });
    account.keep(coin, ctx);

    ids
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

// Portions of this file are derived from the account.tech Move Framework project.
// Those portions remain licensed under the Apache License, Version 2.0.

/// This module allows to manage Account settings.
/// The actions are related to the modifications of certain fields of the Account (metadata, deposits, etc).
/// All these fields are encapsulated in the `Account` struct and each managed in their own module.
/// They are only accessible mutably via package functions defined in account.move which are used here only.

module account_protocol::config;

// === Imports ===

use std::{string::{Self, String}, option::Option, type_name::{Self, TypeName}};
use sui::bcs::{Self, BCS};
use sui::{vec_set::{Self, VecSet}, event};
use account_protocol::{
    account::{Self, Account, Auth},
    intents::{Intent, Expired, Params},
    executable::Executable,
    metadata,
    version,
    version_witness::VersionWitness,
    intent_interface,
};
use account_protocol::package_registry::PackageRegistry;

use fun account_protocol::intents::add_typed_action as Intent.add_typed_action;

// === Aliases ===

use fun intent_interface::build_intent as Account.build_intent;
use fun intent_interface::process_intent as Account.process_intent;

// === Error Constants ===

/// Error when action version is not supported
const EUnsupportedActionVersion: u64 = 1;

// === Action Type Markers ===

/// Update account metadata
public struct ConfigUpdateMetadata has drop {}
/// Configure object deposit settings
public struct ConfigUpdateDeposits has drop {}
/// Manage type whitelist for deposits
public struct ConfigManageWhitelist has drop {}

public fun config_update_metadata(): ConfigUpdateMetadata { ConfigUpdateMetadata {} }
public fun config_update_deposits(): ConfigUpdateDeposits { ConfigUpdateDeposits {} }
public fun config_manage_whitelist(): ConfigManageWhitelist { ConfigManageWhitelist {} }

// === Structs ===

/// Intent Witness for deposit configuration
public struct ConfigureDepositsIntent() has drop;
/// Intent Witness for whitelist management
public struct ManageWhitelistIntent() has drop;

/// Action to configure object deposit settings
public struct ConfigureDepositsAction has drop, store {
    enable: bool,
    new_max: Option<u128>,
    reset_counter: bool,
}
/// Action to manage type whitelist for deposits
public struct ManageWhitelistAction has drop, store {
    add_types: vector<String>,
    remove_types: vector<String>,
}

// === Public Constructors for Actions ===

/// Create a new ConfigureDepositsAction
/// Allows external modules to construct this action for their own intents
public fun new_configure_deposits_action(
    enable: bool,
    new_max: Option<u128>,
    reset_counter: bool,
): ConfigureDepositsAction {
    ConfigureDepositsAction { enable, new_max, reset_counter }
}

/// Create a new ManageWhitelistAction
/// Allows external modules to construct this action for their own intents
public fun new_manage_whitelist_action(
    add_types: vector<String>,
    remove_types: vector<String>,
): ManageWhitelistAction {
    ManageWhitelistAction { add_types, remove_types }
}

// === Destruction Functions ===

/// Destroy a ConfigureDepositsAction after serialization
public fun destroy_configure_deposits_action(action: ConfigureDepositsAction) {
    let ConfigureDepositsAction { enable: _, new_max: _, reset_counter: _ } = action;
}

/// Destroy a ManageWhitelistAction after serialization
public fun destroy_manage_whitelist_action(action: ManageWhitelistAction) {
    let ManageWhitelistAction { add_types: _, remove_types: _ } = action;
}

/// Helper to deserialize vector<String>
fun peel_vector_string(reader: &mut BCS): vector<String> {
    let len = bcs::peel_vec_length(reader);
    let mut i = 0;
    let mut vec = vector::empty();
    while (i < len) {
        vec.push_back(string::utf8(bcs::peel_vec_u8(reader)));
        i = i + 1;
    };
    vec
}

// === Public functions ===

/// Authorized addresses can configure object deposit settings directly
public fun configure_deposits<Config: store>(
    auth: Auth,
    account: &mut Account,
    enable: bool,
    new_max: Option<u128>,
    reset_counter: bool,
) {
    account.verify(auth);
    // Apply the configuration using the helper function
    account.apply_deposit_config(enable, new_max, reset_counter);
}

/// Authorized addresses can edit the metadata of the account
public fun edit_metadata<Config: store>(
    auth: Auth,
    account: &mut Account,
    registry: &PackageRegistry,
    keys: vector<String>,
    values: vector<String>,
) {
    account.verify(auth);
    *account::metadata_mut(account, registry, version::current()) = metadata::from_keys_values(keys, values);
}

/// Creates an intent to configure object deposit settings
public fun request_configure_deposits<Config: store, Outcome: store>(
    auth: Auth,
    account: &mut Account,
    registry: &PackageRegistry,
    outcome: Outcome,
    params: Params,
    enable: bool,
    new_max: Option<u128>,
    reset_counter: bool,
    ctx: &mut TxContext,
) {
    account.verify(auth);
    account.build_intent!(
        registry,
        params,
        outcome,
        b"ConfigureDepositsIntent".to_string(),
        version::current(),
        ConfigureDepositsIntent(),
        ctx,
        |intent, iw| {
            // Create the action struct
            let action = ConfigureDepositsAction { enable, new_max, reset_counter };

            // Serialize it
            let action_data = bcs::to_bytes(&action);

            // Add to intent with pre-serialized bytes
            intent.add_typed_action(
                config_update_deposits(),
                action_data,
                iw
            );

            // Explicitly destroy the action struct
            destroy_configure_deposits_action(action);
        },
    );
}

/// Executes an intent to configure object deposit settings
public fun execute_configure_deposits<Config: store, Outcome: store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version_witness: VersionWitness,
) {
    account.process_intent!(
        registry,
        executable,
        version_witness,
        ConfigureDepositsIntent(),
        |executable, _iw| {
            // Get BCS bytes from ActionSpec
            let specs = executable.intent().action_specs();
            let spec = specs.borrow(executable.action_idx());

            // Check version before deserialization
            let spec_version = account_protocol::intents::action_spec_version(spec);
            assert!(spec_version == 1, EUnsupportedActionVersion);

            let action_data = account_protocol::intents::action_spec_data(spec);

            // Create BCS reader and deserialize
            let mut reader = bcs::new(*action_data);
            let enable = bcs::peel_bool(&mut reader);
            let new_max = bcs::peel_option_u128(&mut reader);
            let reset_counter = bcs::peel_bool(&mut reader);

            // Validate all bytes consumed (prevent trailing data attacks)
            account_protocol::bcs_validation::validate_all_bytes_consumed(reader);

            // Apply the action
            account.apply_deposit_config(enable, new_max, reset_counter);
            account_protocol::executable::increment_action_idx(executable);
        },
    );
}

/// Deletes the ConfigureDepositsAction from an expired intent
public fun delete_configure_deposits(expired: &mut Expired) {
    let spec = expired.remove_action_spec();
    let action_data = account_protocol::intents::action_spec_data(&spec);
    let mut reader = bcs::new(*action_data);

    // We don't need the values, but we must peel them to consume the bytes
    let ConfigureDepositsAction { enable: _, new_max: _, reset_counter: _ } = ConfigureDepositsAction {
        enable: bcs::peel_bool(&mut reader),
        new_max: bcs::peel_option_u128(&mut reader),
        reset_counter: bcs::peel_bool(&mut reader)
    };
}

/// Creates an intent to manage type whitelist
public fun request_manage_whitelist<Config: store, Outcome: store>(
    auth: Auth,
    account: &mut Account,
    registry: &PackageRegistry,
    outcome: Outcome,
    params: Params,
    add_types: vector<String>,
    remove_types: vector<String>,
    ctx: &mut TxContext,
) {
    account.verify(auth);
    account.build_intent!(
        registry,
        params,
        outcome,
        b"ManageWhitelistIntent".to_string(),
        version::current(),
        ManageWhitelistIntent(),
        ctx,
        |intent, iw| {
            // Create the action struct
            let action = ManageWhitelistAction { add_types, remove_types };

            // Serialize it
            let action_data = bcs::to_bytes(&action);

            // Add to intent with pre-serialized bytes
            intent.add_typed_action(
                config_manage_whitelist(),
                action_data,
                iw
            );

            // Explicitly destroy the action struct
            destroy_manage_whitelist_action(action);
        },
    );
}

/// Executes an intent to manage type whitelist
public fun execute_manage_whitelist<Config: store, Outcome: store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version_witness: VersionWitness,
) {
    account.process_intent!(
        registry,
        executable,
        version_witness,
        ManageWhitelistIntent(),
        |executable, _iw| {
            // Get BCS bytes from ActionSpec
            let specs = executable.intent().action_specs();
            let spec = specs.borrow(executable.action_idx());

            // Check version before deserialization
            let spec_version = account_protocol::intents::action_spec_version(spec);
            assert!(spec_version == 1, EUnsupportedActionVersion);

            let action_data = account_protocol::intents::action_spec_data(spec);

            // Create BCS reader and deserialize
            let mut reader = bcs::new(*action_data);
            let add_types = peel_vector_string(&mut reader);
            let remove_types = peel_vector_string(&mut reader);

            // Validate all bytes consumed (prevent trailing data attacks)
            account_protocol::bcs_validation::validate_all_bytes_consumed(reader);

            // Apply the action
            account.apply_whitelist_changes(&add_types, &remove_types);
            account_protocol::executable::increment_action_idx(executable);
        },
    );
}

/// Deletes the ManageWhitelistAction from an expired intent
public fun delete_manage_whitelist(expired: &mut Expired) {
    let spec = expired.remove_action_spec();
    let action_data = account_protocol::intents::action_spec_data(&spec);
    let mut reader = bcs::new(*action_data);

    // We don't need the values, but we must peel them to consume the bytes
    let ManageWhitelistAction { add_types: _, remove_types: _ } = ManageWhitelistAction {
        add_types: peel_vector_string(&mut reader),
        remove_types: peel_vector_string(&mut reader)
    };
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

// Portions of this file are derived from the account.tech Move Framework project.
// Those portions remain licensed under the Apache License, Version 2.0.

/// [Intent Interface] - Functions to create intents and add actions to them.
///
/// 1. Build an intent by stacking actions into it.
/// 2. Process an intent by executing the actions sequentially.

module account_protocol::intent_interface;

use account_protocol::account::{Self, Account};
use account_protocol::executable::Executable;
use account_protocol::intents::{Intent, Params};
use account_protocol::version_witness::VersionWitness;
use std::string::String;

// === Imports ===

// === Public functions ===

/// Example implementation:
///
/// ```move
///
/// public fun request_intent_name<Config, Outcome: store>(
///     auth: Auth,
///     account: &mut Account<Config>,
///     params: Params,
///     outcome: Outcome,
///     action1: Action1,
///     action2: Action2,
///     ctx: &mut TxContext
/// ) {
///     account.verify(auth);
///     params.assert_single_execution(); // if not a recurring intent
///
///     account.build_intent!(
///         params,
///         outcome,
///         b"".to_string(),
///         version::current(),
///         IntentWitness(),
///         ctx,
///         |intent, iw| {
///             intent.add_action(action1, iw);
///             intent.add_action(action2, iw);
///         }
///     );
/// }
///
/// ```

/// Creates an intent with actions and adds it to the account.
public macro fun build_intent<$Config: store, $Outcome, $IW: drop>(
    $account: &mut Account,
    $registry: &account_protocol::package_registry::PackageRegistry,
    $params: Params,
    $outcome: $Outcome,
    $managed_name: String,
    $version_witness: VersionWitness,
    $intent_witness: $IW,
    $ctx: &mut TxContext,
    $new_actions: |&mut Intent<$Outcome>, $IW|,
) {
    let mut intent = account::create_intent(
        $account,
        $registry,
        $params,
        $outcome,
        $managed_name,
        $version_witness,
        $intent_witness,
        $ctx,
    );

    $new_actions(&mut intent, $intent_witness);

    account::insert_intent($account, $registry, intent, $version_witness, $intent_witness);
}

/// Example implementation:
///
/// ```move
///
/// public fun execute_intent_name<Config, Outcome: store>(
///     executable: &mut Executable<Outcome>,
///     account: &mut Account<Config>,
/// ) {
///     account.process_intent!(
///         executable,
///         version::current(),
///         ConfigDepsIntent(),
///         |executable, iw| {
///             do_action(executable, iw, <ADDITIONAL_ARG>)
///             do_other_action(executable, iw)
///         }
///     );
/// }
///
/// ```

/// Executes the actions from the executable intent.
public macro fun process_intent<$Config: store, $Outcome: store, $IW: drop>(
    $account: &Account,
    $registry: &account_protocol::package_registry::PackageRegistry,
    $executable: &mut Executable<$Outcome>,
    $version_witness: VersionWitness,
    $intent_witness: $IW,
    $do_actions: |&mut Executable<$Outcome>, $IW| -> _,
): _ {
    let account = $account;
    let executable = $executable;
    let registry = $registry;
    // let version_witness = $version_witness;
    // let intent_witness = $intent_witness;
    // ensures the package address is a dependency for this account
    account.deps().check($version_witness, registry);
    // ensures the right account is passed
    executable.intent().assert_is_account(account.addr());
    // ensures the intent is created by the same package that creates the action
    executable.intent().assert_is_witness($intent_witness);

    $do_actions(executable, $intent_witness)
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

// Portions of this file are derived from the account.tech Move Framework project.
// Those portions remain licensed under the Apache License, Version 2.0.

/// [Account Interface] - High level functions to create required "methods" for the account.
///
/// 1. Define a new Account type with a specific config and default dependencies.
/// 2. Define a mechanism to authenticate an address to grant permission to call certain functions.
/// 3. Define a way to modify the outcome of an intent.
/// 4. Define an `Outcome.validate()` that will be called upon intent execution.

module account_protocol::account_interface;

use account_protocol::account::{Self, Account, Auth};
use account_protocol::deps::Deps;
use account_protocol::executable::Executable;
use account_protocol::version_witness::VersionWitness;
use std::string::String;
use sui::clock::Clock;

// === Imports ===

// === Public functions ===

/// Example implementation:
///
/// ```move
///
/// public struct Witness() has drop;
///
/// public fun new_account(
///     extensions: &Extensions,
///     ctx: &mut TxContext,
/// ): Account {
///     fees.process(coin);
///
///     let config = Config {
///        .. <FIELDS>
///     };
///
///     create_account!(
///        config,
///        version::current(),
///        Witness(),
///        ctx,
///        || deps::new(extensions)
///     )
/// }
///
/// ```

/// Returns a new Account object with a specific config and initialize dependencies.
public macro fun create_account<$Config: store, $CW: drop>(
    $config: $Config,
    $version_witness: VersionWitness,
    $config_witness: $CW,
    $ctx: &mut TxContext,
    $init_deps: || -> Deps,
): Account {
    let deps = $init_deps();
    account::new<$Config, $CW>($config, deps, $version_witness, $config_witness, $ctx)
}

/// Example implementation:
///
/// ```move
///
/// public fun authenticate(
///     account: &Account,
///     ctx: &TxContext
/// ): Auth {
///     authenticate!(
///        account,
///        version::current(),
///        Witness(),
///        || account.config::<Config>().assert_is_member(ctx)
///     )
/// }
///
/// ```

/// Returns an Auth if the conditions passed are met (used to create intents and more).
public macro fun create_auth<$Config: store, $CW: drop>(
    $account: &Account,
    $registry: &account_protocol::package_registry::PackageRegistry,
    $version_witness: VersionWitness,
    $config_witness: $CW,
    $grant_permission: ||, // condition to grant permission, must throw if not met
): Auth {
    let account = $account;
    let registry = $registry;

    $grant_permission();

    account.new_auth<$Config, $CW>(registry, $version_witness, $config_witness)
}

/// Example implementation:
///
/// ```move
///
/// public fun approve_intent<Config: store>(
///     account: &mut Account,
///     key: String,
///     ctx: &TxContext
/// ) {
///     <PREPARE_DATA>
///
///     resolve_intent!(
///         account,
///         key,
///         version::current(),
///         Witness(),
///         |outcome_mut| {
///             <DO_SOMETHING>
///         }
///     );
/// }
///
/// ```

/// Modifies the outcome of an intent.
public macro fun resolve_intent<$Config: store, $Outcome, $CW: drop>(
    $account: &mut Account,
    $key: String,
    $version_witness: VersionWitness,
    $config_witness: $CW,
    $modify_outcome: |&mut $Outcome|,
) {
    let account = $account;

    let outcome_mut = account
        .intents_mut<$Config, $CW>($version_witness, $config_witness)
        .get_mut($key)
        .outcome_mut<$Outcome>();

    $modify_outcome(outcome_mut);
}

/// Example implementation:
///
/// IMPORTANT: You must provide an Outcome.validate() function that will be called automatically.
/// It must take the outcome by value, a reference to the Config and the role of the intent even if not used.
///
/// ```move
///
/// public fun execute_intent(
///     account: &mut Account,
///     key: String,
///     clock: &Clock,
/// ): Executable<Outcome> {
///     execute_intent!<Config, Outcome, _>(account, key, clock, version::current(), Witness())
/// }
///
/// fun validate_outcome(
///     outcome: Outcome,
///     config: &Config,
///     role: String,
/// ) {
///     let Outcome { fields, .. } = outcome;
///
///     assert!(<CHECK_CONDITIONS>);
/// }
///
/// ```

/// Validates the outcome of an intent and returns an executable.
public macro fun execute_intent<$Config: store, $Outcome, $CW: drop>(
    $account: &mut Account,
    $key: String,
    $clock: &Clock,
    $version_witness: VersionWitness,
    $config_witness: $CW,
    $ctx: &mut TxContext,
    $validate_outcome: |$Outcome|,
): Executable<$Outcome> {
    let (outcome, executable) = account::create_executable<$Config, $Outcome, $CW>(
        $account,
        $key,
        $clock,
        $version_witness,
        $config_witness,
        $ctx,
    );

    $validate_outcome(outcome);

    executable
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Init wrappers for Move Framework actions during DAO creation
///
/// This module provides public functions for init actions.
/// These functions need to be in the account_actions package to access
/// package-visibility functions like do_*_unshared().
module account_actions::init_actions;

use account_actions::{currency, vault, access_control, version};
use account_protocol::account::Account;
use account_protocol::package_registry::PackageRegistry;
use std::string;
use sui::coin::{Coin, TreasuryCap};
use sui::tx_context::TxContext;

// === Vault Actions ===

public fun init_vault_deposit<Config: store, CoinType: drop>(
    account: &mut Account,
    registry: &PackageRegistry,
    vault_name: string::String,
    coin: Coin<CoinType>,
    ctx: &mut TxContext,
) {
    vault::do_deposit_unshared(account, registry, vault_name, coin, ctx);
}

public fun init_vault_spend<Config: store, CoinType: drop>(
    account: &mut Account,
    registry: &PackageRegistry,
    vault_name: string::String,
    amount: u64,
    ctx: &mut TxContext,
): Coin<CoinType> {
    vault::do_spend_unshared(account, registry, vault_name, amount, ctx)
}

// === Currency Actions ===

public fun init_lock_treasury_cap<Config: store, CoinType>(
    account: &mut Account,
    registry: &PackageRegistry,
    cap: TreasuryCap<CoinType>,
) {
    currency::do_lock_cap_unshared(account, registry, cap);
}

public fun init_mint<Config: store, CoinType>(
    account: &mut Account,
    registry: &PackageRegistry,
    amount: u64,
    recipient: address,
    ctx: &mut TxContext,
) {
    currency::do_mint_unshared<CoinType>(account, registry, amount, recipient, ctx);
}

public fun init_mint_to_coin<Config: store, CoinType>(
    account: &mut Account,
    registry: &PackageRegistry,
    amount: u64,
    ctx: &mut TxContext,
): Coin<CoinType> {
    currency::do_mint_to_coin_unshared<CoinType>(account, registry, amount, ctx)
}

public fun init_remove_treasury_cap<Config: store, CoinType>(
    account: &mut Account,
    registry: &PackageRegistry,
    recipient: address,
) {
    currency::do_remove_treasury_cap_unshared<CoinType>(account, registry, recipient)
}

// === Access Control Actions ===

public fun init_lock_cap<Config: store, Cap: key + store>(
    account: &mut Account,
    registry: &PackageRegistry,
    cap: Cap,
) {
    access_control::do_lock_cap_unshared(account, registry, cap);
}

// === Owned Actions ===

public fun init_store_object<Config: store, Key: copy + drop + store, T: key + store>(
    account: &mut Account,
    registry: &PackageRegistry,
    key: Key,
    object: T,
) {
    account.add_managed_asset(registry, key, object, version::current());
}

public fun init_store_data<Config: store, Key: copy + drop + store, T: store>(
    account: &mut Account,
    registry: &PackageRegistry,
    key: Key,
    data: T,
) {
    account.add_managed_data(registry, key, data, version::current());
}

// === Stream Actions ===

public fun init_create_stream<Config: store, CoinType: drop>(
    account: &mut Account,
    registry: &PackageRegistry,
    vault_name: string::String,
    beneficiary: address,
    amount_per_iteration: u64,
    start_time: u64,
    iterations_total: u64,
    iteration_period_ms: u64,
    cliff_time: std::option::Option<u64>,
    claim_window_ms: std::option::Option<u64>,
    max_per_withdrawal: u64,
    is_transferable: bool,
    is_cancellable: bool,
    clock: &sui::clock::Clock,
    ctx: &mut TxContext,
): sui::object::ID {
    vault::create_stream_unshared<Config, CoinType>(
        account,
        registry,
        vault_name,
        beneficiary,
        amount_per_iteration,
        start_time,
        iterations_total,
        iteration_period_ms,
        cliff_time,
        claim_window_ms,
        max_per_withdrawal,
        is_transferable,
        is_cancellable,
        clock,
        ctx,
    )
}

// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Init action staging and dispatching for streams
///
/// This module provides action structs and builders for creating
/// vesting streams during DAO initialization.
module account_actions::stream_init_actions;

use account_actions::init_actions;
use account_protocol::account::Account;
use account_protocol::package_registry::PackageRegistry;
use std::option::Option;
use std::string::String;
use sui::clock::Clock;
use sui::object::ID;
use sui::tx_context::TxContext;

// === Action Structs (for staging/dispatching) ===

/// Action to create an iteration-based vesting stream
/// Stored in InitActionSpecs with BCS serialization
public struct CreateStreamAction has store, copy, drop {
    vault_name: String,
    beneficiary: address,
    amount_per_iteration: u64,  // Tokens per iteration (NO DIVISION)
    start_time: u64,
    iterations_total: u64,
    iteration_period_ms: u64,
    cliff_time: Option<u64>,
    claim_window_ms: Option<u64>,
    max_per_withdrawal: u64,
    is_transferable: bool,
    is_cancellable: bool,
}

// === Spec Builders (for staging in InitActionSpecs) ===

/// Add CreateStreamAction to InitActionSpecs
/// Used for staging actions in launchpad raises
public fun add_create_stream_spec(
    specs: &mut account_actions::init_action_specs::InitActionSpecs,
    vault_name: String,
    beneficiary: address,
    amount_per_iteration: u64,
    start_time: u64,
    iterations_total: u64,
    iteration_period_ms: u64,
    cliff_time: Option<u64>,
    claim_window_ms: Option<u64>,
    max_per_withdrawal: u64,
    is_transferable: bool,
    is_cancellable: bool,
) {
    use std::type_name;
    use sui::bcs;

    // Create action struct
    let action = CreateStreamAction {
        vault_name,
        beneficiary,
        amount_per_iteration,
        start_time,
        iterations_total,
        iteration_period_ms,
        cliff_time,
        claim_window_ms,
        max_per_withdrawal,
        is_transferable,
        is_cancellable,
    };

    // Serialize
    let action_data = bcs::to_bytes(&action);

    // Add to specs with marker type from vault module (NOT the action struct!)
    account_actions::init_action_specs::add_action(
        specs,
        type_name::with_defining_ids<account_actions::vault::CreateStream>(),
        action_data
    );
}

// === Dispatchers ===

/// Execute init_create_stream from a staged action
/// Accepts typed action directly (zero deserialization cost!)
public fun dispatch_create_stream<Config: store, CoinType: drop>(
    account: &mut Account,
    registry: &PackageRegistry,
    action: &CreateStreamAction,
    clock: &Clock,
    ctx: &mut TxContext,
): ID {
    // Execute with the exact parameters from the staged action
    account_actions::init_actions::init_create_stream<Config, CoinType>(
        account,
        registry,
        action.vault_name,
        action.beneficiary,
        action.amount_per_iteration,
        action.start_time,
        action.iterations_total,
        action.iteration_period_ms,
        action.cliff_time,
        action.claim_window_ms,
        action.max_per_withdrawal,
        action.is_transferable,
        action.is_cancellable,
        clock,
        ctx,
    )
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Action specification types for staging init actions
/// These are lightweight "blueprints" stored on Raise before DAO creation
/// GENERIC - doesn't know about specific action types
module account_actions::init_action_specs;

use std::type_name::TypeName;

/// Generic action specification - can hold ANY action data
/// The action_type tells us how to interpret the action_data bytes
public struct ActionSpec has store, drop, copy {
    action_type: TypeName,      // Type of the action (e.g., CreateCouncilAction)
    action_data: vector<u8>,    // BCS-serialized action data
}

/// Container for all init action specifications
/// Completely generic - can hold any combination of actions
public struct InitActionSpecs has store, drop, copy {
    actions: vector<ActionSpec>,
}

// === Constructors ===

public fun new_action_spec(
    action_type: TypeName,
    action_data: vector<u8>
): ActionSpec {
    ActionSpec {
        action_type,
        action_data
    }
}

public fun new_init_specs(): InitActionSpecs {
    InitActionSpecs {
        actions: vector::empty(),
    }
}

/// Add a generic action specification
/// The caller is responsible for BCS-serializing the action data
public fun add_action(
    specs: &mut InitActionSpecs,
    action_type: TypeName,
    action_data: vector<u8>
) {
    vector::push_back(&mut specs.actions, ActionSpec {
        action_type,
        action_data,
    });
}

// === Accessors ===

public fun action_type(spec: &ActionSpec): TypeName {
    spec.action_type
}

public fun action_data(spec: &ActionSpec): &vector<u8> {
    &spec.action_data
}

public fun actions(specs: &InitActionSpecs): &vector<ActionSpec> {
    &specs.actions
}

public fun action_count(specs: &InitActionSpecs): u64 {
    vector::length(&specs.actions)
}

public fun get_action(specs: &InitActionSpecs, index: u64): &ActionSpec {
    vector::borrow(&specs.actions, index)
}

// === Equality Functions ===

/// Check if two ActionSpecs are equal
/// Compares both action_type and action_data
public fun action_spec_equals(a: &ActionSpec, b: &ActionSpec): bool {
    if (a.action_type != b.action_type) {
        return false
    };

    // Compare action_data vectors
    let a_data = &a.action_data;
    let b_data = &b.action_data;

    if (vector::length(a_data) != vector::length(b_data)) {
        return false
    };

    let mut i = 0;
    let len = vector::length(a_data);
    while (i < len) {
        if (*vector::borrow(a_data, i) != *vector::borrow(b_data, i)) {
            return false
        };
        i = i + 1;
    };

    true
}

/// Check if two InitActionSpecs are equal
/// Compares all actions in both specs
public fun init_action_specs_equals(a: &InitActionSpecs, b: &InitActionSpecs): bool {
    let a_actions = &a.actions;
    let b_actions = &b.actions;

    if (vector::length(a_actions) != vector::length(b_actions)) {
        return false
    };

    let mut i = 0;
    let len = vector::length(a_actions);
    while (i < len) {
        let a_spec = vector::borrow(a_actions, i);
        let b_spec = vector::borrow(b_actions, i);

        if (!action_spec_equals(a_spec, b_spec)) {
            return false
        };

        i = i + 1;
    };

    true
}// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Init action staging for currency operations during launchpad raises
///
/// This module provides action structs and spec builders for staging currency return actions.
/// Follows the 3-layer action execution pattern (see IMPORTANT_ACTION_EXECUTION_PATTERN.md)
module account_actions::currency_init_actions;

// === Action Structs (for BCS serialization) ===

/// Action to return TreasuryCap to creator when raise fails
/// PTB will call: currency::do_init_remove_treasury_cap<Config, Outcome, CoinType, IW>(executable, ...)
public struct ReturnTreasuryCapAction has store, copy, drop {
    recipient: address,
}

/// Action to return CoinMetadata to creator when raise fails
/// PTB will call: currency::do_init_remove_metadata<Config, Outcome, Key, CoinType, IW>(executable, ...)
public struct ReturnMetadataAction has store, copy, drop {
    recipient: address,
}

// === Spec Builders ===

/// Add ReturnTreasuryCapAction to InitActionSpecs
/// Used for staging failure actions in launchpad raises
/// Uses marker type from currency module (not action struct type)
public fun add_return_treasury_cap_spec(
    specs: &mut account_actions::init_action_specs::InitActionSpecs,
    recipient: address,
) {
    use std::type_name;
    use sui::bcs;

    let action = ReturnTreasuryCapAction { recipient };
    let action_data = bcs::to_bytes(&action);

    // CRITICAL: Use marker type from currency module, not action struct type
    account_actions::init_action_specs::add_action(
        specs,
        type_name::with_defining_ids<account_actions::currency::RemoveTreasuryCap>(),
        action_data
    );
}

/// Add ReturnMetadataAction to InitActionSpecs
/// Used for staging failure actions in launchpad raises
/// Uses marker type from currency module (not action struct type)
public fun add_return_metadata_spec(
    specs: &mut account_actions::init_action_specs::InitActionSpecs,
    recipient: address,
) {
    use std::type_name;
    use sui::bcs;

    let action = ReturnMetadataAction { recipient };
    let action_data = bcs::to_bytes(&action);

    // CRITICAL: Use marker type from currency module, not action struct type
    account_actions::init_action_specs::add_action(
        specs,
        type_name::with_defining_ids<account_actions::currency::RemoveMetadata>(),
        action_data
    );
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

// Portions of this file are derived from the account.tech Move Framework project.
// Those portions remain licensed under the Apache License, Version 2.0.

/// This module tracks the version of the package by implementing the version_witness type.
/// A new version type should be defined for each new version of the package.

module account_actions::version;

use account_protocol::version_witness::{Self, VersionWitness};

// === Imports ===

// === Constants ===

const VERSION: u64 = 1; // bump this when the package is upgraded

// === Structs ===

// define a new version struct for each new version of the package
public struct V1() has drop;

public fun current(): VersionWitness {
    version_witness::new(V1()) // modify with the new version struct
}

// === Public functions ===

public fun get(): u64 {
    VERSION
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

// Portions of this file are derived from the account.tech Move Framework project.
// Those portions remain licensed under the Apache License, Version 2.0.

/// Package managers can lock UpgradeCaps in the account. Caps can't be unlocked, this is to enforce the policies.
/// Any rule can be defined for the upgrade lock. The module provide a timelock rule by default, based on execution time.
/// Upon locking, the user can define an optional timelock corresponding to the minimum delay between an upgrade proposal and its execution.
/// The account can decide to make the policy more restrictive or destroy the Cap, to make the package immutable.

module account_actions::package_upgrade;

// === Imports ===

use std::{
    string::String,
    option::{Self, Option},
};
use sui::{
    package::{Self, UpgradeCap, UpgradeTicket, UpgradeReceipt},
    clock::Clock,
    vec_map::{Self, VecMap},
    bcs::{Self, BCS},
    transfer,
};
use account_protocol::{
    action_validation,
    account::{Account, Auth},
    intents::{Self, Expired, Intent},
    executable::{Self, Executable},
    version_witness::VersionWitness,
    bcs_validation,
    package_registry::PackageRegistry,
};
use account_actions::{
    version,
};

// === Use Fun Aliases ===

// === Error ===

const ELockAlreadyExists: u64 = 0;
const EUpgradeTooEarly: u64 = 1;
const EPackageDoesntExist: u64 = 2;
const EUnsupportedActionVersion: u64 = 3;
const ECommitCapMismatch: u64 = 4;
const ENoCommitCap: u64 = 5;
const EReclaimTooEarly: u64 = 6;
const ENoReclaimRequest: u64 = 7;
const ECapRevoked: u64 = 8;
const EReclaimNotExpired: u64 = 9;
const EReclaimPending: u64 = 10;
const EReclaimAlreadyPending: u64 = 11;
const EProposalNotApproved: u64 = 12;
const EProposalNotFound: u64 = 13;
const EDigestMismatch: u64 = 14;

// === Events ===

/// Emitted when DAO requests to reclaim commit cap from external holder
public struct ReclaimRequested has copy, drop {
    package_name: String,
    dao_account: address,
    request_time_ms: u64,
    available_after_ms: u64,
    new_nonce: u256,
}

/// Emitted when DAO finalizes reclaim after timelock expires
public struct ReclaimFinalized has copy, drop {
    package_name: String,
    dao_account: address,
    finalized_at_ms: u64,
    final_nonce: u256,
}

/// Emitted when an UpgradeCommitCap is created
public struct CommitCapCreated has copy, drop {
    package_name: String,
    cap_id: ID,
    recipient: address,
    nonce: u256,
}

/// Emitted when an UpgradeCommitCap is locked in an account
public struct CommitCapLocked has copy, drop {
    package_name: String,
    cap_id: ID,
    account: address,
    nonce: u256,
}

/// Emitted when upgrade is committed using DAO-only mode
public struct UpgradeCommittedDaoOnly has copy, drop {
    package_name: String,
    dao_account: address,
    new_package_addr: address,
}

/// Emitted when upgrade is committed using commit cap
public struct UpgradeCommittedWithCap has copy, drop {
    package_name: String,
    dao_account: address,
    new_package_addr: address,
    cap_nonce: u256,
}

/// Emitted when a commit cap is destroyed and DAO takes immediate control
public struct CommitCapDestroyed has copy, drop {
    package_name: String,
    cap_id: ID,
    destroyed_by: address,
}

/// Emitted when reclaim delay is updated (during cap creation)
public struct ReclaimDelayUpdated has copy, drop {
    package_name: String,
    old_delay_ms: u64,
    new_delay_ms: u64,
    updated_via: address, // Address receiving the new cap
}

/// Emitted when a new upgrade digest is proposed
public struct UpgradeDigestProposed has copy, drop {
    package_name: String,
    digest: vector<u8>,
    proposed_at_ms: u64,
    execution_time_ms: u64,
}

/// Emitted when an upgrade digest is approved by governance
public struct UpgradeDigestApproved has copy, drop {
    package_name: String,
    digest: vector<u8>,
    approved_at_ms: u64,
}

/// Emitted when an approved upgrade is executed (ticket created)
public struct UpgradeTicketCreated has copy, drop {
    package_name: String,
    digest: vector<u8>,
    mode: String, // "dao_only" or "with_cap"
}

/// Emitted when an upgrade is completed (receipt consumed)
public struct UpgradeCompleted has copy, drop {
    package_name: String,
    digest: vector<u8>,
    new_package_addr: address,
    mode: String, // "dao_only" or "with_cap"
}

// === Action Type Markers ===

/// Upgrade package
public struct PackageUpgrade has drop {}
/// Commit upgrade
public struct PackageCommit has drop {}
/// Restrict upgrade policy
public struct PackageRestrict has drop {}
/// Create and transfer commit cap
public struct PackageCreateCommitCap has drop {}

public fun package_upgrade(): PackageUpgrade { PackageUpgrade {} }
public fun package_commit(): PackageCommit { PackageCommit {} }
public fun package_restrict(): PackageRestrict { PackageRestrict {} }
public fun package_create_commit_cap(): PackageCreateCommitCap { PackageCreateCommitCap {} }

// === Structs ===

/// Dynamic Object Field key for the UpgradeCap.
public struct UpgradeCapKey(String) has copy, drop, store;
/// Dynamic field key for the UpgradeRules.
public struct UpgradeRulesKey(String) has copy, drop, store;
/// Dynamic field key for the UpgradeIndex.
public struct UpgradeIndexKey() has copy, drop, store;
/// Dynamic Object Field key for the UpgradeCommitCap.
public struct UpgradeCommitCapKey(String) has copy, drop, store;
/// Dynamic field key for UpgradeProposal (keyed by package_name + digest hash)
public struct UpgradeProposalKey has copy, drop, store {
    package_name: String,
    digest_hash: address, // hash of digest for unique key
}

/// Helper to create UpgradeProposalKey from digest
fun proposal_key(package_name: String, digest: vector<u8>): UpgradeProposalKey {
    use sui::hash;
    let digest_hash = object::id_from_bytes(hash::blake2b256(&digest)).to_address();
    UpgradeProposalKey { package_name, digest_hash }
}

/// Proposal for a package upgrade - stores the digest for governance voting
/// This replaces the hot-potato UpgradeAction pattern
public struct UpgradeProposal has store, drop {
    package_name: String,
    digest: vector<u8>,
    proposed_time_ms: u64,
    execution_time_ms: u64,  // Can't execute before this (timelock)
    approved: bool,
}

/// Capability granting authority to commit package upgrades
/// Held by core team/multisig to restrict who can finalize upgrades
/// valid_nonce must match current commit_nonce in UpgradeRules or cap is revoked
public struct UpgradeCommitCap has key, store {
    id: UID,
    package_name: String,
    valid_nonce: u256,
}

/// Dynamic field wrapper defining an optional timelock.
public struct UpgradeRules has store {
    // minimum delay between proposal and execution
    delay_ms: u64,
    // Optional: timestamp when DAO requested to reclaim commit cap from external holder
    // If Some(timestamp), DAO can reclaim after reclaim_delay_ms has passed
    reclaim_request_time: Option<u64>,
    // Duration in ms before DAO can reclaim commit cap (e.g., 6 months = 15552000000)
    reclaim_delay_ms: u64,
    // Nonce that increments on reclaim request, invalidating existing commit caps
    // Caps must have valid_nonce == commit_nonce to be valid
    commit_nonce: u256,
} 

/// Map tracking the latest upgraded package address for a package name.
public struct UpgradeIndex has store {
    // map of package name to address
    packages_info: VecMap<String, address>,
}

public struct RestrictAction has drop, store {
    // name of the package
    name: String,
    // downgrades to this policy
    policy: u8,
}

/// Action for upgrading a package
public struct UpgradeAction has drop, store {
    name: String,
    digest: vector<u8>,
}

/// Action for committing an upgrade
public struct CommitAction has drop, store {
    name: String,
}

/// Action for creating a commit cap
public struct CreateCommitCapAction has drop, store {
    name: String,
    recipient: address,
    new_reclaim_delay_ms: u64,
}

// === Public Functions ===

/// Attaches the UpgradeCap as a Dynamic Object Field to the account.
/// reclaim_delay_ms: Time DAO must wait after requesting reclaim (e.g., 6 months)
public fun lock_cap(
    auth: Auth,
    account: &mut Account,
    registry: &PackageRegistry,
    cap: UpgradeCap,
    name: String, // name of the package
    delay_ms: u64, // minimum delay between proposal and execution
    reclaim_delay_ms: u64, // delay before DAO can reclaim commit cap
) {
    account.verify(auth);
    assert!(!has_cap(account, name), ELockAlreadyExists);

    if (!account.has_managed_data(UpgradeIndexKey()))
        account.add_managed_data(registry, UpgradeIndexKey(), UpgradeIndex { packages_info: vec_map::empty() }, version::current());

    let upgrade_index_mut: &mut UpgradeIndex = account.borrow_managed_data_mut(registry, UpgradeIndexKey(), version::current());
    upgrade_index_mut.packages_info.insert(name, cap.package().to_address());

    account.add_managed_asset(registry, UpgradeCapKey(name), cap, version::current());
    account.add_managed_data(
        registry,
        UpgradeRulesKey(name),
        UpgradeRules {
            delay_ms,
            reclaim_request_time: option::none(),
            reclaim_delay_ms,
            commit_nonce: 0,
        },
        version::current()
    );
}

/// Lock upgrade cap during initialization - works on unshared Accounts
/// This function is for use during account creation, before the account is shared.
public(package) fun do_lock_cap_unshared(
    account: &mut Account,
    registry: &PackageRegistry,
    cap: UpgradeCap,
    name: String,
    delay_ms: u64,
    reclaim_delay_ms: u64,
) {
    assert!(!has_cap(account, name), ELockAlreadyExists);

    if (!account.has_managed_data(UpgradeIndexKey()))
        account.add_managed_data(registry, UpgradeIndexKey(), UpgradeIndex { packages_info: vec_map::empty() }, version::current());

    let upgrade_index_mut: &mut UpgradeIndex = account.borrow_managed_data_mut(registry, UpgradeIndexKey(), version::current());
    upgrade_index_mut.packages_info.insert(name, cap.package().to_address());

    account.add_managed_asset(registry, UpgradeCapKey(name), cap, version::current());
    account.add_managed_data(
        registry,
        UpgradeRulesKey(name),
        UpgradeRules {
            delay_ms,
            reclaim_request_time: option::none(),
            reclaim_delay_ms,
            commit_nonce: 0,
        },
        version::current()
    );
}

/// Creates an UpgradeCommitCap and locks it in an Account
/// This cap grants authority to commit package upgrades (finalize with UpgradeReceipt)
/// Typically given to core team multisig for security
/// Cap is created with current nonce from UpgradeRules
public fun lock_commit_cap(
    auth: Auth,
    account: &mut Account,
    registry: &PackageRegistry,
    package_name: String,
    ctx: &mut TxContext,
) {
    account.verify(auth);

    // Get current nonce
    let rules: &UpgradeRules = account.borrow_managed_data(
        registry,
        UpgradeRulesKey(package_name),
        version::current()
    );
    let current_nonce = rules.commit_nonce;

    let cap_id = object::new(ctx);
    let cap_id_copy = object::uid_to_inner(&cap_id);

    let commit_cap = UpgradeCommitCap {
        id: cap_id,
        package_name,
        valid_nonce: current_nonce,
    };

    account.add_managed_asset(
        registry,
        UpgradeCommitCapKey(package_name),
        commit_cap,
        version::current()
    );

    sui::event::emit(CommitCapLocked {
        package_name,
        cap_id: cap_id_copy,
        account: account.addr(),
        nonce: current_nonce,
    });
}

/// Lock commit cap during initialization - works on unshared Accounts
public(package) fun do_lock_commit_cap_unshared(
    account: &mut Account,
    registry: &PackageRegistry,
    package_name: String,
    ctx: &mut TxContext,
) {
    // Get current nonce (should be 0 at init)
    let rules: &UpgradeRules = account.borrow_managed_data(
        registry,
        UpgradeRulesKey(package_name),
        version::current()
    );
    let current_nonce = rules.commit_nonce;

    let commit_cap = UpgradeCommitCap {
        id: object::new(ctx),
        package_name,
        valid_nonce: current_nonce,
    };

    account.add_managed_asset(
        registry,
        UpgradeCommitCapKey(package_name),
        commit_cap,
        version::current()
    );
}

/// Creates an UpgradeCommitCap and transfers it to a recipient
/// Use this to give commit authority to an external multisig
/// Cap is created with current nonce - will be invalidated if DAO requests reclaim
/// BLOCKED if reclaim is currently pending (to avoid confusion)
public fun create_and_transfer_commit_cap<Config: store>(
    auth: Auth,
    account: &Account,
    registry: &PackageRegistry,
    package_name: String,
    recipient: address,
    ctx: &mut TxContext,
) {
    account.verify(auth);

    // Get current nonce
    let rules: &UpgradeRules = account.borrow_managed_data(
        registry,
        UpgradeRulesKey(package_name),
        version::current()
    );

    // Block cap creation if reclaim is pending
    assert!(option::is_none(&rules.reclaim_request_time), EReclaimPending);

    let current_nonce = rules.commit_nonce;

    let cap_id = object::new(ctx);
    let cap_id_copy = object::uid_to_inner(&cap_id);

    let commit_cap = UpgradeCommitCap {
        id: cap_id,
        package_name,
        valid_nonce: current_nonce,
    };

    sui::event::emit(CommitCapCreated {
        package_name,
        cap_id: cap_id_copy,
        recipient,
        nonce: current_nonce,
    });

    transfer::transfer(commit_cap, recipient);
}

/// Checks if account has a commit cap for a package
public fun has_commit_cap(
    account: &Account,
    package_name: String,
): bool {
    account.has_managed_asset(UpgradeCommitCapKey(package_name))
}

/// Get the package name from an UpgradeCommitCap
public fun commit_cap_package_name(cap: &UpgradeCommitCap): String {
    cap.package_name
}

/// Get the valid nonce from an UpgradeCommitCap
public fun commit_cap_valid_nonce(cap: &UpgradeCommitCap): u256 {
    cap.valid_nonce
}

/// Get the current commit nonce from UpgradeRules
/// This is the nonce that new caps will be created with
/// Existing caps are only valid if their nonce matches this value
public fun get_current_commit_nonce(
    account: &Account,
    registry: &PackageRegistry,
    package_name: String,
): u256 {
    let rules: &UpgradeRules = account.borrow_managed_data(
        registry,
        UpgradeRulesKey(package_name),
        version::current()
    );
    rules.commit_nonce
}

/// Returns true if the account has an UpgradeCap for a given package name.
public fun has_cap(
    account: &Account, 
    name: String
): bool {
    account.has_managed_asset(UpgradeCapKey(name))
}

/// Returns the address of the package for a given package name.
public fun get_cap_package(
    account: &Account,
    registry: &PackageRegistry,
    name: String
): address {
    account.borrow_managed_asset<UpgradeCapKey, UpgradeCap>(registry, UpgradeCapKey(name), version::current()).package().to_address()
} 

/// Returns the version of the UpgradeCap for a given package name.
public fun get_cap_version(
    account: &Account,
    registry: &PackageRegistry,
    name: String
): u64 {
    account.borrow_managed_asset<UpgradeCapKey, UpgradeCap>(registry, UpgradeCapKey(name), version::current()).version()
} 

/// Returns the policy of the UpgradeCap for a given package name.
public fun get_cap_policy(
    account: &Account,
    registry: &PackageRegistry,
    name: String
): u8 {
    account.borrow_managed_asset<UpgradeCapKey, UpgradeCap>(registry, UpgradeCapKey(name), version::current()).policy()
} 

/// Returns the timelock of the UpgradeRules for a given package name.
public fun get_time_delay(
    account: &Account,
    registry: &PackageRegistry,
    name: String
): u64 {
    account.borrow_managed_data<UpgradeRulesKey, UpgradeRules>(registry, UpgradeRulesKey(name), version::current()).delay_ms
}

/// Returns the map of package names to package addresses.
public fun get_packages_info(
    account: &Account,
    registry: &PackageRegistry
): &VecMap<String, address> {
    &account.borrow_managed_data<UpgradeIndexKey, UpgradeIndex>(registry, UpgradeIndexKey(), version::current()).packages_info
}

/// Returns true if the package is managed by the account.
public fun is_package_managed(
    account: &Account,
    registry: &PackageRegistry,
    package_addr: address
): bool {
    if (!account.has_managed_data(UpgradeIndexKey())) return false;
    let index: &UpgradeIndex = account.borrow_managed_data(registry, UpgradeIndexKey(), version::current());

    let mut i = 0;
    while (i < index.packages_info.length()) {
        let (_, value) = index.packages_info.get_entry_by_idx(i);
        if (value == package_addr) return true;
        i = i + 1;
    };

    false
}

/// Returns the address of the package for a given package name.
public fun get_package_addr(
    account: &Account,
    registry: &PackageRegistry,
    package_name: String
): address {
    let index: &UpgradeIndex = account.borrow_managed_data(registry, UpgradeIndexKey(), version::current());
    *index.packages_info.get(&package_name)
}

/// Returns the package name for a given package address.
#[allow(unused_assignment)] // false positive
public fun get_package_name(
    account: &Account,
    registry: &PackageRegistry,
    package_addr: address
): String {
    let index: &UpgradeIndex = account.borrow_managed_data(registry, UpgradeIndexKey(), version::current());
    let (mut i, mut package_name) = (0, b"".to_string());
    loop {
        let (name, addr) = index.packages_info.get_entry_by_idx(i);
        package_name = *name;
        if (addr == package_addr) break package_name;
        
        i = i + 1;
        if (i == index.packages_info.length()) abort EPackageDoesntExist;
    };
    
    package_name
}

// === Destruction Functions ===

/// Destroy an UpgradeAction after serialization
public fun destroy_upgrade_action(action: UpgradeAction) {
    let UpgradeAction { name: _, digest: _ } = action;
}

/// Destroy a CommitAction after serialization
public fun destroy_commit_action(action: CommitAction) {
    let CommitAction { name: _ } = action;
}

/// Destroy a RestrictAction after serialization
public fun destroy_restrict_action(action: RestrictAction) {
    let RestrictAction { name: _, policy: _ } = action;
}

/// Destroy a CreateCommitCapAction after serialization
public fun destroy_create_commit_cap_action(action: CreateCommitCapAction) {
    let CreateCommitCapAction { name: _, recipient: _, new_reclaim_delay_ms: _ } = action;
}

// Intent functions

/// Creates a new UpgradeAction and adds it to an intent.

/// Processes an UpgradeAction and returns a UpgradeTicket.
public fun do_upgrade<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    clock: &Clock,
    version_witness: VersionWitness,
    _intent_witness: IW,
): UpgradeTicket {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<PackageUpgrade>(spec);

    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let name = bcs::peel_vec_u8(&mut reader).to_string();
    let digest = bcs::peel_vec_u8(&mut reader);

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    assert!(
        clock.timestamp_ms() >= executable.intent().creation_time() + get_time_delay(account, registry, name),
        EUpgradeTooEarly
    );

    let cap: &mut UpgradeCap = account.borrow_managed_asset_mut(registry, UpgradeCapKey(name), version_witness);
    let policy = cap.policy();

    // Increment action index
    executable::increment_action_idx(executable);

    cap.authorize_upgrade(policy, digest) // return ticket
}    

/// Deletes an UpgradeAction from an expired intent.
public fun delete_upgrade(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, automatically cleaned up
}


// must be called after UpgradeAction is processed, there cannot be any other action processed before
/// Commits an upgrade WITHOUT requiring commit cap validation
/// Use this when DAO has full control over upgrades OR when reclaim timelock has expired
/// If a reclaim request is pending, validates that the timelock has expired before allowing DAO-only commit
public fun do_commit_dao_only<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    receipt: UpgradeReceipt,
    clock: &Clock,
    version_witness: VersionWitness,
    _intent_witness: IW,
) {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<PackageCommit>(spec);

    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let _name = bcs::peel_vec_u8(&mut reader).to_string();

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    // SECURITY: If reclaim request is pending, verify timelock has expired
    let rules: &UpgradeRules = account.borrow_managed_data(
        registry,
        UpgradeRulesKey(_name),
        version_witness
    );

    if (option::is_some(&rules.reclaim_request_time)) {
        let request_time = *option::borrow(&rules.reclaim_request_time);
        let current_time = clock.timestamp_ms();
        assert!(
            current_time >= request_time + rules.reclaim_delay_ms,
            EReclaimNotExpired
        );
    };
    // If no reclaim request, DAO can commit anytime (pure DAO-only mode)

    let cap_mut: &mut UpgradeCap = account.borrow_managed_asset_mut(registry, UpgradeCapKey(_name), version_witness);
    cap_mut.commit_upgrade(receipt);
    let new_package_addr = cap_mut.package().to_address();

    // update the index with the new package address
    let index_mut: &mut UpgradeIndex = account.borrow_managed_data_mut(registry, UpgradeIndexKey(), version_witness);
    *index_mut.packages_info.get_mut(&_name) = new_package_addr;

    sui::event::emit(UpgradeCommittedDaoOnly {
        package_name: _name,
        dao_account: account.addr(),
        new_package_addr,
    });

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Commits an upgrade WITH commit cap validation
/// Use this when core team holds commit authority
/// Cap must have valid nonce matching current commit_nonce or will be rejected
public fun do_commit_with_cap<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    receipt: UpgradeReceipt,
    commit_cap: &UpgradeCommitCap,
    version_witness: VersionWitness,
    _intent_witness: IW,
) {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<PackageCommit>(spec);

    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let name = bcs::peel_vec_u8(&mut reader).to_string();

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    // SECURITY: Validate that the commit cap matches the package being upgraded
    assert!(commit_cap.package_name == name, ECommitCapMismatch);

    // SECURITY: Validate that the cap's nonce matches current nonce (not revoked)
    let rules: &UpgradeRules = account.borrow_managed_data(
        registry,
        UpgradeRulesKey(name),
        version_witness
    );
    assert!(commit_cap.valid_nonce == rules.commit_nonce, ECapRevoked);

    let cap_mut: &mut UpgradeCap = account.borrow_managed_asset_mut(registry, UpgradeCapKey(name), version_witness);
    cap_mut.commit_upgrade(receipt);
    let new_package_addr = cap_mut.package().to_address();

    // update the index with the new package address
    let index_mut: &mut UpgradeIndex = account.borrow_managed_data_mut(registry, UpgradeIndexKey(), version_witness);
    *index_mut.packages_info.get_mut(&name) = new_package_addr;

    sui::event::emit(UpgradeCommittedWithCap {
        package_name: name,
        dao_account: account.addr(),
        new_package_addr,
        cap_nonce: commit_cap.valid_nonce,
    });

    // Increment action index
    executable::increment_action_idx(executable);
}

public fun delete_commit(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, automatically cleaned up
}

/// Processes a RestrictAction and updates the UpgradeCap policy.
public fun do_restrict<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version_witness: VersionWitness,
    _intent_witness: IW,
) {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<PackageRestrict>(spec);

    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let name = bcs::peel_vec_u8(&mut reader).to_string();
    let policy = bcs::peel_u8(&mut reader);

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    // Defense-in-depth: explicitly validate known policy values
    if (policy == package::additive_policy()) {
        let cap_mut: &mut UpgradeCap = account.borrow_managed_asset_mut(registry, UpgradeCapKey(name), version_witness);
        cap_mut.only_additive_upgrades();
    } else if (policy == package::dep_only_policy()) {
        let cap_mut: &mut UpgradeCap = account.borrow_managed_asset_mut(registry, UpgradeCapKey(name), version_witness);
        cap_mut.only_dep_upgrades();
    } else {
        // Only make immutable for the explicit immutable policy (255)
        // Any other policy value should abort rather than defaulting to immutable
        assert!(policy == 255, EUnsupportedActionVersion); // Reuse error code for invalid policy
        let cap: UpgradeCap = account.remove_managed_asset(registry, UpgradeCapKey(name), version_witness);
        package::make_immutable(cap);
    };

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Deletes a RestrictAction from an expired intent.
public fun delete_restrict(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, automatically cleaned up
}

/// Processes a CreateCommitCapAction and creates/transfers the commit cap.
public fun do_create_commit_cap<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    ctx: &mut TxContext,
    version_witness: VersionWitness,
    _intent_witness: IW,
) {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<PackageCreateCommitCap>(spec);

    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let name = bcs::peel_vec_u8(&mut reader).to_string();
    let recipient_bytes = bcs::peel_address(&mut reader);
    let new_reclaim_delay_ms = bcs::peel_u64(&mut reader);

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    // Get current nonce from rules
    let rules_mut: &mut UpgradeRules = account.borrow_managed_data_mut(
        registry,
        UpgradeRulesKey(name),
        version_witness
    );

    // Block if reclaim is pending
    assert!(option::is_none(&rules_mut.reclaim_request_time), EReclaimPending);

    let current_nonce = rules_mut.commit_nonce;
    let old_delay_ms = rules_mut.reclaim_delay_ms;

    // Update reclaim delay
    rules_mut.reclaim_delay_ms = new_reclaim_delay_ms;

    // Emit delay update event
    sui::event::emit(ReclaimDelayUpdated {
        package_name: name,
        old_delay_ms,
        new_delay_ms: new_reclaim_delay_ms,
        updated_via: recipient_bytes,
    });

    // Create the commit cap
    let cap_id = object::new(ctx);
    let cap_id_copy = object::uid_to_inner(&cap_id);

    let commit_cap = UpgradeCommitCap {
        id: cap_id,
        package_name: name,
        valid_nonce: current_nonce,
    };

    // Emit event
    sui::event::emit(CommitCapCreated {
        package_name: name,
        cap_id: cap_id_copy,
        recipient: recipient_bytes,
        nonce: current_nonce,
    });

    // Transfer to recipient
    transfer::transfer(commit_cap, recipient_bytes);

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Deletes a CreateCommitCapAction from an expired intent.
public fun delete_create_commit_cap(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, automatically cleaned up
}

// === Package Funtions ===

/// Borrows the UpgradeCap for a given package address.
public(package) fun borrow_cap<Config: store>(
    account: &Account,
    registry: &PackageRegistry,
    package_addr: address
): &UpgradeCap {
    let name = get_package_name(account, registry, package_addr);
    account.borrow_managed_asset(registry, UpgradeCapKey(name), version::current())
}

// === Commit Cap Borrow/Return Functions ===
// These enable using the commit cap via the access_control pattern

/// Borrow the commit cap from the account (removes it temporarily)
/// Must be returned in the same transaction using return_commit_cap
public fun borrow_commit_cap<Config: store>(
    account: &mut Account,
    registry: &PackageRegistry,
    package_name: String,
    version_witness: VersionWitness,
): UpgradeCommitCap {
    account.remove_managed_asset(registry, UpgradeCommitCapKey(package_name), version_witness)
}

/// Return the commit cap to the account after use
public fun return_commit_cap<Config: store>(
    account: &mut Account,
    registry: &PackageRegistry,
    commit_cap: UpgradeCommitCap,
    version_witness: VersionWitness,
) {
    let package_name = commit_cap.package_name;
    account.add_managed_asset(registry, UpgradeCommitCapKey(package_name), commit_cap, version_witness);
}

/// Create an UpgradeCommitCap for transferring (used in init_actions)
/// This is public(package) as it's only meant for initialization helpers
/// Created with nonce=0 (initial state)
public(package) fun create_commit_cap_for_transfer(
    package_name: String,
    ctx: &mut TxContext,
): UpgradeCommitCap {
    UpgradeCommitCap {
        id: object::new(ctx),
        package_name,
        valid_nonce: 0,
    }
}

/// Transfer commit cap to an address (needed for Sui private transfer rules)
public fun transfer_commit_cap(cap: UpgradeCommitCap, recipient: address) {
    transfer::transfer(cap, recipient);
}

/// Destroys a commit cap and immediately gives DAO full control
/// Anyone holding the cap can call this to destroy it
/// This resets nonce to 0, clears any pending reclaim, giving DAO immediate control
/// Use this when core team wants to hand over control immediately
public fun destroy_commit_cap<Config: store>(
    cap: UpgradeCommitCap,
    account: &mut Account,
    registry: &PackageRegistry,
    ctx: &TxContext,
) {
    let UpgradeCommitCap { id, package_name, valid_nonce: _ } = cap;
    let cap_id = object::uid_to_inner(&id);
    let destroyed_by = ctx.sender();
    object::delete(id);

    // Reset to DAO-only mode: nonce=0, no reclaim pending
    let rules_mut: &mut UpgradeRules = account.borrow_managed_data_mut(
        registry,
        UpgradeRulesKey(package_name),
        version::current()
    );

    rules_mut.commit_nonce = 0;
    rules_mut.reclaim_request_time = option::none();

    // Emit event
    sui::event::emit(CommitCapDestroyed {
        package_name,
        cap_id,
        destroyed_by,
    });
}

// === Commit Cap Reclaim Functions ===

/// DAO initiates reclaim of commit cap from external holder
/// Starts the timelock countdown (e.g., 6 months)
/// IMMEDIATELY increments nonce, invalidating all existing commit caps
/// This gives core team notice that DAO wants to reclaim control
public fun request_reclaim_commit_cap<Config: store>(
    auth: Auth,
    account: &mut Account,
    registry: &PackageRegistry,
    package_name: String,
    clock: &Clock,
) {
    account.verify(auth);

    let dao_account = account.addr();

    let rules_mut: &mut UpgradeRules = account.borrow_managed_data_mut(
        registry,
        UpgradeRulesKey(package_name),
        version::current()
    );

    // Can only request reclaim if not already pending
    assert!(option::is_none(&rules_mut.reclaim_request_time), EReclaimAlreadyPending);

    // Increment nonce - this IMMEDIATELY invalidates all existing commit caps
    rules_mut.commit_nonce = rules_mut.commit_nonce + 1;

    let current_time = clock.timestamp_ms();
    // Start the reclaim timer
    rules_mut.reclaim_request_time = option::some(current_time);

    sui::event::emit(ReclaimRequested {
        package_name,
        dao_account,
        request_time_ms: current_time,
        available_after_ms: current_time + rules_mut.reclaim_delay_ms,
        new_nonce: rules_mut.commit_nonce,
    });
}

/// Clears the reclaim request after timelock expires (optional cleanup)
/// After timelock expires, DAO can use do_commit_dao_only() without calling this
/// This just clears the reclaim_request_time for cleaner state
/// Can only be called after request_reclaim_commit_cap + reclaim_delay_ms
public fun clear_reclaim_request<Config: store>(
    auth: Auth,
    account: &mut Account,
    registry: &PackageRegistry,
    package_name: String,
    clock: &Clock,
) {
    account.verify(auth);

    let dao_account = account.addr();

    let rules_mut: &mut UpgradeRules = account.borrow_managed_data_mut(
        registry,
        UpgradeRulesKey(package_name),
        version::current()
    );

    // Validate reclaim request exists
    assert!(option::is_some(&rules_mut.reclaim_request_time), ENoReclaimRequest);

    let request_time = *option::borrow(&rules_mut.reclaim_request_time);
    let current_time = clock.timestamp_ms();

    // Validate timelock has passed
    assert!(
        current_time >= request_time + rules_mut.reclaim_delay_ms,
        EReclaimTooEarly
    );

    // Clear the reclaim request (nonce stays incremented, caps stay invalid)
    rules_mut.reclaim_request_time = option::none();

    sui::event::emit(ReclaimFinalized {
        package_name,
        dao_account,
        finalized_at_ms: current_time,
        final_nonce: rules_mut.commit_nonce,
    });

    // Note: DAO can now use do_commit_dao_only() since timelock has expired
}

/// Check if a reclaim request is pending
public fun has_reclaim_request(
    account: &Account,
    registry: &PackageRegistry,
    package_name: String,
): bool {
    let rules: &UpgradeRules = account.borrow_managed_data(
        registry,
        UpgradeRulesKey(package_name),
        version::current()
    );
    option::is_some(&rules.reclaim_request_time)
}

/// Get the timestamp when reclaim will be available (if request exists)
public fun get_reclaim_available_time(
    account: &Account,
    registry: &PackageRegistry,
    package_name: String,
): Option<u64> {
    let rules: &UpgradeRules = account.borrow_managed_data(
        registry,
        UpgradeRulesKey(package_name),
        version::current()
    );

    if (option::is_none(&rules.reclaim_request_time)) {
        return option::none()
    };

    let request_time = *option::borrow(&rules.reclaim_request_time);
    option::some(request_time + rules.reclaim_delay_ms)
}

// === NEW: Digest-Based Upgrade System (Fixes Hot Potato Issue) ===

/// Phase 1: Propose an upgrade digest for governance voting
/// This creates a proposal that can be voted on over time (multi-day)
/// The digest is just data (has `store`), not a hot potato
public fun propose_upgrade_digest(
    auth: Auth,
    account: &mut Account,
    registry: &PackageRegistry,
    package_name: String,
    digest: vector<u8>,
    execution_time_ms: u64,
    clock: &Clock,
) {
    account.verify(auth);

    // Validate package exists
    assert!(has_cap(account, package_name), EPackageDoesntExist);

    // Validate timelock
    let rules: &UpgradeRules = account.borrow_managed_data(
        registry,
        UpgradeRulesKey(package_name),
        version::current()
    );
    let current_time = clock.timestamp_ms();
    assert!(
        execution_time_ms >= current_time + rules.delay_ms,
        EUpgradeTooEarly
    );

    // Create proposal
    let proposal = UpgradeProposal {
        package_name,
        digest,
        proposed_time_ms: current_time,
        execution_time_ms,
        approved: false,
    };

    // Store proposal for voting
    account.add_managed_data(
        registry,
        proposal_key(package_name, digest),
        proposal,
        version::current()
    );

    // Emit event
    sui::event::emit(UpgradeDigestProposed {
        package_name,
        digest,
        proposed_at_ms: current_time,
        execution_time_ms,
    });
}

/// Called by governance system when vote passes
/// Marks the digest as approved for execution
public fun approve_upgrade_proposal<Config: store>(
    auth: Auth,
    account: &mut Account,
    registry: &PackageRegistry,
    package_name: String,
    digest: vector<u8>,
    clock: &Clock,
) {
    account.verify(auth);

    let proposal: &mut UpgradeProposal = account.borrow_managed_data_mut(
        registry,
        proposal_key(package_name, digest),
        version::current()
    );

    proposal.approved = true;

    // Emit event
    sui::event::emit(UpgradeDigestApproved {
        package_name,
        digest,
        approved_at_ms: clock.timestamp_ms(),
    });
}

/// Phase 2a: Execute approved upgrade atomically (DAO-only mode)
/// This creates the UpgradeTicket (hot potato) which MUST be consumed in same PTB
/// Returns ticket that caller must immediately consume via sui upgrade command
public fun execute_approved_upgrade_dao_only<Config: store>(
    account: &mut Account,
    registry: &PackageRegistry,
    package_name: String,
    digest: vector<u8>,
    clock: &Clock,
    version_witness: VersionWitness,
): UpgradeTicket {
    // 1. Validate proposal exists and is approved
    let proposal: &UpgradeProposal = account.borrow_managed_data(
        registry,
        proposal_key(package_name, digest),
        version_witness
    );
    assert!(proposal.approved, EProposalNotApproved);

    // 2. Validate execution time
    let current_time = clock.timestamp_ms();
    assert!(current_time >= proposal.execution_time_ms, EUpgradeTooEarly);

    // 3. Check reclaim logic (if applicable)
    let rules: &UpgradeRules = account.borrow_managed_data(
        registry,
        UpgradeRulesKey(package_name),
        version_witness
    );
    if (option::is_some(&rules.reclaim_request_time)) {
        let request_time = *option::borrow(&rules.reclaim_request_time);
        assert!(
            current_time >= request_time + rules.reclaim_delay_ms,
            EReclaimNotExpired
        );
    };

    // 4. Create upgrade ticket (HOT POTATO STARTS HERE!)
    let cap: &mut UpgradeCap = account.borrow_managed_asset_mut(
        registry,
        UpgradeCapKey(package_name),
        version_witness
    );
    let policy = cap.policy();
    let ticket = cap.authorize_upgrade(policy, digest);

    // Emit event
    sui::event::emit(UpgradeTicketCreated {
        package_name,
        digest,
        mode: b"dao_only".to_string(),
    });

    // Return ticket - caller MUST consume in same PTB!
    ticket
}

/// Phase 2b: Complete the upgrade by consuming the receipt (DAO-only mode)
/// This MUST be called in same PTB after sui upgrade command
public fun complete_approved_upgrade_dao_only<Config: store>(
    account: &mut Account,
    registry: &PackageRegistry,
    package_name: String,
    digest: vector<u8>,
    receipt: UpgradeReceipt,
    version_witness: VersionWitness,
) {
    // Validate this matches an approved upgrade
    let proposal: &UpgradeProposal = account.borrow_managed_data(
        registry,
        proposal_key(package_name, digest),
        version_witness
    );
    assert!(proposal.approved, EProposalNotApproved);

    // Validate digest matches receipt
    assert!(receipt.package() == get_cap_package(account, registry, package_name).to_id(), EDigestMismatch);

    // Commit the upgrade
    let cap: &mut UpgradeCap = account.borrow_managed_asset_mut(
        registry,
        UpgradeCapKey(package_name),
        version_witness
    );
    cap.commit_upgrade(receipt);

    // Update package index
    let new_addr = cap.package().to_address();
    let index: &mut UpgradeIndex = account.borrow_managed_data_mut(
        registry,
        UpgradeIndexKey(),
        version_witness
    );
    *index.packages_info.get_mut(&package_name) = new_addr;

    // Clean up proposal
    let _removed_proposal: UpgradeProposal = account.remove_managed_data(
        registry,
        proposal_key(package_name, digest),
        version_witness
    );

    // Emit event
    sui::event::emit(UpgradeCompleted {
        package_name,
        digest,
        new_package_addr: new_addr,
        mode: b"dao_only".to_string(),
    });
}

/// Test-only version that skips package validation
/// This is needed because package::test_upgrade() creates receipts with mismatched package IDs
#[test_only]
public fun complete_approved_upgrade_dao_only_for_testing<Config: store>(
    account: &mut Account,
    registry: &PackageRegistry,
    package_name: String,
    digest: vector<u8>,
    receipt: UpgradeReceipt,
    version_witness: VersionWitness,
) {
    // Validate this matches an approved upgrade
    let proposal: &UpgradeProposal = account.borrow_managed_data(
        registry,
        proposal_key(package_name, digest),
        version_witness
    );
    assert!(proposal.approved, EProposalNotApproved);

    // Skip package validation for tests since package::test_upgrade creates mismatched receipts

    // Commit the upgrade
    let cap: &mut UpgradeCap = account.borrow_managed_asset_mut(
        registry,
        UpgradeCapKey(package_name),
        version_witness
    );
    cap.commit_upgrade(receipt);

    // Update package index
    let new_addr = cap.package().to_address();
    let index: &mut UpgradeIndex = account.borrow_managed_data_mut(
        registry,
        UpgradeIndexKey(),
        version_witness
    );
    *index.packages_info.get_mut(&package_name) = new_addr;

    // Clean up proposal
    let _removed_proposal: UpgradeProposal = account.remove_managed_data(
        registry,
        proposal_key(package_name, digest),
        version_witness
    );

    // Emit event
    sui::event::emit(UpgradeCompleted {
        package_name,
        digest,
        new_package_addr: new_addr,
        mode: b"dao_only".to_string(),
    });
}

/// Phase 2a: Execute approved upgrade atomically (with commit cap)
/// This requires the commit cap to be provided, validating nonce
public fun execute_approved_upgrade_with_cap<Config: store>(
    account: &mut Account,
    registry: &PackageRegistry,
    package_name: String,
    digest: vector<u8>,
    commit_cap: &UpgradeCommitCap,
    clock: &Clock,
    version_witness: VersionWitness,
): UpgradeTicket {
    // 1. Validate proposal exists and is approved
    let proposal: &UpgradeProposal = account.borrow_managed_data(
        registry,
        proposal_key(package_name, digest),
        version_witness
    );
    assert!(proposal.approved, EProposalNotApproved);

    // 2. Validate execution time
    assert!(clock.timestamp_ms() >= proposal.execution_time_ms, EUpgradeTooEarly);

    // 3. Validate commit cap
    assert!(commit_cap.package_name == package_name, ECommitCapMismatch);
    let rules: &UpgradeRules = account.borrow_managed_data(
        registry,
        UpgradeRulesKey(package_name),
        version_witness
    );
    assert!(commit_cap.valid_nonce == rules.commit_nonce, ECapRevoked);

    // 4. Create upgrade ticket
    let cap: &mut UpgradeCap = account.borrow_managed_asset_mut(
        registry,
        UpgradeCapKey(package_name),
        version_witness
    );
    let policy = cap.policy();
    let ticket = cap.authorize_upgrade(policy, digest);

    // Emit event
    sui::event::emit(UpgradeTicketCreated {
        package_name,
        digest,
        mode: b"with_cap".to_string(),
    });

    ticket
}

/// Phase 2b: Complete the upgrade by consuming the receipt (with commit cap)
public fun complete_approved_upgrade_with_cap<Config: store>(
    account: &mut Account,
    registry: &PackageRegistry,
    package_name: String,
    digest: vector<u8>,
    receipt: UpgradeReceipt,
    commit_cap: &UpgradeCommitCap,
    version_witness: VersionWitness,
) {
    // Validate proposal
    let proposal: &UpgradeProposal = account.borrow_managed_data(
        registry,
        proposal_key(package_name, digest),
        version_witness
    );
    assert!(proposal.approved, EProposalNotApproved);

    // Validate commit cap again (defense in depth)
    assert!(commit_cap.package_name == package_name, ECommitCapMismatch);
    let rules: &UpgradeRules = account.borrow_managed_data(
        registry,
        UpgradeRulesKey(package_name),
        version_witness
    );
    assert!(commit_cap.valid_nonce == rules.commit_nonce, ECapRevoked);

    // Commit upgrade
    let cap: &mut UpgradeCap = account.borrow_managed_asset_mut(
        registry,
        UpgradeCapKey(package_name),
        version_witness
    );
    cap.commit_upgrade(receipt);

    // Update package index
    let new_addr = cap.package().to_address();
    let index: &mut UpgradeIndex = account.borrow_managed_data_mut(
        registry,
        UpgradeIndexKey(),
        version_witness
    );
    *index.packages_info.get_mut(&package_name) = new_addr;

    // Clean up proposal
    let _removed_proposal: UpgradeProposal = account.remove_managed_data(
        registry,
        proposal_key(package_name, digest),
        version_witness
    );

    // Emit event
    sui::event::emit(UpgradeCompleted {
        package_name,
        digest,
        new_package_addr: new_addr,
        mode: b"with_cap".to_string(),
    });
}

/// Check if a specific upgrade digest proposal exists
public fun has_upgrade_proposal(
    account: &Account,
    package_name: String,
    digest: vector<u8>,
): bool {
    account.has_managed_data(proposal_key(package_name, digest))
}

/// Check if a specific upgrade digest is approved
public fun is_upgrade_approved(
    account: &Account,
    registry: &PackageRegistry,
    package_name: String,
    digest: vector<u8>,
): bool {
    if (!has_upgrade_proposal(account, package_name, digest)) {
        return false
    };

    let proposal: &UpgradeProposal = account.borrow_managed_data(
        registry,
        proposal_key(package_name, digest),
        version::current()
    );
    proposal.approved
}

/// Get upgrade proposal details
public fun get_upgrade_proposal(
    account: &Account,
    registry: &PackageRegistry,
    package_name: String,
    digest: vector<u8>,
): (vector<u8>, u64, u64, bool) {
    let proposal: &UpgradeProposal = account.borrow_managed_data(
        registry,
        proposal_key(package_name, digest),
        version::current()
    );
    (proposal.digest, proposal.proposed_time_ms, proposal.execution_time_ms, proposal.approved)
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Common utilities for time-based streaming/vesting functionality.
/// Shared between vault streams and vesting modules to avoid duplication.
/// Provides reusable math helpers for vesting and stream modules.
/// - Vested/unvested split calculations for cancellations
///
/// This enables both vault streams and standalone vestings to have:
/// - Consistent mathematical accuracy
/// - Shared security validations
/// - Unified approach to time-based fund releases

module account_actions::stream_utils;

use std::u128;

// === Imports ===

// === Constants ===
//
// UPGRADABLE CONSTANT PATTERN:
// These constants are defined here in the framework for backwards compatibility,
// but the canonical source is futarchy_one_shot_utils::constants.
//
// To upgrade these values:
// 1. Update futarchy_one_shot_utils::constants::max_beneficiaries()
// 2. Deploy new version of futarchy_one_shot_utils
// 3. All dependent packages inherit new limits on next deployment
//
// This pattern allows system-wide configuration updates without modifying
// the framework package, enabling DAOs to adjust limits via governance.

public fun max_beneficiaries(): u64 { 100 }

// === Iteration-Based Vesting Functions ===

/// Checks if withdrawal amount respects maximum limit
public fun check_withdrawal_limit(amount: u64, max_per_withdrawal: u64): bool {
    if (max_per_withdrawal == 0) {
        true
    } else {
        amount <= max_per_withdrawal
    }
}

/// Calculates vested amount based on discrete iterations with optional forfeit window
/// Used for iteration-based streams where tokens unlock at specific intervals
/// NOTE: Uses amount_per_iteration directly (NO DIVISION) to avoid precision loss
public fun calculate_iteration_vested(
    amount_per_iteration: u64,
    start_time: u64,
    iterations_total: u64,
    iteration_period_ms: u64,
    current_time: u64,
    cliff_time_opt: &Option<u64>,
    claim_window_ms_opt: &Option<u64>,
): u64 {
    // Check cliff first
    if (cliff_time_opt.is_some()) {
        let cliff = *cliff_time_opt.borrow();
        if (current_time < cliff) {
            return 0  // Nothing vested before cliff
        };
    };

    // Before start time, nothing vested
    if (current_time < start_time) {
        return 0
    };

    // Calculate elapsed time
    let elapsed = current_time - start_time;

    // Calculate current iteration (how many unlocks have occurred)
    let current_iteration = elapsed / iteration_period_ms;

    // Cap at total iterations
    let completed_iterations = if (current_iteration > iterations_total) {
        iterations_total
    } else {
        current_iteration
    };

    if (completed_iterations == 0) {
        return 0
    };

    // If claim window enabled, calculate forfeited iterations
    if (claim_window_ms_opt.is_some()) {
        let claim_window_ms = *claim_window_ms_opt.borrow();

        // How many iteration periods fit in the claim window?
        let window_in_iterations = claim_window_ms / iteration_period_ms;

        // Oldest claimable iteration
        let oldest_claimable = if (completed_iterations > window_in_iterations) {
            completed_iterations - window_in_iterations
        } else {
            0  // All iterations still within window
        };

        // Only iterations from oldest_claimable to completed_iterations are vested (not forfeited)
        let claimable_iterations = completed_iterations - oldest_claimable;

        // Use u128 to prevent overflow during multiplication
        let vested_u128 = (claimable_iterations as u128) * (amount_per_iteration as u128);
        assert!(vested_u128 <= (18446744073709551615 as u128), 0); // u64::MAX check
        (vested_u128 as u64)
    } else {
        // No forfeit - all completed iterations are vested
        // Use u128 to prevent overflow during multiplication
        let vested_u128 = (completed_iterations as u128) * (amount_per_iteration as u128);
        assert!(vested_u128 <= (18446744073709551615 as u128), 0); // u64::MAX check
        (vested_u128 as u64)
    }
}

/// Calculate claimable amount for iteration-based streams
public fun calculate_claimable_iterations(
    amount_per_iteration: u64,
    claimed_amount: u64,
    start_time: u64,
    iterations_total: u64,
    iteration_period_ms: u64,
    current_time: u64,
    cliff_time_opt: &Option<u64>,
    claim_window_ms_opt: &Option<u64>,
): u64 {
    let vested = calculate_iteration_vested(
        amount_per_iteration,
        start_time,
        iterations_total,
        iteration_period_ms,
        current_time,
        cliff_time_opt,
        claim_window_ms_opt,
    );

    if (vested > claimed_amount) {
        vested - claimed_amount
    } else {
        0
    }
}

/// Splits vested and unvested amounts for cancellation (iteration-based)
public fun split_vested_unvested_iterations(
    amount_per_iteration: u64,
    claimed_amount: u64,
    balance_remaining: u64,
    start_time: u64,
    iterations_total: u64,
    iteration_period_ms: u64,
    current_time: u64,
    cliff_time_opt: &Option<u64>,
    claim_window_ms_opt: &Option<u64>,
): (u64, u64, u64) {
    let vested = calculate_iteration_vested(
        amount_per_iteration,
        start_time,
        iterations_total,
        iteration_period_ms,
        current_time,
        cliff_time_opt,
        claim_window_ms_opt,
    );

    // Calculate amounts
    let unvested_claimed = if (claimed_amount > vested) {
        claimed_amount - vested
    } else {
        0
    };

    let to_pay_beneficiary = if (vested > claimed_amount) {
        let owed = vested - claimed_amount;
        if (owed > balance_remaining) {
            balance_remaining
        } else {
            owed
        }
    } else {
        0
    };

    let to_refund = if (balance_remaining > to_pay_beneficiary) {
        balance_remaining - to_pay_beneficiary
    } else {
        0
    };

    (to_pay_beneficiary, to_refund, unvested_claimed)
}

/// Validate iteration-based stream parameters
public fun validate_iteration_parameters(
    start_time: u64,
    iterations_total: u64,
    iteration_period_ms: u64,
    cliff_time_opt: &Option<u64>,
    current_time: u64,
): bool {
    // Must have at least 1 iteration
    if (iterations_total == 0) return false;

    // Iteration period must be positive
    if (iteration_period_ms == 0) return false;

    // Start must be in future or present
    if (start_time < current_time) return false;

    // If cliff exists, must be at or after start
    if (cliff_time_opt.is_some()) {
        let cliff = *cliff_time_opt.borrow();
        if (cliff < start_time) return false;
    };

    true
}

// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Generic memo emission actions for Account Protocol
/// Works with any Account type
/// Provides text memos
///
/// Can be used for:
/// - Simple text memos: "This is important"
/// - Accept decisions: "Accept" + Some(proposal_id)
/// - Reject decisions: "Reject" + Some(proposal_id)
/// - Comments on objects: "Looks good!" + Some(object_id)

module account_actions::memo;

// === Imports ===

use std::{
    string::{Self, String},
    option::{Option},
};
use sui::{
    object::{Self, ID},
    clock::{Clock},
    tx_context::{Self, TxContext},
    event,
    bcs,
};
use account_protocol::{
    account::{Account},
    executable::{Self, Executable},
    intents::{Self, Expired, Intent},
    bcs_validation,
    action_validation,
};

// === Errors ===

const EEmptyMemo: u64 = 0;
const EMemoTooLong: u64 = 1;
const EUnsupportedActionVersion: u64 = 2;

// === Constants ===

const MAX_MEMO_LENGTH: u64 = 10000; // Maximum memo length in bytes

// === Action Type Markers ===

/// Emit a text memo
public struct Memo has drop {}

public fun memo(): Memo { Memo {} }

// === Structs ===

/// Action to emit a text memo
public struct EmitMemoAction has store, drop {
    /// The message to emit
    memo: String,
}

// === Events ===

public struct MemoEmitted has copy, drop {
    /// DAO that emitted the memo
    dao_id: ID,
    /// The memo content
    memo: String,
    /// When it was emitted
    timestamp: u64,
    /// Who triggered the emission
    emitter: address,
}

// === Destruction Functions ===

/// Destroy an EmitMemoAction after serialization
public fun destroy_emit_memo_action(action: EmitMemoAction) {
    let EmitMemoAction { memo: _ } = action;
}

// === Public Functions ===

/// Creates an EmitMemoAction and adds it to an intent

/// Execute an emit memo action
public fun do_emit_memo<Config: store, Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    _intent_witness: IW,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<Memo>(spec);

    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Create BCS reader and deserialize
    // BCS format: String (memo)
    let mut reader = bcs::new(*action_data);
    let memo_bytes = reader.peel_vec_u8();
    let memo = string::utf8(memo_bytes);

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    // Validate memo
    assert!(memo.length() > 0, EEmptyMemo);
    assert!(memo.length() <= MAX_MEMO_LENGTH, EMemoTooLong);

    // Emit the event
    event::emit(MemoEmitted {
        dao_id: object::id(account),
        memo,
        timestamp: clock.timestamp_ms(),
        emitter: tx_context::sender(ctx),
    });

    executable::increment_action_idx(executable);
}

/// Deletes a memo action from an expired intent
public fun delete_memo(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, automatically cleaned up
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Enhanced auditable upgrade proposal with source verification
module account_actions::package_upgrade_auditable;

use std::string::String;
use sui::clock::Clock;
use account_protocol::account::{Account, Auth};
use account_protocol::package_registry::PackageRegistry;
use account_actions::{version, package_upgrade};

// === Structs ===

/// Comprehensive audit metadata for upgrade proposals
public struct AuditMetadata has store, copy, drop {
    // Source code verification
    source_code_hash: vector<u8>,      // SHA256 of all source files
    move_toml_hash: vector<u8>,        // SHA256 of Move.toml

    // Build verification
    compiler_version: String,          // e.g., "sui-move 1.18.0"
    build_timestamp_ms: u64,           // When built
    dependencies_hash: vector<u8>,     // Hash of all dependency versions

    // Audit trail
    git_commit_hash: String,           // Git SHA of source
    github_release_tag: String,        // e.g., "v3.0.0"
    audit_report_url: String,          // Link to audit report

    // Verifier attestations (optional)
    verifier_signatures: vector<vector<u8>>, // Independent verifiers who checked
}

/// Enhanced proposal with full audit metadata
public struct AuditableUpgradeProposal has store {
    package_name: String,
    bytecode_digest: vector<u8>,       // What Sui runtime validates
    audit_metadata: AuditMetadata,     // All verification data
    proposed_time_ms: u64,
    execution_time_ms: u64,
    approved: bool,
}

/// Dynamic field key for auditable proposals
public struct AuditableProposalKey has copy, drop, store {
    package_name: String,
    digest_hash: address,
}

// === Events ===

/// Emitted when auditable proposal is created
public struct AuditableUpgradeProposed has copy, drop {
    package_name: String,
    bytecode_digest: vector<u8>,
    source_code_hash: vector<u8>,
    git_commit: String,
    audit_report_url: String,
    proposed_at_ms: u64,
}

/// Emitted when verifier adds attestation
public struct VerifierAttestationAdded has copy, drop {
    package_name: String,
    bytecode_digest: vector<u8>,
    verifier: address,
    signature: vector<u8>,
    timestamp_ms: u64,
}

// === Public Functions ===

/// Propose upgrade with full audit trail
public fun propose_auditable_upgrade<Config: store>(
    auth: Auth,
    account: &mut Account,
    registry: &PackageRegistry,
    package_name: String,
    bytecode_digest: vector<u8>,
    audit_metadata: AuditMetadata,
    execution_time_ms: u64,
    clock: &Clock,
) {
    // Delegate to standard upgrade system for UpgradeCap validation
    // (this will verify auth internally)
    package_upgrade::propose_upgrade_digest(
        auth,
        account,
        registry,
        package_name,
        bytecode_digest,
        execution_time_ms,
        clock,
    );

    // Store enhanced metadata separately
    let key = auditable_key(package_name, bytecode_digest);
    let proposal = AuditableUpgradeProposal {
        package_name,
        bytecode_digest,
        audit_metadata,
        proposed_time_ms: clock.timestamp_ms(),
        execution_time_ms,
        approved: false,
    };

    account.add_managed_data(registry, key, proposal, version::current());

    // Emit detailed event
    sui::event::emit(AuditableUpgradeProposed {
        package_name,
        bytecode_digest,
        source_code_hash: audit_metadata.source_code_hash,
        git_commit: audit_metadata.git_commit_hash,
        audit_report_url: audit_metadata.audit_report_url,
        proposed_at_ms: clock.timestamp_ms(),
    });
}

/// Add independent verifier attestation
public fun add_verifier_attestation<Config: store>(
    auth: Auth,
    account: &mut Account,
    registry: &PackageRegistry,
    package_name: String,
    bytecode_digest: vector<u8>,
    signature: vector<u8>,  // Verifier's signature over digest
    clock: &Clock,
) {
    use account_protocol::account as acc;
    let verifier = acc::auth_account_addr(&auth);
    account.verify(auth);

    let proposal: &mut AuditableUpgradeProposal = account.borrow_managed_data_mut(
        registry,
        auditable_key(package_name, bytecode_digest),
        version::current()
    );

    proposal.audit_metadata.verifier_signatures.push_back(signature);

    sui::event::emit(VerifierAttestationAdded {
        package_name,
        bytecode_digest,
        verifier,
        signature,
        timestamp_ms: clock.timestamp_ms(),
    });
}

/// Get full audit metadata for proposal
public fun get_audit_metadata<Config: store>(
    account: &Account,
    registry: &PackageRegistry,
    package_name: String,
    bytecode_digest: vector<u8>,
): AuditMetadata {
    let proposal: &AuditableUpgradeProposal = account.borrow_managed_data(
        registry,
        auditable_key(package_name, bytecode_digest),
        version::current()
    );
    proposal.audit_metadata
}

/// Helper to create key
fun auditable_key(package_name: String, digest: vector<u8>): AuditableProposalKey {
    use sui::hash;
    let digest_hash = object::id_from_bytes(hash::blake2b256(&digest)).to_address();
    AuditableProposalKey { package_name, digest_hash }
}

/// Create audit metadata (helper for testing/scripts)
public fun new_audit_metadata(
    source_code_hash: vector<u8>,
    move_toml_hash: vector<u8>,
    compiler_version: String,
    build_timestamp_ms: u64,
    dependencies_hash: vector<u8>,
    git_commit_hash: String,
    github_release_tag: String,
    audit_report_url: String,
): AuditMetadata {
    AuditMetadata {
        source_code_hash,
        move_toml_hash,
        compiler_version,
        build_timestamp_ms,
        dependencies_hash,
        git_commit_hash,
        github_release_tag,
        audit_report_url,
        verifier_signatures: vector::empty(),
    }
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

// Portions of this file are derived from the account.tech Move Framework project.
// Those portions remain licensed under the Apache License, Version 2.0.

module account_actions::vault;

// === Imports ===

use std::{
    string::String,
    type_name::{Self, TypeName},
    option::Option,
    u128,
    u64,
};
use sui::{
    bag::{Self, Bag},
    balance::Balance,
    coin::{Self, Coin},
    table::{Self, Table},
    clock::Clock,
    event,
    object::{Self, ID},
    transfer,
    tx_context,
    vec_map::{Self, VecMap},
    vec_set::{Self, VecSet},
    bcs,
};
use account_protocol::{
    account::{Self, Account, Auth},
    intents::{Self, Expired, Intent},
    executable::{Self, Executable},
    version_witness::VersionWitness,
    bcs_validation,
    action_validation,
    package_registry::{Self, PackageRegistry},
};
use account_actions::{version, stream_utils};

// === Use Fun Aliases ===

// === Errors ===

const EVaultNotEmpty: u64 = 0;
const EStreamNotFound: u64 = 1;
const EStreamNotStarted: u64 = 2;
const EStreamCliffNotReached: u64 = 3;
const EUnauthorizedBeneficiary: u64 = 4;
const EWrongCoinType: u64 = 5;
const EWithdrawalLimitExceeded: u64 = 6;
const EWithdrawalTooSoon: u64 = 7;
const EInsufficientVestedAmount: u64 = 8;
const EInvalidStreamParameters: u64 = 9;
const EIntentAmountMismatch: u64 = 10;
// Additional error codes
const EAmountMustBeGreaterThanZero: u64 = 20;
const EVaultDoesNotExist: u64 = 21;
const ECoinTypeDoesNotExist: u64 = 22;
const EInsufficientBalance: u64 = 23;
const ENotTransferable: u64 = 13;
const ENotCancellable: u64 = 14;
const EBeneficiaryAlreadyExists: u64 = 15;
const EBeneficiaryNotFound: u64 = 16;
const EUnsupportedActionVersion: u64 = 17;
const ECannotReduceBelowClaimed: u64 = 18;
const ETooManyBeneficiaries: u64 = 19;
const EStreamExpired: u64 = 28;

// === Action Type Markers ===

/// Deposit coins into vault
public struct VaultDeposit has drop {}

/// Spend coins from vault
public struct VaultSpend has drop {}

/// Approve coin type for permissionless deposits
public struct VaultApproveCoinType has drop {}

/// Remove coin type approval
public struct VaultRemoveApprovedCoinType has drop {}

/// Cancel stream
public struct CancelStream has drop {}

/// Create stream (marker type for action validation)
public struct CreateStream has drop {}

// === Structs ===

/// Dynamic Field key for the Vault.
public struct VaultKey(String) has copy, drop, store;
/// Dynamic field holding a budget with different coin types, key is name
public struct Vault has store {
    // heterogeneous array of Balances, TypeName -> Balance<CoinType>
    bag: Bag,
    // streams for time-based vesting withdrawals
    streams: Table<ID, VaultStream>,
    // approved coin types for permissionless deposits (enables revenue/donations)
    approved_types: VecSet<TypeName>,
}

/// Stream for iteration-based vesting from vault
/// Features:
/// - Iteration-based vesting (discrete unlock events)
/// - Optional "use or lose" claim window per iteration
/// - Multiple beneficiaries support (unlimited)
/// - Metadata for extensibility
/// - Transfer and reduction capabilities
public struct VaultStream has store, drop {
    id: ID,
    coin_type: TypeName,
    beneficiary: address,  // Primary beneficiary
    // Core vesting parameters (iteration-based)
    amount_per_iteration: u64,   // Tokens that unlock per iteration (NO DIVISION!)
    claimed_amount: u64,          // Total claimed so far
    start_time: u64,
    iterations_total: u64,        // Number of unlock events
    iteration_period_ms: u64,     // Time between unlocks (ms)
    cliff_time: Option<u64>,
    // Use-or-lose feature
    claim_window_ms: Option<u64>, // If Some(X), must claim within X ms after unlock or forfeit
    // Rate limiting (per claim)
    max_per_withdrawal: u64,
    // Multiple beneficiaries support (unlimited)
    additional_beneficiaries: vector<address>,
    // Metadata for extensibility
    metadata: Option<String>,
    // Transfer settings
    is_transferable: bool,
    is_cancellable: bool,
}

// Event structures for stream operations

/// Emitted when a stream is created
public struct StreamCreated has copy, drop {
    stream_id: ID,
    beneficiary: address,
    total_amount: u64,
    coin_type: TypeName,
    start_time: u64,
    iterations_total: u64,
    iteration_period_ms: u64,
}

/// Emitted when funds are withdrawn from a stream
public struct StreamWithdrawal has copy, drop {
    stream_id: ID,
    beneficiary: address,
    amount: u64,
    remaining_vested: u64,
}

/// Emitted when a stream is cancelled
public struct StreamCancelled has copy, drop {
    stream_id: ID,
    refunded_amount: u64,
    final_payment: u64,
}

/// Emitted when a beneficiary is added
public struct BeneficiaryAdded has copy, drop {
    stream_id: ID,
    new_beneficiary: address,
}

/// Emitted when a beneficiary is removed
public struct BeneficiaryRemoved has copy, drop {
    stream_id: ID,
    removed_beneficiary: address,
}

/// Emitted when a stream is transferred
public struct StreamTransferred has copy, drop {
    stream_id: ID,
    old_beneficiary: address,
    new_beneficiary: address,
}

/// Emitted when stream metadata is updated
public struct StreamMetadataUpdated has copy, drop {
    stream_id: ID,
}

/// Emitted when stream amount is reduced
public struct StreamAmountReduced has copy, drop {
    stream_id: ID,
    old_amount: u64,
    new_amount: u64,
}

/// Action to deposit an amount of this coin to the targeted Vault.
public struct DepositAction<phantom CoinType> has store, drop {
    // vault name
    name: String,
    // exact amount to be deposited
    amount: u64,
}
/// Action to be used within intent making good use of the returned coin, similar to owned::withdraw.
public struct SpendAction<phantom CoinType> has store, drop {
    // vault name
    name: String,
    // amount to withdraw (ignored if spend_all is true)
    amount: u64,
    // if true, withdraw entire balance and ignore amount field
    spend_all: bool,
}

/// Action to approve a coin type for permissionless deposits
public struct ApproveCoinTypeAction<phantom CoinType> has store, drop {
    // vault name
    name: String,
}

/// Action to remove approval for a coin type
public struct RemoveApprovedCoinTypeAction<phantom CoinType> has store, drop {
    // vault name
    name: String,
}

/// Action for canceling a stream
public struct CancelStreamAction has store {
    vault_name: String,
    stream_id: ID,
}

// === Public Functions ===

/// Authorized address can open a vault.
public fun open<Config: store>(
    auth: Auth,
    account: &mut Account,
    registry: &PackageRegistry,
    name: String,
    ctx: &mut TxContext
) {
    account.verify(auth);

    account.add_managed_data(registry, VaultKey(name), Vault {
        bag: bag::new(ctx),
        streams: table::new(ctx),
        approved_types: vec_set::empty(),
    }, version::current());
}

/// Deposits coins owned by a an authorized address into a vault.
public fun deposit<Config: store, CoinType: drop>(
    auth: Auth,
    account: &mut Account,
    registry: &PackageRegistry,
    name: String,
    coin: Coin<CoinType>,
) {
    account.verify(auth);

    let vault: &mut Vault =
        account.borrow_managed_data_mut(registry, VaultKey(name), version::current());

    if (vault.coin_type_exists<CoinType>()) {
        let balance_mut = vault.bag.borrow_mut<_, Balance<_>>(type_name::with_defining_ids<CoinType>());
        balance_mut.join(coin.into_balance());
    } else {
        vault.bag.add(type_name::with_defining_ids<CoinType>(), coin.into_balance());
    };
}

/// Permissionless deposit for approved coin types
/// Anyone can deposit coins of types that have been approved by governance
/// This enables revenue/donations for common tokens (SUI, USDC, etc.)
/// Safe because:
/// 1. Only approved types can be deposited
/// 2. Deposits increase DAO assets, never decrease
/// 3. Creates balance entry on first deposit if needed
public fun deposit_approved<Config: store, CoinType>(
    account: &mut Account,
    registry: &PackageRegistry,
    name: String,
    coin: Coin<CoinType>,
) {
    let vault: &mut Vault =
        account.borrow_managed_data_mut(registry, VaultKey(name), version::current());

    // Only allow deposits of approved coin types
    let type_key = type_name::with_defining_ids<CoinType>();
    assert!(vault.approved_types.contains(&type_key), EWrongCoinType);

    // Add to existing balance or create new one
    if (vault.coin_type_exists<CoinType>()) {
        let balance_mut = vault.bag.borrow_mut<_, Balance<_>>(type_key);
        balance_mut.join(coin.into_balance());
    } else {
        vault.bag.add(type_key, coin.into_balance());
    }
}

/// Permissionless withdrawal (no Auth required)
/// Used by authorized operations like dissolution and NAV market making
/// Safety checks are performed by the calling module before calling this
///
/// This is a privileged function - only use from modules that enforce their own safety checks
/// Current authorized callers:
/// - futarchy_actions::dissolution (proportional redemption)
/// - futarchy_actions::nav_market_making (buyback/sell operations)
/// - futarchy_governance::proposal_lifecycle (outcome winner rewards)
public fun withdraw_permissionless<Config: store, CoinType>(
    account: &mut Account,
    registry: &PackageRegistry,
    dao_address: address,
    vault_name: String,
    amount: u64,
    ctx: &mut TxContext,
): Coin<CoinType> {
    // Verify caller provided correct DAO address
    assert!(dao_address == account.addr(), EWrongCoinType); // Reusing error, should add specific one

    // Standard vault withdrawal logic (no Auth check for dissolution)
    let vault: &mut Vault =
        account.borrow_managed_data_mut(registry, VaultKey(vault_name), version::current());

    let type_key = type_name::with_defining_ids<CoinType>();
    assert!(vault.coin_type_exists<CoinType>(), EWrongCoinType);

    let balance_mut = vault.bag.borrow_mut<_, Balance<_>>(type_key);
    assert!(balance_mut.value() >= amount, EInsufficientBalance);

    let coin = coin::take(balance_mut, amount, ctx);

    // Clean up empty balance
    if (balance_mut.value() == 0) {
        vault.bag.remove<_, Balance<CoinType>>(type_key).destroy_zero();
    };

    coin
}

/// Approve a coin type for permissionless deposits (requires Auth)
/// After approval, anyone can deposit this coin type to the vault
public fun approve_coin_type<Config: store, CoinType>(
    auth: Auth,
    account: &mut Account,
    registry: &PackageRegistry,
    name: String,
) {
    account.verify(auth);

    let vault: &mut Vault =
        account.borrow_managed_data_mut(registry, VaultKey(name), version::current());

    let type_key = type_name::with_defining_ids<CoinType>();
    if (!vault.approved_types.contains(&type_key)) {
        vault.approved_types.insert(type_key);
    }
}

/// Remove approval for a coin type (requires Auth)
/// Prevents future permissionless deposits of this type
/// Does not affect existing balances
public fun remove_approved_coin_type<Config: store, CoinType>(
    auth: Auth,
    account: &mut Account,
    registry: &PackageRegistry,
    name: String,
) {
    account.verify(auth);

    let vault: &mut Vault =
        account.borrow_managed_data_mut(registry, VaultKey(name), version::current());

    let type_key = type_name::with_defining_ids<CoinType>();
    if (vault.approved_types.contains(&type_key)) {
        vault.approved_types.remove(&type_key);
    }
}

/// Check if a coin type is approved for permissionless deposits
public fun is_coin_type_approved<Config: store, CoinType>(
    account: &Account,
    registry: &PackageRegistry,
    name: String,
): bool {
    if (!has_vault(account, name)) {
        return false
    };

    let vault: &Vault = account.borrow_managed_data(registry, VaultKey(name), version::current());
    let type_key = type_name::with_defining_ids<CoinType>();
    vault.approved_types.contains(&type_key)
}

/// Withdraws coins from a vault with authorization.
/// This is the Auth-based counterpart to `deposit`, used for direct withdrawals
/// outside of intent execution (e.g., for liquidity subsidy escrow funding).
public fun spend<Config: store, CoinType: drop>(
    auth: Auth,
    account: &mut Account,
    registry: &PackageRegistry,
    name: String,
    amount: u64,
    ctx: &mut TxContext,
): Coin<CoinType> {
    account.verify(auth);

    let vault: &mut Vault =
        account.borrow_managed_data_mut(registry, VaultKey(name), version::current());

    // Ensure coin type exists in vault
    assert!(vault.coin_type_exists<CoinType>(), EWrongCoinType);

    // Withdraw from balance
    let balance_mut = vault.bag.borrow_mut<_, Balance<_>>(type_name::with_defining_ids<CoinType>());
    assert!(balance_mut.value() >= amount, EInsufficientBalance);

    let coin = coin::take(balance_mut, amount, ctx);

    // Clean up empty balance if needed
    if (balance_mut.value() == 0) {
        vault.bag.remove<_, Balance<CoinType>>(type_name::with_defining_ids<CoinType>()).destroy_zero();
    };

    coin
}

/// Returns the balance of a specific coin type in a vault.
/// Convenience function that combines vault existence check with balance lookup.
public fun balance<Config: store, CoinType: drop>(
    account: &Account,
    registry: &PackageRegistry,
    name: String,
): u64 {
    if (!has_vault(account, name)) {
        return 0
    };

    let vault: &Vault = account.borrow_managed_data(registry, VaultKey(name), version::current());

    if (!coin_type_exists<CoinType>(vault)) {
        return 0
    };

    coin_type_value<CoinType>(vault)
}

/// Default vault name for standard operations
public fun default_vault_name(): String {
    std::string::utf8(b"Main Vault")
}

/// Deposit during initialization - works on unshared Accounts
/// This function is for use during account creation, before the account is shared.
/// It follows the same pattern as Futarchy init actions.
/// SAFETY: This function MUST only be called on unshared Accounts.
/// Calling this on a shared Account bypasses Auth checks.
/// The package(package) visibility helps enforce this constraint.
public(package) fun do_deposit_unshared< CoinType: drop>(
    account: &mut Account,
    registry: &PackageRegistry,
    name: String,
    coin: Coin<CoinType>,
    ctx: &mut tx_context::TxContext,
) {
    // SAFETY REQUIREMENT: Account must be unshared
    // Move doesn't allow runtime is_shared checks, so this is enforced by:
    // 1. package(package) visibility - only callable from this package
    // 2. Only exposed through init_actions module
    // 3. Documentation and naming convention (_unshared suffix)

    // Ensure vault exists
    if (!account.has_managed_data(VaultKey(name))) {
        let vault = Vault {
            bag: bag::new(ctx),
            streams: table::new(ctx),
            approved_types: vec_set::empty(),
        };
        account.add_managed_data(registry, VaultKey(name), vault, version::current());
    };

    let vault: &mut Vault =
        account.borrow_managed_data_mut(registry, VaultKey(name), version::current());

    // Add coin to vault
    let coin_type_name = type_name::with_defining_ids<CoinType>();
    if (vault.bag.contains(coin_type_name)) {
        let balance_mut = vault.bag.borrow_mut<TypeName, Balance<CoinType>>(coin_type_name);
        balance_mut.join(coin.into_balance());
    } else {
        vault.bag.add(coin_type_name, coin.into_balance());
    };
}

/// Spend from vault during initialization - works on unshared Accounts
/// Returns Coin for use in the same transaction
/// SAFETY: This function MUST only be called on unshared Accounts.
/// Calling this on a shared Account bypasses Auth checks.
public(package) fun do_spend_unshared<CoinType: drop>(
    account: &mut Account,
    registry: &PackageRegistry,
    vault_name: String,
    amount: u64,
    ctx: &mut TxContext,
): Coin<CoinType> {
    // SAFETY REQUIREMENT: Account must be unshared
    // Move doesn't allow runtime is_shared checks, so this is enforced by:
    // 1. package(package) visibility - only callable from this package
    // 2. Only exposed through init_actions module
    // 3. Documentation and naming convention (_unshared suffix)

    // Get vault
    let vault: &mut Vault =
        account.borrow_managed_data_mut(registry, VaultKey(vault_name), version::current());

    // Ensure coin type exists in vault
    let coin_type_name = type_name::with_defining_ids<CoinType>();
    assert!(vault.bag.contains(coin_type_name), ECoinTypeDoesNotExist);

    // Withdraw from balance
    let balance_mut = vault.bag.borrow_mut<TypeName, Balance<CoinType>>(coin_type_name);
    assert!(balance_mut.value() >= amount, EInsufficientBalance);

    let coin = coin::take(balance_mut, amount, ctx);

    // Clean up empty balance if needed
    if (balance_mut.value() == 0) {
        vault.bag.remove<TypeName, Balance<CoinType>>(coin_type_name).destroy_zero();
    };

    coin
}

/// Closes the vault if empty.
public fun close<Config: store>(
    auth: Auth,
    account: &mut Account,
    registry: &PackageRegistry,
    name: String,
) {
    account.verify(auth);

    let Vault { bag, streams, approved_types: _ } =
        account.remove_managed_data(registry, VaultKey(name), version::current());
    assert!(bag.is_empty(), EVaultNotEmpty);
    assert!(streams.is_empty(), EVaultNotEmpty);
    bag.destroy_empty();
    streams.destroy_empty();
}

/// Returns true if the vault exists.
public fun has_vault(
    account: &Account, 
    name: String
): bool {
    account.has_managed_data(VaultKey(name))
}

/// Returns a reference to the vault.
public fun borrow_vault(
    account: &Account,
    registry: &PackageRegistry,
    name: String
): &Vault {
    account.borrow_managed_data(registry, VaultKey(name), version::current())
}

/// Returns the number of coin types in the vault.
public fun size(vault: &Vault): u64 {
    vault.bag.length()
}

/// Returns true if the coin type exists in the vault.
public fun coin_type_exists<CoinType>(vault: &Vault): bool {
    vault.bag.contains(type_name::with_defining_ids<CoinType>())
}

/// Returns the value of the coin type in the vault.
public fun coin_type_value<CoinType>(vault: &Vault): u64 {
    vault.bag.borrow<TypeName, Balance<CoinType>>(type_name::with_defining_ids<CoinType>()).value()
}

// === Destruction Functions ===

/// Destroy a DepositAction after serialization
public fun destroy_deposit_action<CoinType>(action: DepositAction<CoinType>) {
    let DepositAction { name: _, amount: _ } = action;
}

/// Destroy a SpendAction after serialization
public fun destroy_spend_action<CoinType>(action: SpendAction<CoinType>) {
    let SpendAction { name: _, amount: _, spend_all: _ } = action;
}

/// Destroy an ApproveCoinTypeAction after serialization
public fun destroy_approve_coin_type_action<CoinType>(action: ApproveCoinTypeAction<CoinType>) {
    let ApproveCoinTypeAction { name: _ } = action;
}

/// Destroy a RemoveApprovedCoinTypeAction after serialization
public fun destroy_remove_approved_coin_type_action<CoinType>(action: RemoveApprovedCoinTypeAction<CoinType>) {
    let RemoveApprovedCoinTypeAction { name: _ } = action;
}

/// Destroy a CancelStreamAction after serialization
public fun destroy_cancel_stream_action(action: CancelStreamAction) {
    let CancelStreamAction { vault_name: _, stream_id: _ } = action;
}

// Intent functions

/// Creates a DepositAction and adds it to an intent with descriptor.

/// Processes a DepositAction and deposits a coin to the vault.
public fun do_deposit<Config: store, Outcome: store, CoinType: drop, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    coin: Coin<CoinType>,
    version_witness: VersionWitness,
    _intent_witness: IW,
) {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<VaultDeposit>(spec);

    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Deserialize the entire action struct directly
    let mut reader = bcs::new(*action_data);
    let name = std::string::utf8(bcs::peel_vec_u8(&mut reader));
    let amount = bcs::peel_u64(&mut reader);

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    assert!(amount == coin.value(), EIntentAmountMismatch);

    let vault: &mut Vault = account.borrow_managed_data_mut(registry, VaultKey(name), version_witness);
    if (!vault.coin_type_exists<CoinType>()) {
        vault.bag.add(type_name::with_defining_ids<CoinType>(), coin.into_balance());
    } else {
        let balance_mut = vault.bag.borrow_mut<_, Balance<_>>(type_name::with_defining_ids<CoinType>());
        balance_mut.join(coin.into_balance());
    };

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Deletes a DepositAction from an expired intent.
public fun delete_deposit<CoinType>(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, so it's automatically cleaned up
    // No need to deserialize the data
}





// === Execution Functions ===

/// Execute cancel stream action
public fun do_cancel_stream<Config: store, Outcome: store, CoinType: drop, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    vault_name: String,
    clock: &Clock,
    version_witness: VersionWitness,
    witness: IW,
    ctx: &mut TxContext,
): (Coin<CoinType>, u64) {
    executable.intent().assert_is_account(account.addr());

    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<CancelStream>(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    let action_data = intents::action_spec_data(spec);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let deserialized_vault_name = std::string::utf8(bcs::peel_vec_u8(&mut reader));
    let stream_id = bcs::peel_address(&mut reader).to_id();

    // Security: ensure all bytes are consumed to prevent trailing data attacks
    bcs_validation::validate_all_bytes_consumed(reader);

    // Validate vault name matches
    assert!(vault_name == deserialized_vault_name, EVaultDoesNotExist);

    // Get vault
    let vault: &mut Vault = account.borrow_managed_data_mut(registry, VaultKey(vault_name), version_witness);
    assert!(vault.streams.contains(stream_id), EStreamNotFound);

    let stream = table::remove(&mut vault.streams, stream_id);
    assert!(stream.is_cancellable, ENotCancellable);

    let current_time = clock.timestamp_ms();

    // Calculate total amount (with overflow protection)
    let total_amount_u128 = (stream.amount_per_iteration as u128) * (stream.iterations_total as u128);
    assert!(total_amount_u128 <= (18446744073709551615 as u128), 0);
    let total_amount = (total_amount_u128 as u64);

    let balance_remaining = total_amount - stream.claimed_amount;

    // Calculate what should be paid to beneficiary vs refunded (iteration-based)
    let (to_pay_beneficiary, to_refund, _unvested_claimed) =
        account_actions::stream_utils::split_vested_unvested_iterations(
            stream.amount_per_iteration,
            stream.claimed_amount,
            balance_remaining,
            stream.start_time,
            stream.iterations_total,
            stream.iteration_period_ms,
            current_time,
            &stream.cliff_time,
            &stream.claim_window_ms,
        );

    let balance_mut = vault.bag.borrow_mut<TypeName, Balance<CoinType>>(stream.coin_type);

    // Create coins for refund and final payment
    let mut refund_coin = coin::zero<CoinType>(ctx);
    if (to_refund > 0) {
        refund_coin.join(coin::take(balance_mut, to_refund, ctx));
    };

    // Transfer final payment to beneficiary if any
    if (to_pay_beneficiary > 0) {
        let final_payment = coin::take(balance_mut, to_pay_beneficiary, ctx);
        transfer::public_transfer(final_payment, stream.beneficiary);
    };

    // Emit event
    event::emit(StreamCancelled {
        stream_id,
        refunded_amount: to_refund,
        final_payment: to_pay_beneficiary,
    });

    // Clean up empty balance if needed
    if (balance_mut.value() == 0) {
        vault.bag.remove<TypeName, Balance<CoinType>>(stream.coin_type).destroy_zero();
    };

    // Increment action index
    executable::increment_action_idx(executable);

    (refund_coin, to_refund)
}

/// Processes a SpendAction and takes a coin from the vault.
/// If spend_all is true, withdraws entire balance regardless of amount field.
public fun do_spend<Config: store, Outcome: store, CoinType: drop, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version_witness: VersionWitness,
    _intent_witness: IW,
    ctx: &mut TxContext
): Coin<CoinType> {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<VaultSpend>(spec);

    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Deserialize the entire action struct directly
    let mut reader = bcs::new(*action_data);
    let name = std::string::utf8(bcs::peel_vec_u8(&mut reader));
    let amount = bcs::peel_u64(&mut reader);
    let spend_all = bcs::peel_bool(&mut reader);

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    let vault: &mut Vault = account.borrow_managed_data_mut(registry, VaultKey(name), version_witness);
    let balance_mut = vault.bag.borrow_mut<_, Balance<_>>(type_name::with_defining_ids<CoinType>());

    // Determine actual amount to withdraw
    let withdraw_amount = if (spend_all) {
        balance_mut.value()  // Spend entire balance
    } else {
        amount  // Spend specified amount
    };

    let coin = coin::take(balance_mut, withdraw_amount, ctx);

    if (balance_mut.value() == 0)
        vault.bag.remove<_, Balance<CoinType>>(type_name::with_defining_ids<CoinType>()).destroy_zero();

    // Store coin info in context for potential use by later actions
    // PTBs handle object flow naturally - no context storage needed

    // Increment action index
    executable::increment_action_idx(executable);
    coin
}

/// Deletes a SpendAction from an expired intent.
public fun delete_spend<CoinType>(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, so it's automatically cleaned up
    // No need to deserialize the data
}

/// Processes an ApproveCoinTypeAction and approves the coin type.
public fun do_approve_coin_type<Config: store, Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version_witness: VersionWitness,
    _intent_witness: IW,
) {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<VaultApproveCoinType>(spec);

    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Deserialize the entire action struct directly
    let mut reader = bcs::new(*action_data);
    let name = std::string::utf8(bcs::peel_vec_u8(&mut reader));

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    let vault: &mut Vault = account.borrow_managed_data_mut(registry, VaultKey(name), version_witness);

    let type_key = type_name::with_defining_ids<CoinType>();
    if (!vault.approved_types.contains(&type_key)) {
        vault.approved_types.insert(type_key);
    };

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Processes a RemoveApprovedCoinTypeAction and removes the coin type approval.
public fun do_remove_approved_coin_type<Config: store, Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version_witness: VersionWitness,
    _intent_witness: IW,
) {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<VaultRemoveApprovedCoinType>(spec);

    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Deserialize the entire action struct directly
    let mut reader = bcs::new(*action_data);
    let name = std::string::utf8(bcs::peel_vec_u8(&mut reader));

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    let vault: &mut Vault = account.borrow_managed_data_mut(registry, VaultKey(name), version_witness);

    let type_key = type_name::with_defining_ids<CoinType>();
    if (vault.approved_types.contains(&type_key)) {
        vault.approved_types.remove(&type_key);
    };

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Deletes an ApproveCoinTypeAction from an expired intent.
public fun delete_approve_coin_type<CoinType>(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, so it's automatically cleaned up
    // No need to deserialize the data
}

/// Deletes a RemoveApprovedCoinTypeAction from an expired intent.
public fun delete_remove_approved_coin_type<CoinType>(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, so it's automatically cleaned up
    // No need to deserialize the data
}

/// Deletes a CancelStreamAction from an expired intent.
public fun delete_cancel_stream(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, so it's automatically cleaned up
    // No need to deserialize the data
}

/// Deletes a ToggleStreamPauseAction from an expired intent.
public fun delete_toggle_stream_pause(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, so it's automatically cleaned up
    // No need to deserialize the data
}

/// Deletes a ToggleStreamFreezeAction from an expired intent.
public fun delete_toggle_stream_freeze(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, so it's automatically cleaned up
    // No need to deserialize the data
}

// === Stream Management Functions ===

/// Creates a new iteration-based stream in the vault
public fun create_stream<Config: store, CoinType: drop>(
    auth: Auth,
    account: &mut Account,
    registry: &PackageRegistry,
    vault_name: String,
    beneficiary: address,
    amount_per_iteration: u64,
    start_time: u64,
    iterations_total: u64,
    iteration_period_ms: u64,
    cliff_time: Option<u64>,
    claim_window_ms: Option<u64>,
    max_per_withdrawal: u64,
    is_transferable: bool,
    is_cancellable: bool,
    clock: &Clock,
    ctx: &mut TxContext,
): ID {
    account.verify(auth);

    // Validate stream parameters
    let current_time = clock.timestamp_ms();
    assert!(
        account_actions::stream_utils::validate_iteration_parameters(
            start_time,
            iterations_total,
            iteration_period_ms,
            &cliff_time,
            current_time
        ),
        EInvalidStreamParameters
    );
    assert!(amount_per_iteration > 0, EAmountMustBeGreaterThanZero);

    let vault: &mut Vault = account.borrow_managed_data_mut(registry, VaultKey(vault_name), version::current());

    // Calculate total amount needed for stream
    // Use u128 to prevent overflow
    let total_amount_u128 = (amount_per_iteration as u128) * (iterations_total as u128);
    assert!(total_amount_u128 <= (18446744073709551615 as u128), EInsufficientVestedAmount);
    let total_amount = (total_amount_u128 as u64);

    // Check that vault has sufficient balance
    assert!(vault.coin_type_exists<CoinType>(), EWrongCoinType);
    let balance = vault.bag.borrow<TypeName, Balance<CoinType>>(type_name::with_defining_ids<CoinType>());
    assert!(balance.value() >= total_amount, EInsufficientVestedAmount);

    // Create stream
    let stream_id = object::new(ctx);
    let stream = VaultStream {
        id: object::uid_to_inner(&stream_id),
        coin_type: type_name::with_defining_ids<CoinType>(),
        beneficiary,
        amount_per_iteration,
        claimed_amount: 0,
        start_time,
        iterations_total,
        iteration_period_ms,
        cliff_time,
        claim_window_ms,
        max_per_withdrawal,
        additional_beneficiaries: vector::empty(),
        metadata: option::none(),
        is_transferable,
        is_cancellable,
    };

    let id = object::uid_to_inner(&stream_id);
    object::delete(stream_id);

    // Store stream in vault
    table::add(&mut vault.streams, id, stream);

    // Emit event
    event::emit(StreamCreated {
        stream_id: id,
        beneficiary,
        total_amount: amount_per_iteration,  // Event uses amount_per_iteration for backward compat
        coin_type: type_name::with_defining_ids<CoinType>(),
        start_time,
        iterations_total,
        iteration_period_ms,
    });

    id
}

/// Cancel a stream and return unused funds
public fun cancel_stream<Config: store, CoinType: drop>(
    auth: Auth,
    account: &mut Account,
    registry: &PackageRegistry,
    vault_name: String,
    stream_id: ID,
    clock: &Clock,
    ctx: &mut TxContext,
): (Coin<CoinType>, u64) {
    account.verify(auth);

    let vault: &mut Vault = account.borrow_managed_data_mut(registry, VaultKey(vault_name), version::current());
    assert!(table::contains(&vault.streams, stream_id), EStreamNotFound);

    let stream = table::remove(&mut vault.streams, stream_id);
    assert!(stream.is_cancellable, ENotCancellable);

    let current_time = clock.timestamp_ms();

    // Calculate total amount (with overflow protection)
    let total_amount_u128 = (stream.amount_per_iteration as u128) * (stream.iterations_total as u128);
    assert!(total_amount_u128 <= (18446744073709551615 as u128), 0);
    let total_amount = (total_amount_u128 as u64);

    let balance_remaining = total_amount - stream.claimed_amount;

    // Calculate what should be paid to beneficiary vs refunded (iteration-based)
    let (to_pay_beneficiary, to_refund, _unvested_claimed) =
        account_actions::stream_utils::split_vested_unvested_iterations(
            stream.amount_per_iteration,
            stream.claimed_amount,
            balance_remaining,
            stream.start_time,
            stream.iterations_total,
            stream.iteration_period_ms,
            current_time,
            &stream.cliff_time,
            &stream.claim_window_ms,
        );

    let balance_mut = vault.bag.borrow_mut<TypeName, Balance<CoinType>>(stream.coin_type);

    // Create coins for refund and final payment
    let mut refund_coin = coin::zero<CoinType>(ctx);
    if (to_refund > 0) {
        refund_coin.join(coin::take(balance_mut, to_refund, ctx));
    };

    // Transfer final payment to beneficiary if any
    if (to_pay_beneficiary > 0) {
        let final_payment = coin::take(balance_mut, to_pay_beneficiary, ctx);
        transfer::public_transfer(final_payment, stream.beneficiary);
    };

    // Emit event
    event::emit(StreamCancelled {
        stream_id,
        refunded_amount: to_refund,
        final_payment: to_pay_beneficiary,
    });

    // Clean up empty balance if needed
    if (balance_mut.value() == 0) {
        vault.bag.remove<TypeName, Balance<CoinType>>(stream.coin_type).destroy_zero();
    };

    (refund_coin, to_refund)
}

/// Withdraw from a stream
public fun withdraw_from_stream<Config: store, CoinType: drop>(
    account: &mut Account,
    registry: &PackageRegistry,
    vault_name: String,
    stream_id: ID,
    amount: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<CoinType> {
    let vault: &mut Vault = account.borrow_managed_data_mut(registry, VaultKey(vault_name), version::current());
    assert!(table::contains(&vault.streams, stream_id), EStreamNotFound);

    let stream = table::borrow_mut(&mut vault.streams, stream_id);
    let current_time = clock.timestamp_ms();

    // CRITICAL: Check authorization - only beneficiaries can withdraw
    let sender = tx_context::sender(ctx);
    assert!(
        sender == stream.beneficiary || stream.additional_beneficiaries.contains(&sender),
        EUnauthorizedBeneficiary
    );

    // Check if stream has started
    assert!(current_time >= stream.start_time, EStreamNotStarted);

    // Check cliff period
    if (stream.cliff_time.is_some()) {
        assert!(current_time >= *stream.cliff_time.borrow(), EStreamCliffNotReached);
    };

    // Check withdrawal limits
    assert!(
        account_actions::stream_utils::check_withdrawal_limit(
            amount,
            stream.max_per_withdrawal
        ),
        EWithdrawalLimitExceeded
    );

    // Calculate available amount (iteration-based)
    let available = account_actions::stream_utils::calculate_claimable_iterations(
        stream.amount_per_iteration,
        stream.claimed_amount,
        stream.start_time,
        stream.iterations_total,
        stream.iteration_period_ms,
        current_time,
        &stream.cliff_time,
        &stream.claim_window_ms,
    );

    assert!(available >= amount, EInsufficientVestedAmount);

    // Update stream state
    stream.claimed_amount = stream.claimed_amount + amount;

    // Withdraw from vault balance
    let balance_mut = vault.bag.borrow_mut<TypeName, Balance<CoinType>>(stream.coin_type);
    let coin = coin::take(balance_mut, amount, ctx);

    // Emit event
    event::emit(StreamWithdrawal {
        stream_id,
        beneficiary: tx_context::sender(ctx),
        amount,
        remaining_vested: available - amount,
    });

    // Clean up empty balance if needed
    if (balance_mut.value() == 0) {
        vault.bag.remove<TypeName, Balance<CoinType>>(stream.coin_type).destroy_zero();
    };

    coin
}

/// Calculate how much can be claimed from a stream
public fun calculate_claimable<Config: store>(
    account: &Account,
    registry: &PackageRegistry,
    vault_name: String,
    stream_id: ID,
    clock: &Clock,
): u64 {
    let vault: &Vault = account.borrow_managed_data(registry, VaultKey(vault_name), version::current());
    assert!(table::contains(&vault.streams, stream_id), EStreamNotFound);

    let stream = table::borrow(&vault.streams, stream_id);
    let current_time = clock.timestamp_ms();

    account_actions::stream_utils::calculate_claimable_iterations(
        stream.amount_per_iteration,
        stream.claimed_amount,
        stream.start_time,
        stream.iterations_total,
        stream.iteration_period_ms,
        current_time,
        &stream.cliff_time,
        &stream.claim_window_ms,
    )
}

/// Get stream information
/// Returns: (beneficiary, total_amount, claimed_amount, start_time, iterations_total, iteration_period_ms, is_cancellable)
public fun stream_info<Config: store>(
    account: &Account,
    registry: &PackageRegistry,
    vault_name: String,
    stream_id: ID,
): (address, u64, u64, u64, u64, u64, bool) {
    let vault: &Vault = account.borrow_managed_data(registry, VaultKey(vault_name), version::current());
    assert!(table::contains(&vault.streams, stream_id), EStreamNotFound);

    let stream = table::borrow(&vault.streams, stream_id);
    (
        stream.beneficiary,
        stream.amount_per_iteration,
        stream.claimed_amount,
        stream.start_time,
        stream.iterations_total,
        stream.iteration_period_ms,
        stream.is_cancellable
    )
}

/// Check if a stream exists
public fun has_stream(
    account: &Account,
    registry: &PackageRegistry,
    vault_name: String,
    stream_id: ID,
): bool {
    if (!account.has_managed_data(VaultKey(vault_name))) {
        return false
    };

    let vault: &Vault = account.borrow_managed_data(registry, VaultKey(vault_name), version::current());
    table::contains(&vault.streams, stream_id)
}

/// Create a stream during initialization - works on unshared Accounts.
/// Directly creates a stream without requiring Auth during DAO creation.
/// SAFETY: This function MUST only be called on unshared Accounts
/// during the initialization phase before the Account is shared.
/// Once an Account is shared, this function will fail as it bypasses
/// the normal Auth checks that protect shared Accounts.
public(package) fun create_stream_unshared<Config: store, CoinType: drop>(
    account: &mut Account,
    registry: &PackageRegistry,
    vault_name: String,
    beneficiary: address,
    amount_per_iteration: u64,
    start_time: u64,
    iterations_total: u64,
    iteration_period_ms: u64,
    cliff_time: Option<u64>,
    claim_window_ms: Option<u64>,
    max_per_withdrawal: u64,
    is_transferable: bool,
    is_cancellable: bool,
    clock: &Clock,
    ctx: &mut TxContext,
): ID {
    // Validate stream parameters
    let current_time = clock.timestamp_ms();
    assert!(
        account_actions::stream_utils::validate_iteration_parameters(
            start_time,
            iterations_total,
            iteration_period_ms,
            &cliff_time,
            current_time
        ),
        EInvalidStreamParameters
    );
    assert!(amount_per_iteration > 0, EAmountMustBeGreaterThanZero);

    // Ensure vault exists and has sufficient balance
    let vault_exists = account.has_managed_data(VaultKey(vault_name));
    assert!(vault_exists, EVaultDoesNotExist);

    let vault: &mut Vault = account.borrow_managed_data_mut(registry, VaultKey(vault_name), version::current());
    let coin_type_name = type_name::with_defining_ids<CoinType>();
    assert!(bag::contains(&vault.bag, coin_type_name), ECoinTypeDoesNotExist);

    // Calculate total amount needed (with overflow protection)
    let total_amount_u128 = (amount_per_iteration as u128) * (iterations_total as u128);
    assert!(total_amount_u128 <= (18446744073709551615 as u128), EInsufficientBalance);
    let total_amount = (total_amount_u128 as u64);

    let balance = vault.bag.borrow<TypeName, Balance<CoinType>>(coin_type_name);
    assert!(balance.value() >= total_amount, EInsufficientBalance);

    // Create stream ID
    let stream_uid = object::new(ctx);
    let stream_id = object::uid_to_inner(&stream_uid);
    object::delete(stream_uid);

    // Create stream
    let stream = VaultStream {
        id: stream_id,
        coin_type: coin_type_name,
        beneficiary,
        amount_per_iteration,
        claimed_amount: 0,
        start_time,
        iterations_total,
        iteration_period_ms,
        cliff_time,
        claim_window_ms,
        max_per_withdrawal,
        is_transferable,
        is_cancellable,
        additional_beneficiaries: vector::empty<address>(),
        metadata: option::none(),
    };

    // Copy ID before moving stream
    let stream_id_copy = stream.id;

    // Add stream to vault
    table::add(&mut vault.streams, stream_id_copy, stream);

    // Emit event
    event::emit(StreamCreated {
        stream_id: stream_id_copy,
        beneficiary,
        total_amount: amount_per_iteration,  // Event uses amount_per_iteration
        coin_type: coin_type_name,
        start_time,
        iterations_total,
        iteration_period_ms,
    });

    stream_id_copy
}

/// Execute create_stream from Intent during launchpad initialization
/// Reads CreateStreamAction from Executable and creates stream
public fun do_init_create_stream<Config: store, Outcome: store, CoinType: drop, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    clock: &Clock,
    _version_witness: VersionWitness,
    _intent_witness: IW,
    ctx: &mut TxContext,
): ID {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect (using marker type)
    action_validation::assert_action_type<CreateStream>(spec);

    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Deserialize CreateStreamAction
    let mut reader = bcs::new(*action_data);
    let vault_name = std::string::utf8(bcs::peel_vec_u8(&mut reader));
    let beneficiary = bcs::peel_address(&mut reader);
    let amount_per_iteration = bcs::peel_u64(&mut reader);
    let start_time = bcs::peel_u64(&mut reader);
    let iterations_total = bcs::peel_u64(&mut reader);
    let iteration_period_ms = bcs::peel_u64(&mut reader);

    // Deserialize Option<u64> for cliff_time
    let cliff_time = if (bcs::peel_bool(&mut reader)) {
        option::some(bcs::peel_u64(&mut reader))
    } else {
        option::none()
    };

    // Deserialize Option<u64> for claim_window_ms
    let claim_window_ms = if (bcs::peel_bool(&mut reader)) {
        option::some(bcs::peel_u64(&mut reader))
    } else {
        option::none()
    };

    let max_per_withdrawal = bcs::peel_u64(&mut reader);
    let is_transferable = bcs::peel_bool(&mut reader);
    let is_cancellable = bcs::peel_bool(&mut reader);

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    // Call existing create_stream_unshared
    let stream_id = create_stream_unshared<Config, CoinType>(
        account,
        registry,
        vault_name,
        beneficiary,
        amount_per_iteration,
        start_time,
        iterations_total,
        iteration_period_ms,
        cliff_time,
        claim_window_ms,
        max_per_withdrawal,
        is_transferable,
        is_cancellable,
        clock,
        ctx,
    );

    // Increment action index
    executable::increment_action_idx(executable);

    stream_id
}

// === Preview Functions ===

/// Calculate currently claimable amount from a stream
public fun stream_claimable_now(
    vault: &Vault,
    stream_id: ID,
    clock: &Clock,
): u64 {
    let stream = table::borrow(&vault.streams, stream_id);
    let current_time = clock.timestamp_ms();

    // Check cliff
    if (stream.cliff_time.is_some()) {
        let cliff = *stream.cliff_time.borrow();
        if (current_time < cliff) {
            return 0
        };
    } else if (current_time < stream.start_time) {
        return 0
    };

    // Calculate claimable using iteration-based stream_utils
    stream_utils::calculate_claimable_iterations(
        stream.amount_per_iteration,
        stream.claimed_amount,
        stream.start_time,
        stream.iterations_total,
        stream.iteration_period_ms,
        current_time,
        &stream.cliff_time,
        &stream.claim_window_ms,
    )
}

/// Get next vesting time for an iteration-based stream
/// Returns the timestamp when the next iteration will unlock
public fun stream_next_vest_time(
    vault: &Vault,
    stream_id: ID,
    clock: &Clock,
): Option<u64> {
    let stream = table::borrow(&vault.streams, stream_id);
    let current_time = clock.timestamp_ms();

    // Check if before cliff
    if (stream.cliff_time.is_some()) {
        let cliff = *stream.cliff_time.borrow();
        if (current_time < cliff) {
            return option::some(cliff)
        };
    };

    // Check if before start
    if (current_time < stream.start_time) {
        return option::some(stream.start_time)
    };

    // Calculate current iteration
    let elapsed = current_time - stream.start_time;
    let current_iteration = elapsed / stream.iteration_period_ms;

    // If all iterations complete, no more vesting
    if (current_iteration >= stream.iterations_total) {
        return option::none()
    };

    // Next iteration time
    let next_iteration_time = stream.start_time + ((current_iteration + 1) * stream.iteration_period_ms);
    option::some(next_iteration_time)
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

// Portions of this file are derived from the account.tech Move Framework project.
// Those portions remain licensed under the Apache License, Version 2.0.

/// Authenticated users can lock a TreasuryCap in the Account to restrict minting and burning operations,
/// as well as modifying the CoinMetadata.

module account_actions::currency;

// === Imports ===

use std::{
    string::{Self, String},
    ascii,
    option,

};
use sui::{
    coin::{Self, Coin, TreasuryCap, CoinMetadata},
    url::{Self, Url},
    bcs,
    object,
};
use account_protocol::{
    action_validation,
    account::{Self, Account, Auth},
    intents::{Self, Expired, Intent},
    executable::{Self, Executable},
    version_witness::VersionWitness,
    bcs_validation,
    package_registry::PackageRegistry,
};
use account_actions::{
    currency,
    version,
};
// === Use Fun Aliases ===

// === Errors ===

const ENoChange: u64 = 0;
const EWrongValue: u64 = 1;
const EMintDisabled: u64 = 2;
const EBurnDisabled: u64 = 3;
const ECannotUpdateName: u64 = 4;
const ECannotUpdateSymbol: u64 = 5;
const ECannotUpdateDescription: u64 = 6;
const ECannotUpdateIcon: u64 = 7;
const EMaxSupply: u64 = 8;
const EUnsupportedActionVersion: u64 = 9;

// === Action Type Markers ===

/// Lock treasury cap
public struct CurrencyLockCap has drop {}
/// Disable currency operations
public struct CurrencyDisable has drop {}
/// Mint new currency
public struct CurrencyMint has drop {}
/// Burn currency
public struct CurrencyBurn has drop {}
/// Update currency metadata
public struct CurrencyUpdate has drop {}
/// Remove treasury cap (return to recipient)
public struct RemoveTreasuryCap has drop {}
/// Remove coin metadata (return to recipient)
public struct RemoveMetadata has drop {}

public fun currency_lock_cap(): CurrencyLockCap { CurrencyLockCap {} }
public fun currency_disable(): CurrencyDisable { CurrencyDisable {} }
public fun currency_mint(): CurrencyMint { CurrencyMint {} }
public fun currency_burn(): CurrencyBurn { CurrencyBurn {} }
public fun currency_update(): CurrencyUpdate { CurrencyUpdate {} }

/// Create a TreasuryCapKey witness (for PTB execution)
public fun treasury_cap_key<CoinType>(): TreasuryCapKey<CoinType> {
    TreasuryCapKey()
}

/// Create a CoinMetadataKey witness (for PTB execution)
public fun coin_metadata_key<CoinType>(): CoinMetadataKey<CoinType> {
    CoinMetadataKey()
}

// === Structs ===

/// Dynamic Object Field key for the TreasuryCap.
public struct TreasuryCapKey<phantom CoinType>() has copy, drop, store;
/// Dynamic Object Field key for the CoinMetadata.
public struct CoinMetadataKey<phantom CoinType>() has copy, drop, store;
/// Dynamic Field key for the CurrencyRules.
public struct CurrencyRulesKey<phantom CoinType>() has copy, drop, store;
/// Dynamic Field wrapper restricting access to a TreasuryCap, permissions are disabled forever if set.
public struct CurrencyRules<phantom CoinType> has store {
    // coin can have a fixed supply, can_mint must be true to be able to mint more
    max_supply: Option<u64>,
    // total amount minted
    total_minted: u64,
    // total amount burned
    total_burned: u64,
    // permissions
    can_mint: bool,
    can_burn: bool,
    can_update_symbol: bool,
    can_update_name: bool,
    can_update_description: bool,
    can_update_icon: bool,
}

/// Create a new CurrencyRules instance
public fun new_currency_rules<CoinType>(
    max_supply: Option<u64>,
    can_mint: bool,
    can_burn: bool,
    can_update_symbol: bool,
    can_update_name: bool,
    can_update_description: bool,
    can_update_icon: bool,
): CurrencyRules<CoinType> {
    CurrencyRules {
        max_supply,
        total_minted: 0,
        total_burned: 0,
        can_mint,
        can_burn,
        can_update_symbol,
        can_update_name,
        can_update_description,
        can_update_icon,
    }
}

/// Create a CurrencyRulesKey witness (for PTB execution)
public fun currency_rules_key<CoinType>(): CurrencyRulesKey<CoinType> {
    CurrencyRulesKey()
}

/// Action disabling permissions marked as true, cannot be reenabled.
public struct DisableAction<phantom CoinType> has store, drop {
    mint: bool,
    burn: bool,
    update_symbol: bool,
    update_name: bool,
    update_description: bool,
    update_icon: bool,
}
/// Action minting new coins.
public struct MintAction<phantom CoinType> has store, drop {
    amount: u64,
}
/// Action burning coins.
public struct BurnAction<phantom CoinType> has store, drop {
    amount: u64,
}
/// Action updating a CoinMetadata object using a locked TreasuryCap.
public struct UpdateAction<phantom CoinType> has store, drop {
    symbol: Option<ascii::String>,
    name: Option<String>,
    description: Option<String>,
    icon_url: Option<ascii::String>,
}

// === Public functions ===

/// Authenticated users can lock a TreasuryCap.
public fun lock_cap<CoinType>(
    auth: Auth,
    account: &mut Account,
    registry: &PackageRegistry,
    treasury_cap: TreasuryCap<CoinType>,
    max_supply: Option<u64>,
) {
    account.verify(auth);

    let rules = CurrencyRules<CoinType> {
        max_supply,
        total_minted: 0,
        total_burned: 0,
        can_mint: true,
        can_burn: true,
        can_update_symbol: true,
        can_update_name: true,
        can_update_description: true,
        can_update_icon: true,
    };
    account.add_managed_data(registry, CurrencyRulesKey<CoinType>(), rules, version::current());
    account::add_managed_asset(account, registry, TreasuryCapKey<CoinType>(), treasury_cap, version::current());
}

/// Lock treasury cap during initialization - works on unshared Accounts
/// This function is for use during account creation, before the account is shared.
/// SAFETY: This function MUST only be called on unshared Accounts.
/// Calling this on a shared Account bypasses Auth checks.
public(package) fun do_lock_cap_unshared< CoinType>(
    account: &mut Account,
    registry: &PackageRegistry,
    treasury_cap: TreasuryCap<CoinType>,
) {
    // SAFETY REQUIREMENT: Account must be unshared
    // Default rules with no max supply
    let rules = CurrencyRules<CoinType> {
        max_supply: option::none(),
        total_minted: 0,
        total_burned: 0,
        can_mint: true,
        can_burn: true,
        can_update_symbol: true,
        can_update_name: true,
        can_update_description: true,
        can_update_icon: true,
    };
    account.add_managed_data(registry, CurrencyRulesKey<CoinType>(), rules, version::current());
    account::add_managed_asset(account, registry, TreasuryCapKey<CoinType>(), treasury_cap, version::current());
}

/// Mint coins during initialization - works on unshared Accounts
/// Transfers minted coins directly to recipient
/// SAFETY: This function MUST only be called on unshared Accounts.
/// Calling this on a shared Account bypasses Auth checks.
public(package) fun do_mint_unshared< CoinType>(
    account: &mut Account,
    registry: &PackageRegistry,
    amount: u64,
    recipient: address,
    ctx: &mut TxContext,
) {
    // SAFETY REQUIREMENT: Account must be unshared
    let rules: &mut CurrencyRules<CoinType> =
        account.borrow_managed_data_mut(registry, CurrencyRulesKey<CoinType>(), version::current());

    assert!(rules.can_mint, EMintDisabled);
    if (rules.max_supply.is_some()) {
        let total_supply = rules.total_minted - rules.total_burned;
        assert!(amount + total_supply <= *rules.max_supply.borrow(), EMaxSupply);
    };

    rules.total_minted = rules.total_minted + amount;

    let cap: &mut TreasuryCap<CoinType> =
        account.borrow_managed_asset_mut(registry, TreasuryCapKey<CoinType>(), version::current());

    let coin = cap.mint(amount, ctx);
    transfer::public_transfer(coin, recipient);
}

/// Mint coins to Coin object during initialization - works on unshared Accounts
/// Returns Coin for further use in the same transaction
public(package) fun do_mint_to_coin_unshared< CoinType>(
    account: &mut Account,
    registry: &PackageRegistry,
    amount: u64,
    ctx: &mut TxContext,
): Coin<CoinType> {
    let rules: &mut CurrencyRules<CoinType> =
        account.borrow_managed_data_mut(registry, CurrencyRulesKey<CoinType>(), version::current());

    assert!(rules.can_mint, EMintDisabled);
    if (rules.max_supply.is_some()) {
        let total_supply = rules.total_minted - rules.total_burned;
        assert!(amount + total_supply <= *rules.max_supply.borrow(), EMaxSupply);
    };

    rules.total_minted = rules.total_minted + amount;

    let cap: &mut TreasuryCap<CoinType> =
        account.borrow_managed_asset_mut(registry, TreasuryCapKey<CoinType>(), version::current());

    cap.mint(amount, ctx)
}

/// Checks if a TreasuryCap exists for a given coin type.
public fun has_cap<CoinType>(
    account: &Account
): bool {
    account.has_managed_asset(TreasuryCapKey<CoinType>())
}

/// Borrows a mutable reference to the TreasuryCap for a given coin type.
/// This is used by oracle mints and other patterns that need direct cap access
/// to bypass object-level policies (only Account access matters).
public fun borrow_treasury_cap_mut<CoinType>(
    account: &mut Account,
    registry: &PackageRegistry,
): &mut TreasuryCap<CoinType> {
    account.borrow_managed_asset_mut(registry, TreasuryCapKey<CoinType>(), version::current())
}

/// Borrows the CurrencyRules for a given coin type.
public fun borrow_rules<CoinType>(
    account: &Account,
    registry: &PackageRegistry
): &CurrencyRules<CoinType> {
    account.borrow_managed_data(registry, CurrencyRulesKey<CoinType>(), version::current())
}

/// Returns the total supply of a given coin type.
public fun coin_type_supply<CoinType>(account: &Account, registry: &PackageRegistry): u64 {
    let cap: &TreasuryCap<CoinType> =
        account.borrow_managed_asset(registry, TreasuryCapKey<CoinType>(), version::current());
    cap.total_supply()
}

/// Returns the maximum supply of a given coin type.
public fun max_supply<CoinType>(lock: &CurrencyRules<CoinType>): Option<u64> {
    lock.max_supply
}

/// Returns the total amount minted of a given coin type.
public fun total_minted<CoinType>(lock: &CurrencyRules<CoinType>): u64 {
    lock.total_minted
}

/// Returns the total amount burned of a given coin type.
public fun total_burned<CoinType>(lock: &CurrencyRules<CoinType>): u64 {
    lock.total_burned
}

/// Returns true if the coin type can mint.
public fun can_mint<CoinType>(lock: &CurrencyRules<CoinType>): bool {
    lock.can_mint
}

/// Returns true if the coin type can burn.
public fun can_burn<CoinType>(lock: &CurrencyRules<CoinType>): bool {
    lock.can_burn
}

/// Returns true if the coin type can update the symbol.
public fun can_update_symbol<CoinType>(lock: &CurrencyRules<CoinType>): bool {
    lock.can_update_symbol
}

/// Returns true if the coin type can update the name.
public fun can_update_name<CoinType>(lock: &CurrencyRules<CoinType>): bool {
    lock.can_update_name
}

/// Returns true if the coin type can update the description.
public fun can_update_description<CoinType>(lock: &CurrencyRules<CoinType>): bool {
    lock.can_update_description
}

/// Returns true if the coin type can update the icon.
public fun can_update_icon<CoinType>(lock: &CurrencyRules<CoinType>): bool {
    lock.can_update_icon
}

/// Read metadata from a CoinMetadata object
/// Simple helper to extract all metadata fields in one call
/// Returns: (decimals, symbol, name, description, icon_url)
public fun read_coin_metadata<CoinType>(
    metadata: &CoinMetadata<CoinType>,
): (u8, ascii::String, String, String, ascii::String) {
    (
        metadata.get_decimals(),
        metadata.get_symbol(),
        metadata.get_name(),
        metadata.get_description(),
        metadata.get_icon_url().extract().inner_url()
    )
}

/// Anyone can burn coins they own if enabled.
public fun public_burn<Config: store, CoinType>(
    account: &mut Account,
    registry: &PackageRegistry,
    coin: Coin<CoinType>
) {
    let rules_mut: &mut CurrencyRules<CoinType> =
        account.borrow_managed_data_mut(registry, CurrencyRulesKey<CoinType>(), version::current());
    assert!(rules_mut.can_burn, EBurnDisabled);
    rules_mut.total_burned = rules_mut.total_burned + coin.value();

    let cap_mut: &mut TreasuryCap<CoinType> =
        account.borrow_managed_asset_mut(registry, TreasuryCapKey<CoinType>(), version::current());
    cap_mut.burn(coin);
}

// === Destruction Functions ===

/// Destroy a MintAction after serialization
public fun destroy_mint_action<CoinType>(action: MintAction<CoinType>) {
    let MintAction { amount: _ } = action;
}

/// Destroy a BurnAction after serialization
public fun destroy_burn_action<CoinType>(action: BurnAction<CoinType>) {
    let BurnAction { amount: _ } = action;
}

// Intent functions

/// Creates a DisableAction and adds it to an intent.

/// Processes a DisableAction and disables the permissions marked as true.
public fun do_disable<Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version_witness: VersionWitness,
    _intent_witness: IW,
) {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<CurrencyDisable>(spec);


    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let mint = bcs::peel_bool(&mut reader);
    let burn = bcs::peel_bool(&mut reader);
    let update_symbol = bcs::peel_bool(&mut reader);
    let update_name = bcs::peel_bool(&mut reader);
    let update_description = bcs::peel_bool(&mut reader);
    let update_icon = bcs::peel_bool(&mut reader);

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    let rules_mut: &mut CurrencyRules<CoinType> =
        account.borrow_managed_data_mut(registry, CurrencyRulesKey<CoinType>(), version_witness);

    // if disabled, can be true or false, it has no effect
    if (mint) rules_mut.can_mint = false;
    if (burn) rules_mut.can_burn = false;
    if (update_symbol) rules_mut.can_update_symbol = false;
    if (update_name) rules_mut.can_update_name = false;
    if (update_description) rules_mut.can_update_description = false;
    if (update_icon) rules_mut.can_update_icon = false;

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Deletes a DisableAction from an expired intent.
public fun delete_disable<CoinType>(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, so it's automatically cleaned up
}


/// Processes an UpdateAction, updates the CoinMetadata.
public fun do_update<Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    metadata: &mut CoinMetadata<CoinType>,
    version_witness: VersionWitness,
    _intent_witness: IW,
) {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<CurrencyUpdate>(spec);


    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);

    // Deserialize Option fields
    let symbol = if (bcs::peel_bool(&mut reader)) {
        option::some(bcs::peel_vec_u8(&mut reader).to_ascii_string())
    } else {
        option::none()
    };

    let name = if (bcs::peel_bool(&mut reader)) {
        option::some(bcs::peel_vec_u8(&mut reader).to_string())
    } else {
        option::none()
    };

    let description = if (bcs::peel_bool(&mut reader)) {
        option::some(bcs::peel_vec_u8(&mut reader).to_string())
    } else {
        option::none()
    };

    let icon_url = if (bcs::peel_bool(&mut reader)) {
        option::some(bcs::peel_vec_u8(&mut reader).to_ascii_string())
    } else {
        option::none()
    };

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    let rules_mut: &mut CurrencyRules<CoinType> =
        account.borrow_managed_data_mut(registry, CurrencyRulesKey<CoinType>(), version_witness);

    if (!rules_mut.can_update_symbol) assert!(symbol.is_none(), ECannotUpdateSymbol);
    if (!rules_mut.can_update_name) assert!(name.is_none(), ECannotUpdateName);
    if (!rules_mut.can_update_description) assert!(description.is_none(), ECannotUpdateDescription);
    if (!rules_mut.can_update_icon) assert!(icon_url.is_none(), ECannotUpdateIcon);

    let (default_symbol, default_name, default_description, default_icon_url) =
        (metadata.get_symbol(), metadata.get_name(), metadata.get_description(), metadata.get_icon_url().extract().inner_url());
    let cap: &TreasuryCap<CoinType> =
        account.borrow_managed_asset(registry, TreasuryCapKey<CoinType>(), version_witness);

    cap.update_symbol(metadata, symbol.get_with_default(default_symbol));
    cap.update_name(metadata, name.get_with_default(default_name));
    cap.update_description(metadata, description.get_with_default(default_description));
    cap.update_icon_url(metadata, icon_url.get_with_default(default_icon_url));

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Deletes an UpdateAction from an expired intent.
public fun delete_update<CoinType>(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, so it's automatically cleaned up
}

/// Creates a MintAction and adds it to an intent with descriptor.

/// Processes a MintAction, mints and returns new coins.
public fun do_mint<Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version_witness: VersionWitness,
    _intent_witness: IW,
    ctx: &mut TxContext
): Coin<CoinType> {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<CurrencyMint>(spec);


    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let amount = bcs::peel_u64(&mut reader);

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    let total_supply = currency::coin_type_supply<CoinType>(account, registry);
    let rules_mut: &mut CurrencyRules<CoinType> =
        account.borrow_managed_data_mut(registry, CurrencyRulesKey<CoinType>(), version_witness);

    assert!(rules_mut.can_mint, EMintDisabled);
    if (rules_mut.max_supply.is_some()) assert!(amount + total_supply <= *rules_mut.max_supply.borrow(), EMaxSupply);

    rules_mut.total_minted = rules_mut.total_minted + amount;

    let cap_mut: &mut TreasuryCap<CoinType> =
        account.borrow_managed_asset_mut(registry, TreasuryCapKey<CoinType>(), version_witness);

    // Mint the coin
    let coin = cap_mut.mint(amount, ctx);

    // Store coin info in context for potential use by later actions
    // PTBs handle object flow naturally - no context storage needed

    // Increment action index
    executable::increment_action_idx(executable);

    coin
}

/// Deletes a MintAction from an expired intent.
public fun delete_mint<CoinType>(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, so it's automatically cleaned up
}


/// Processes a BurnAction, burns coins and returns the amount burned.
public fun do_burn<Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    coin: Coin<CoinType>,
    version_witness: VersionWitness,
    _intent_witness: IW,
) {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<CurrencyBurn>(spec);


    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let amount = bcs::peel_u64(&mut reader);

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    assert!(amount == coin.value(), EWrongValue);

    let rules_mut: &mut CurrencyRules<CoinType> =
        account.borrow_managed_data_mut(registry, CurrencyRulesKey<CoinType>(), version_witness);
    assert!(rules_mut.can_burn, EBurnDisabled);

    rules_mut.total_burned = rules_mut.total_burned + amount;

    let cap_mut: &mut TreasuryCap<CoinType> =
        account.borrow_managed_asset_mut(registry, TreasuryCapKey<CoinType>(), version_witness);

    // Increment action index
    executable::increment_action_idx(executable);

    cap_mut.burn(coin);
}

/// Deletes a BurnAction from an expired intent.
public fun delete_burn<CoinType>(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, so it's automatically cleaned up
}

// === Removal Functions (for launchpad failure cases) ===

/// Remove TreasuryCap from Account during init and transfer to recipient
/// This is package-visible so only trusted modules can call it
/// Used when a launchpad raise fails and we need to return the cap to creator
public(package) fun do_remove_treasury_cap_unshared<CoinType>(
    account: &mut Account,
    registry: &PackageRegistry,
    recipient: address,
) {
    // Extract TreasuryCap from Account
    let treasury_cap = account::remove_managed_asset<TreasuryCapKey<CoinType>, TreasuryCap<CoinType>>(
        account,
        registry,
        TreasuryCapKey<CoinType>(),
        version::current()
    );

    // Also remove the CurrencyRules since the cap is leaving
    let rules = account::remove_managed_data<CurrencyRulesKey<CoinType>, CurrencyRules<CoinType>>(
        account,
        registry,
        CurrencyRulesKey<CoinType>(),
        version::current()
    );

    // Properly destroy the CurrencyRules struct
    let CurrencyRules {
        max_supply: _,
        total_minted: _,
        total_burned: _,
        can_mint: _,
        can_burn: _,
        can_update_symbol: _,
        can_update_name: _,
        can_update_description: _,
        can_update_icon: _,
    } = rules;

    // Transfer TreasuryCap to recipient
    transfer::public_transfer(treasury_cap, recipient);
}

/// Init action: Remove TreasuryCap from Account and return to recipient
/// Follows the 3-layer action execution pattern (see IMPORTANT_ACTION_EXECUTION_PATTERN.md)
/// Used for failure_specs in launchpad raises - returns treasury cap to creator when raise fails
public fun do_init_remove_treasury_cap<Config: store, Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    _version_witness: VersionWitness,
    _intent_witness: IW,
) {
    // 1. Assert account ownership
    executable.intent().assert_is_account(account.addr());

    // 2. Get current ActionSpec from Executable
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // 3. CRITICAL: Validate action type (using marker type)
    action_validation::assert_action_type<RemoveTreasuryCap>(spec);

    // 4. Check version
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // 5. Deserialize ReturnTreasuryCapAction from BCS bytes
    let action_data = intents::action_spec_data(spec);
    let mut reader = bcs::new(*action_data);
    let recipient = bcs::peel_address(&mut reader);

    // 6. Validate all bytes consumed (security)
    bcs_validation::validate_all_bytes_consumed(reader);

    // 7. Execute with deserialized params
    do_remove_treasury_cap_unshared<CoinType>(
        account,
        registry,
        recipient,  // ‚Üê From ActionSpec, not PTB!
    );

    // 8. Increment action index
    executable::increment_action_idx(executable);
}

/// Init action: Remove CoinMetadata from Account and return to recipient
/// Follows the 3-layer action execution pattern (see IMPORTANT_ACTION_EXECUTION_PATTERN.md)
/// Used for failure_specs in launchpad raises - returns metadata to creator when raise fails
public fun do_init_remove_metadata<Config: store, Outcome: store, Key: copy + drop + store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    key: Key,
    _version_witness: VersionWitness,
    _intent_witness: IW,
) {
    // 1. Assert account ownership
    executable.intent().assert_is_account(account.addr());

    // 2. Get current ActionSpec from Executable
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // 3. CRITICAL: Validate action type (using marker type)
    action_validation::assert_action_type<RemoveMetadata>(spec);

    // 4. Check version
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // 5. Deserialize ReturnMetadataAction from BCS bytes
    let action_data = intents::action_spec_data(spec);
    let mut reader = bcs::new(*action_data);
    let recipient = bcs::peel_address(&mut reader);

    // 6. Validate all bytes consumed (security)
    bcs_validation::validate_all_bytes_consumed(reader);

    // 7. Remove metadata from account
    let metadata = account::remove_managed_asset<Key, CoinMetadata<CoinType>>(
        account,
        registry,
        key,
        version::current()
    );

    // 8. Transfer metadata to recipient
    transfer::public_transfer(metadata, recipient);

    // 9. Increment action index
    executable::increment_action_idx(executable);
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

// Portions of this file are derived from the account.tech Move Framework project.
// Those portions remain licensed under the Apache License, Version 2.0.

/// This module defines apis to transfer assets owned or managed by the account.
/// The intents can implement transfers for any action type (e.g. see owned or vault).

module account_actions::transfer;

// === Imports ===


use sui::bcs;
use account_protocol::{
    action_validation,
    intents::{Self, Expired, Intent},
    executable::{Self, Executable},
    bcs_validation,
};

// === Use Fun Aliases ===

// === Errors ===

const EUnsupportedActionVersion: u64 = 0;

// === Action Type Markers ===

/// Transfer object ownership
public struct TransferObject has drop {}
/// Transfer object to transaction sender
public struct TransferToSender has drop {}

// === Structs ===

/// Action used in combination with other actions (like WithdrawAction) to transfer objects to a recipient.
public struct TransferAction has store {
    // address to transfer to
    recipient: address,
}

/// Action to transfer to the transaction sender (perfect for crank fees)
public struct TransferToSenderAction has store {
    // No recipient field needed - uses tx_context::sender()
}

// === Destruction Functions ===

/// Destroy a TransferAction after serialization
public fun destroy_transfer_action(action: TransferAction) {
    let TransferAction { recipient: _ } = action;
}

/// Destroy a TransferToSenderAction after serialization
public fun destroy_transfer_to_sender_action(action: TransferToSenderAction) {
    let TransferToSenderAction {} = action;
}

// === Public functions ===

/// Creates a TransferAction and adds it to an intent with descriptor.

/// Processes a TransferAction and transfers an object to a recipient.
public fun do_transfer<Outcome: store, T: key + store, IW: drop>(
    executable: &mut Executable<Outcome>,
    object: T,
    _intent_witness: IW,
) {
    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<TransferObject>(spec);


    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let recipient = bcs::peel_address(&mut reader);

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    transfer::public_transfer(object, recipient);
    executable::increment_action_idx(executable);
}

/// Transfer object during initialization - works on unshared Accounts
/// Directly transfers an object to a recipient during DAO creation.
/// SAFETY: This function can be called during initialization to transfer
/// objects that were created as part of the DAO setup.
public fun do_transfer_unshared<T: key + store>(
    object: T,
    recipient: address,
) {
    transfer::public_transfer(object, recipient);
}

/// Deletes a TransferAction from an expired intent.
public fun delete_transfer(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, automatically cleaned up
}


/// Processes a TransferToSenderAction and transfers an object to the transaction sender
public fun do_transfer_to_sender<Outcome: store, T: key + store, IW: drop>(
    executable: &mut Executable<Outcome>,
    object: T,
    _intent_witness: IW,
    ctx: &mut TxContext,
) {
    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect (using TransferObject)
    action_validation::assert_action_type<TransferObject>(spec);

    let _action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // TransferToSenderAction is an empty struct with no fields to deserialize
    // We acknowledge the action_data exists but don't process it

    // Transfer to the transaction sender (the cranker!)
    transfer::public_transfer(object, tx_context::sender(ctx));
    executable::increment_action_idx(executable);
}

/// Deletes a TransferToSenderAction from an expired intent.
public fun delete_transfer_to_sender(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, automatically cleaned up
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

// Portions of this file are derived from the account.tech Move Framework project.
// Those portions remain licensed under the Apache License, Version 2.0.

/// Developers can restrict access to functions in their own package with a Cap that can be locked into an Account. 
/// The Cap can be borrowed upon approval and used in other move calls within the same ptb before being returned.
/// 
/// The Cap pattern uses the object type as a proof of access, the object ID is never checked.
/// Therefore, only one Cap of a given type can be locked into the Smart Account.
/// And any Cap of that type can be returned to the Smart Account after being borrowed.
/// 
/// A good practice to follow is to use a different Cap type for each function that needs to be restricted.
/// This way, the Cap borrowed can't be misused in another function, by the person executing the intent.
/// 
/// e.g.
/// 
/// public struct AdminCap has key, store {}
/// 
/// public fun foo(_: &AdminCap) { ... }

module account_actions::access_control;

// === Imports ===


use sui::bcs::{Self, BCS};
use account_protocol::{
    action_validation,
    account::{Account, Auth},
    intents::{Self, Expired, Intent},
    executable::{Self, Executable},
    version_witness::VersionWitness,
    package_registry::PackageRegistry,
};
use account_actions::version;

// === Use Fun Aliases ===

// === Errors ===

/// BorrowAction requires a matching ReturnAction in the same intent to ensure capability is returned
const ENoReturn: u64 = 0;
/// Error when action version is not supported
const EUnsupportedActionVersion: u64 = 1;

// === Action Type Markers ===

/// Store/lock capability
public struct AccessControlStore has drop {}
/// Borrow capability
public struct AccessControlBorrow has drop {}
/// Return borrowed capability
public struct AccessControlReturn has drop {}

public fun access_control_store(): AccessControlStore { AccessControlStore {} }
public fun access_control_borrow(): AccessControlBorrow { AccessControlBorrow {} }
public fun access_control_return(): AccessControlReturn { AccessControlReturn {} }

// === Structs ===    

/// Dynamic Object Field key for the Cap.
public struct CapKey<phantom Cap>() has copy, drop, store;

/// Action giving access to the Cap.
public struct BorrowAction<phantom Cap> has drop, store {}
/// This hot potato is created upon approval to ensure the cap is returned.
public struct ReturnAction<phantom Cap> has drop, store {}

// === Public functions ===

/// Authenticated user can lock a Cap, the Cap must have at least store ability.
public fun lock_cap<Config: store, Cap: key + store>(
    auth: Auth,
    account: &mut Account,
    registry: &PackageRegistry,
    cap: Cap,
) {
    account.verify(auth);
    account.add_managed_asset(registry, CapKey<Cap>(), cap, version::current());
}

/// Lock capability during initialization - works on unshared Accounts
/// Store any capability in the Account during creation
public(package) fun do_lock_cap_unshared< Cap: key + store>(
    account: &mut Account,
    registry: &PackageRegistry,
    cap: Cap,
) {
    account.add_managed_asset(registry, CapKey<Cap>(), cap, version::current());
}

/// Checks if there is a Cap locked for a given type.
public fun has_lock<Config: store, Cap>(
    account: &Account
): bool {
    account.has_managed_asset(CapKey<Cap>())
}

// === Destruction Functions ===

/// Destroy a BorrowAction after serialization
public fun destroy_borrow_action<Cap>(action: BorrowAction<Cap>) {
    let BorrowAction {} = action;
}

/// Destroy a ReturnAction after serialization
public fun destroy_return_action<Cap>(action: ReturnAction<Cap>) {
    let ReturnAction {} = action;
}

// Intent functions

/// Creates and returns a BorrowAction.

/// Processes a BorrowAction and returns a Borrowed hot potato and the Cap.
public fun do_borrow<Config: store, Outcome: store, Cap: key + store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version_witness: VersionWitness,
    _intent_witness: IW,
): Cap {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec and verify it's a BorrowAction
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<AccessControlBorrow>(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    let _action_data = intents::action_spec_data(spec);

    // BorrowAction is an empty struct with no fields to deserialize
    // We acknowledge the action_data exists but don't process it

    // CRITICAL: Verify that a matching ReturnAction exists in the intent
    // This ensures the borrowed capability will be returned
    let current_idx = executable.action_idx();
    let mut return_found = false;
    let return_action_type = action_validation::get_action_type_name<AccessControlReturn>();

    // Search from the next action onwards
    let mut i = current_idx + 1;
    while (i < specs.length()) {
        let future_spec = specs.borrow(i);
        if (intents::action_spec_type(future_spec) == return_action_type) {
            return_found = true;
            break
        };
        i = i + 1;
    };

    assert!(return_found, ENoReturn);

    // For BorrowAction<Cap>, there's no data to deserialize (empty struct)
    // Just increment the action index
    executable::increment_action_idx(executable);

    account.remove_managed_asset(registry, CapKey<Cap>(), version_witness)
}

/// Deletes a BorrowAction from an expired intent.
public fun delete_borrow<Cap>(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, automatically cleaned up
}


/// Returns a Cap to the Account and validates the ReturnAction.
public fun do_return<Config: store, Outcome: store, Cap: key + store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    cap: Cap,
    version_witness: VersionWitness,
    _intent_witness: IW,
) {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec and verify it's a ReturnAction
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<AccessControlReturn>(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    let _action_data = intents::action_spec_data(spec);

    // ReturnAction is an empty struct with no fields to deserialize
    // We acknowledge the action_data exists but don't process it

    // Increment the action index
    executable::increment_action_idx(executable);

    account.add_managed_asset(registry, CapKey<Cap>(), cap, version_witness);
}

/// Deletes a ReturnAction from an expired intent.
public fun delete_return<Cap>(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, automatically cleaned up
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

module futarchy_one_shot_utils::vectors;

use std::string::String;
use sui::coin::{Self, Coin};
use sui::vec_set;

// === Introduction ===
// Vector Methods and processing

// === Public Functions ===
// Combined check that a vector contains only unique elements and that all the elements are less then a certain length
public fun check_valid_outcomes(outcome: vector<String>, max_length: u64): bool {
    let length = outcome.length();
    if (length == 0) return false;

    // Create a vec_set to track unique strings
    let mut seen = vec_set::empty<String>();

    let mut i = 0;
    while (i < length) {
        let current_string_ref = &outcome[i];
        // Check length constraint
        let string_length = current_string_ref.length();
        if (string_length == 0 || string_length > max_length) {
            return false
        };
        if (seen.contains(current_string_ref)) {
            return false
        };

        // Add to our set of seen strings
        seen.insert(*current_string_ref);
        i = i + 1;
    };

    true
}

/// Validates a single outcome message - checks length bounds
public fun validate_outcome_message(message: &String, max_length: u64): bool {
    let length = message.length();
    length > 0 && length <= max_length
}

/// Validates outcome detail - checks length bounds
public fun validate_outcome_detail(detail: &String, max_length: u64): bool {
    let length = detail.length();
    length > 0 && length <= max_length
}

/// Checks if a message already exists in the outcome messages
public fun is_duplicate_message(outcome_messages: &vector<String>, new_message: &String): bool {
    let mut i = 0;
    let len = outcome_messages.length();
    while (i < len) {
        if (outcome_messages[i] == *new_message) {
            return true
        };
        i = i + 1;
    };
    false
}

/// Merges a vector of coins into a single coin
public fun merge_coins<T>(mut coins: vector<Coin<T>>, ctx: &mut TxContext): Coin<T> {
    assert!(!coins.is_empty(), 0);

    let mut merged = coins.pop_back();
    while (!coins.is_empty()) {
        coin::join(&mut merged, coins.pop_back());
    };
    coins.destroy_empty();

    merged
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Registry of pre-created "blank" coin types that can be used for conditional tokens
/// Solves the problem that coin types can't be created dynamically in Sui
/// Allows proposal creators to acquire coin pairs without requiring two transactions
module futarchy_one_shot_utils::coin_registry;

use sui::clock::Clock;
use sui::coin::{TreasuryCap, CoinMetadata, Coin};
use sui::dynamic_field;
use sui::event;
use sui::sui::SUI;

// === Errors ===
const ESupplyNotZero: u64 = 0;
const EInsufficientFee: u64 = 1;
const ERegistryNotEmpty: u64 = 2;
const ENameNotEmpty: u64 = 3;
const EDescriptionNotEmpty: u64 = 4;
const ESymbolNotEmpty: u64 = 5;
const EIconUrlNotEmpty: u64 = 6;
const ERegistryFull: u64 = 7;
const EFeeExceedsMaximum: u64 = 8;
const ENoCoinSetsAvailable: u64 = 9;

// === Constants ===
const MAX_COIN_SETS: u64 = 100_000;
/// Maximum fee in SUI MIST (10 SUI = 10_000_000_000 MIST)
/// Prevents malicious actors from setting arbitrarily high fees that would DoS the registry
/// by filling it with economically unusable coin sets
const MAX_FEE: u64 = 10_000_000_000;

// === Structs ===

/// A single coin set ready for use as conditional tokens
/// Contains both TreasuryCap and CoinMetadata for one coin type
public struct CoinSet<phantom T> has store {
    treasury_cap: TreasuryCap<T>,
    metadata: CoinMetadata<T>,
    owner: address, // Who deposited this set and gets paid
    fee: u64, // Fee in SUI to acquire this set
}

/// Global registry storing available coin sets
/// Permissionless - anyone can add coin sets
/// Uses dynamic fields to store different CoinSet<T> types
public struct CoinRegistry has key {
    id: UID,
    // CoinSets stored as dynamic fields with cap_id as key
    // Dynamic fields allow storing different CoinSet<T> types
    total_sets: u64,
}

// === Events ===

public struct CoinSetDeposited has copy, drop {
    registry_id: ID,
    cap_id: ID,
    owner: address,
    fee: u64,
    timestamp: u64,
}

public struct CoinSetTaken has copy, drop {
    registry_id: ID,
    cap_id: ID,
    taker: address,
    fee_paid: u64,
    owner_paid: address,
    timestamp: u64,
}

// === Validation Functions ===

/// Basic validation of a coin set (supply must be zero, types must match)
/// Used by factory and launchpad to ensure cap validity
/// Does NOT enforce empty metadata - use validate_coin_set_for_registry for that
///
/// Checks:
/// 1. Supply must be zero (prevents using already-minted coins)
/// 2. Type parameters of treasury_cap and metadata must match (enforced by generics)
public fun validate_coin_set<T>(
    treasury_cap: &TreasuryCap<T>,
    _metadata: &CoinMetadata<T>,
) {
    // Validate coin meets requirements: supply must be zero
    assert!(treasury_cap.total_supply() == 0, ESupplyNotZero);

    // Type match is enforced by generics - both must be same type T
}

/// Validate a coin set for deposit into registry
/// Enforces stricter requirements: metadata must be empty for "blank" conditional tokens
///
/// Checks:
/// 1. Supply must be zero (prevents using already-minted coins)
/// 2. Metadata must be empty (name, symbol, description, icon)
/// 3. Type parameters of treasury_cap and metadata must match (enforced by generics)
fun validate_coin_set_for_registry<T>(
    treasury_cap: &TreasuryCap<T>,
    metadata: &CoinMetadata<T>,
) {
    // First do basic validation
    validate_coin_set(treasury_cap, metadata);

    // Validate metadata is empty (required for "blank" conditional tokens)
    // These coins should have no preset names/symbols so they can be customized
    assert!(metadata.get_name().is_empty(), ENameNotEmpty);
    assert!(metadata.get_description().is_empty(), EDescriptionNotEmpty);
    assert!(metadata.get_symbol().is_empty(), ESymbolNotEmpty);
    assert!(metadata.get_icon_url().is_none(), EIconUrlNotEmpty);
}

// === Admin Functions ===

/// Create a new coin registry (admin/one-time setup)
public fun create_registry(ctx: &mut TxContext): CoinRegistry {
    CoinRegistry {
        id: object::new(ctx),
        total_sets: 0,
    }
}

/// Share the registry to make it publicly accessible
public entry fun share_registry(registry: CoinRegistry) {
    transfer::share_object(registry);
}

/// Destroy an empty registry
public fun destroy_empty_registry(registry: CoinRegistry) {
    let CoinRegistry { id, total_sets } = registry;
    assert!(total_sets == 0, ERegistryNotEmpty);
    id.delete();
}

// === Deposit Functions ===

/// Deposit a coin set into the registry
/// Validates that the coin meets all requirements for conditional tokens
public fun deposit_coin_set<T>(
    registry: &mut CoinRegistry,
    treasury_cap: TreasuryCap<T>,
    metadata: CoinMetadata<T>,
    fee: u64,
    clock: &Clock,
    ctx: &TxContext,
) {
    // Check registry not full
    assert!(registry.total_sets < MAX_COIN_SETS, ERegistryFull);

    // Validate fee is reasonable to prevent DoS attacks
    // Without this check, malicious actors could fill the registry with
    // coin sets demanding arbitrarily high fees (e.g., u64::max = 18.4B SUI),
    // making them economically unusable and permanently occupying registry slots
    assert!(fee <= MAX_FEE, EFeeExceedsMaximum);

    // Validate coin set for registry (supply must be zero, metadata must be empty)
    validate_coin_set_for_registry(&treasury_cap, &metadata);

    let cap_id = object::id(&treasury_cap);
    let owner = ctx.sender();

    // Create coin set
    let coin_set = CoinSet {
        treasury_cap,
        metadata,
        owner,
        fee,
    };

    // Store in registry as dynamic field
    dynamic_field::add(&mut registry.id, cap_id, coin_set);
    registry.total_sets = registry.total_sets + 1;

    // Emit event
    event::emit(CoinSetDeposited {
        registry_id: object::id(registry),
        cap_id,
        owner,
        fee,
        timestamp: clock.timestamp_ms(),
    });
}

/// Deposit a coin set via entry function (transfers ownership)
public entry fun deposit_coin_set_entry<T>(
    registry: &mut CoinRegistry,
    treasury_cap: TreasuryCap<T>,
    metadata: CoinMetadata<T>,
    fee: u64,
    clock: &Clock,
    ctx: &TxContext,
) {
    deposit_coin_set(registry, treasury_cap, metadata, fee, clock, ctx);
}

// === Take Functions ===

/// Take a coin set from registry and transfer caps to sender
/// Returns the remaining payment coin for chaining multiple takes in a PTB
/// Call this N times in a PTB for N outcomes
public fun take_coin_set<T>(
    registry: &mut CoinRegistry,
    cap_id: ID,
    mut fee_payment: Coin<SUI>,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<SUI> {
    // Check exists
    assert!(
        dynamic_field::exists_with_type<ID, CoinSet<T>>(&registry.id, cap_id),
        ENoCoinSetsAvailable,
    );

    // Remove from registry
    let coin_set: CoinSet<T> = dynamic_field::remove(&mut registry.id, cap_id);

    // Validate fee
    assert!(fee_payment.value() >= coin_set.fee, EInsufficientFee);

    // Split exact payment
    let payment = fee_payment.split(coin_set.fee, ctx);

    // Pay owner
    transfer::public_transfer(payment, coin_set.owner);

    // Update total count
    registry.total_sets = registry.total_sets - 1;

    // Emit event
    event::emit(CoinSetTaken {
        registry_id: object::id(registry),
        cap_id,
        taker: ctx.sender(),
        fee_paid: coin_set.fee,
        owner_paid: coin_set.owner,
        timestamp: clock.timestamp_ms(),
    });

    // Return caps to sender (they become owned objects)
    let CoinSet { treasury_cap, metadata, owner: _, fee: _ } = coin_set;
    transfer::public_transfer(treasury_cap, ctx.sender());
    transfer::public_transfer(metadata, ctx.sender());

    // Return remaining payment for next take
    fee_payment
}

// === View Functions ===

/// Get total number of coin sets in registry
public fun total_sets(registry: &CoinRegistry): u64 {
    registry.total_sets
}

/// Check if a specific coin set is available
public fun has_coin_set(registry: &CoinRegistry, cap_id: ID): bool {
    dynamic_field::exists_(&registry.id, cap_id)
}

/// Get fee for a specific coin set
public fun get_fee<T>(registry: &CoinRegistry, cap_id: ID): u64 {
    let coin_set: &CoinSet<T> = dynamic_field::borrow(&registry.id, cap_id);
    coin_set.fee
}

/// Get owner of a specific coin set
public fun get_owner<T>(registry: &CoinRegistry, cap_id: ID): address {
    let coin_set: &CoinSet<T> = dynamic_field::borrow(&registry.id, cap_id);
    coin_set.owner
}

// === Helper Functions for Proposals ===

/// Validate coin set in registry without removing it
public fun validate_coin_set_in_registry(registry: &CoinRegistry, cap_id: ID): bool {
    dynamic_field::exists_(&registry.id, cap_id)
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

module futarchy_one_shot_utils::strategy;

// === Constants for Strategy Types ===
const STRATEGY_AND: u8 = 0;
const STRATEGY_OR: u8 = 1;
const STRATEGY_EITHER: u8 = 2; // XOR
const STRATEGY_THRESHOLD: u8 = 3;

/// Strategy for combining multiple approval conditions
/// Uses constants instead of magic numbers for clarity
public struct Strategy has copy, drop, store {
    kind: u8,
    m: u64, // For threshold: minimum approvals required
    n: u64, // For threshold: total number of conditions
}

public fun and(): Strategy {
    Strategy { kind: STRATEGY_AND, m: 0, n: 0 }
}

public fun or(): Strategy {
    Strategy { kind: STRATEGY_OR, m: 0, n: 0 }
}

public fun either(): Strategy {
    Strategy { kind: STRATEGY_EITHER, m: 0, n: 0 }
}

public fun threshold(m: u64, n: u64): Strategy {
    Strategy { kind: STRATEGY_THRESHOLD, m, n }
}

/// Combine boolean gates. Extend by adding more sources as needed.
public fun can_execute(ok_a: bool, ok_b: bool, s: Strategy): bool {
    if (s.kind == STRATEGY_AND) {
        // Both conditions must be true
        ok_a && ok_b
    } else if (s.kind == STRATEGY_OR) {
        // At least one condition must be true
        ok_a || ok_b
    } else if (s.kind == STRATEGY_EITHER) {
        // Exactly one condition must be true (XOR)
        (ok_a && !ok_b) || (!ok_a && ok_b)
    } else if (s.kind == STRATEGY_THRESHOLD) {
        // M-of-N threshold over 2 booleans
        let satisfied_count = (if (ok_a) 1 else 0) + (if (ok_b) 1 else 0);
        satisfied_count >= s.m && s.n >= s.m
    } else {
        // Unknown strategy type - fail safe by requiring all conditions
        false
    }
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Centralized constants for the Futarchy protocol
/// This module contains all magic numbers and configuration constants
/// to ensure consistency across the codebase
module futarchy_one_shot_utils::constants;

// === AMM Fee Constants ===

/// Maximum fee in basis points (100%) - for calculations only
public fun max_fee_bps(): u64 { 10000 }

/// Maximum AMM fee in basis points (5%) - hard cap for steady-state fees
public fun max_amm_fee_bps(): u64 { 500 }

/// Maximum AMM fee during launch window in basis points (99%)
/// Allows high initial fees for anti-snipe protection
public fun max_launch_fee_bps(): u64 { 9900 }

/// LP fee share in basis points for CONDITIONAL AMMs (80% of fees go to LPs)
public fun conditional_lp_fee_share_bps(): u64 { 8000 }

/// Protocol fee share in basis points for CONDITIONAL AMMs (20% of fees go to protocol)
public fun conditional_protocol_fee_share_bps(): u64 { 2000 }

/// LP fee share in basis points for SPOT AMM (90% of fees go to LPs)
public fun spot_lp_fee_share_bps(): u64 { 9000 }

/// Protocol fee share in basis points for SPOT AMM (10% of fees go to protocol)
public fun spot_protocol_fee_share_bps(): u64 { 1000 }

/// Total fee basis points denominator (100%)
public fun total_fee_bps(): u64 { 10000 }

/// Default AMM total fee in basis points (0.3%)
public fun default_amm_total_fee_bps(): u64 { 30 }

// === Price Precision Constants ===

/// Price scale for AMM calculations (10^12)
/// Used for high-precision reserve ratio calculations
public fun price_scale(): u128 { 1_000_000_000_000 }

/// Price precision scale for calculations (10^12)
/// Used for high-precision price calculations to prevent rounding to 0.
/// NOTE: This is NOT basis points (which is 10,000 for 100%).
/// This is a price multiplier scale similar to price_multiplier_scale() but with higher precision.
/// Use max_fee_bps() or total_fee_bps() for actual basis points calculations.
public fun price_precision_scale(): u64 { 1_000_000_000_000 }

/// Price multiplier scale (10^9)
/// Used for relative price calculations (e.g., 2_000_000_000 = 2.0x)
/// Matches AMM spot price precision
public fun price_multiplier_scale(): u64 { 1_000_000_000 }

/// Parts per million denominator for percentage calculations
public fun ppm_denominator(): u64 { 1_000_000 }

// === Time Constants ===

/// TWAP price cap window in milliseconds (60 seconds)
public fun twap_price_cap_window(): u64 { 60_000 }

/// One week in milliseconds
public fun one_week_ms(): u64 { 604_800_000 }

/// Seal reveal grace period (7 days in milliseconds)
/// Time after launchpad deadline to decrypt Seal-encrypted max raise
public fun seal_reveal_grace_period_ms(): u64 { 604_800_000 }

/// Default permit expiry time (5 minutes)
public fun default_permit_expiry_ms(): u64 { 5 * 60_000 }

// === Governance Constants ===

/// Maximum queue size for proposals
public fun max_queue_size(): u64 { 100 }

/// Grace period for proposal eviction
public fun proposal_grace_period_ms(): u64 { 24 * 60 * 60_000 } // 24 hours

/// Protocol-level maximum outcomes per proposal
/// Updated to 50 with O(N) linear filter optimization (was 5 with O(N¬≤) pruning)
public fun protocol_max_outcomes(): u64 { 50 }

/// Protocol-level maximum actions per proposal (across all outcomes)
public fun protocol_max_actions(): u64 { 50 }

/// Protocol-level maximum actions per single outcome
public fun protocol_max_actions_per_outcome(): u64 { 20 }

/// Default maximum outcomes per proposal for DAOs
public fun default_max_outcomes(): u64 { 2 }

/// Default maximum actions per proposal for DAOs (across all outcomes)
public fun default_max_actions_per_proposal(): u64 { 10 }

/// Default maximum actions per outcome for DAOs
public fun default_max_actions_per_outcome(): u64 { 5 }

/// Minimum number of outcomes for any proposal
public fun min_outcomes(): u64 { 2 }

/// Minimum review period in milliseconds
public fun min_review_period_ms(): u64 { 1000 } // 1 second for testing

/// Minimum trading period in milliseconds
public fun min_trading_period_ms(): u64 { 1000 } // 1 second for testing

/// Minimum grace period for eviction in milliseconds
public fun min_eviction_grace_period_ms(): u64 { 300000 } // 5 minutes

/// Minimum proposal intent expiry in milliseconds
public fun min_proposal_intent_expiry_ms(): u64 { 3600000 } // 1 hour

/// Default optimistic challenge fee (1 billion MIST = 1 token)
public fun default_optimistic_challenge_fee(): u64 { 1_000_000_000 }

/// Default optimistic challenge period in milliseconds (10 days)
public fun default_optimistic_challenge_period_ms(): u64 { 864_000_000 }

/// Default eviction grace period in milliseconds (2 hours)
public fun default_eviction_grace_period_ms(): u64 { 7_200_000 }

/// Default proposal intent expiry in milliseconds (30 days)
public fun default_proposal_intent_expiry_ms(): u64 { 2_592_000_000 }

/// Default fee escalation basis points (5%)
public fun default_fee_escalation_bps(): u64 { 500 }

/// Default queue fullness multiplier for exponential fee scaling (50%)
/// Controls how aggressively fees increase as queue fills up
public fun default_queue_fullness_multiplier_bps(): u64 { 5000 }

// === Queue Fee Split Constants ===
// Two fees: Bond (spam prevention) + Priority Fee (queue position)
// NO protocol cuts - all revenue stays with DAO

// === Cancellation Splits ===
/// Bond split on cancellation: 50% proposer (partial refund), 50% DAO (spam tax)
public fun bond_cancel_proposer_bps(): u64 { 5000 }
public fun bond_cancel_dao_bps(): u64 { 5000 }

/// Priority fee on cancellation: 100% refund to proposer
public fun priority_fee_cancel_refund_bps(): u64 { 10000 }

// === Eviction Splits ===
/// Bond split on eviction: 50% evictor (reward), 50% DAO
public fun bond_evict_evictor_bps(): u64 { 5000 }
public fun bond_evict_dao_bps(): u64 { 5000 }

/// Priority fee on eviction: 90% proposer (partial refund), 10% evictor (reward)
public fun priority_fee_evict_proposer_bps(): u64 { 9000 }
public fun priority_fee_evict_evictor_bps(): u64 { 1000 }

// === Activation Splits ===
/// Bond split on activation: 50% activator (reward for cranking), 50% DAO
public fun bond_activation_activator_bps(): u64 { 5000 }
public fun bond_activation_dao_bps(): u64 { 5000 }

/// Priority fee on activation: 100% to DAO treasury (full governance revenue!)
public fun priority_fee_activation_dao_bps(): u64 { 10000 }

/// Default proposal creation cooldown after DAO creation (2 hours in milliseconds)
/// Prevents immediate sniping of proposal queue slots
public fun default_proposal_creation_cooldown_ms(): u64 { 7_200_000 }

/// Maximum proposal creation cooldown (24 hours in milliseconds)
/// Hard cap to prevent DAOs from being permanently locked
public fun max_proposal_creation_cooldown_ms(): u64 { 86_400_000 }

// === Cleanup Constants ===

/// Maximum intents that can be cleaned in one call
public fun max_cleanup_per_call(): u64 { 20 }

/// Maximum pending withdrawals per payment stream
public fun max_pending_withdrawals(): u64 { 10 }

// === Market Constants ===

/// Number of outcomes for binary markets
public fun binary_outcomes(): u64 { 2 }

/// Token type constants
public fun token_type_asset(): u8 { 0 }

public fun token_type_stable(): u8 { 1 }

public fun token_type_lp(): u8 { 2 }

// === Liquidity Constants ===

/// Minimum percentage of liquidity that can move to conditional markets (base 100)
/// Enforces at least 1% stays in spot pool for trading during proposals
public fun min_conditional_liquidity_percent(): u64 { 1 }

/// Maximum percentage of liquidity that can move to conditional markets (base 100)
/// Enforces at least 1% stays in spot pool for trading during proposals
public fun max_conditional_liquidity_percent(): u64 { 99 }

/// Default percentage of liquidity that moves to conditional markets (base 100)
/// 80% provides good balance between price discovery and spot liquidity
public fun default_conditional_liquidity_percent(): u64 { 80 }

// === Document Registry Constants ===

/// Maximum chunks per document (limited by per-tx dynamic field access)
public fun max_chunks_per_document(): u64 { 1000 }

/// Maximum documents per DAO (soft limit for reasonable DAOs)
public fun max_documents_per_dao(): u64 { 1000 }

/// Maximum traversal limit for document queries (pagination)
public fun max_traversal_limit(): u64 { 1000 }

// === Treasury & Payment Constants ===
//
// UPGRADABLE LIMITS PATTERN:
// These constants are referenced by move-framework modules (vault, vesting, stream_utils)
// but defined here for centralized upgradability.
//
// To change these limits system-wide:
// 1. Update the values below
// 2. Deploy new version of futarchy_one_shot_utils
// 3. Redeploy dependent packages (they'll pick up new limits)
//
// This enables DAOs to adjust limits via package upgrade proposals
// without modifying the core framework code.

/// Maximum beneficiaries per stream/vesting
/// Used by vault streams and vesting to limit multi-beneficiary coordination
/// Current: 100 (reasonable for most DAO coordination scenarios)
/// To increase: Update here and redeploy. Consider gas costs for large beneficiary lists.
public fun max_beneficiaries(): u64 { 100 }

// === Launchpad Constants ===

/// The duration for every launchpad raise (4 days in milliseconds)
public fun launchpad_duration_ms(): u64 { 30_000 } // 30 seconds for E2E testing

/// Claim period after successful raise before creator can sweep dust (14 days)
public fun launchpad_claim_period_ms(): u64 { 1_209_600_000 }

/// Minimum SUI fee per contribution (0.1 SUI) to prevent spam and fund settlement cranking
public fun launchpad_bid_fee_per_contribution(): u64 { 100_000_000 }

/// Reward paid to cranker per successful claim (0.05 SUI) - decoupled from bid fee
public fun launchpad_cranker_reward_per_claim(): u64 { 50_000_000 }

/// Reward per cap processed during settlement cranking (0.05 SUI)
public fun launchpad_reward_per_cap_processed(): u64 { 50_000_000 }

/// Maximum number of unique cap values to prevent unbounded heap
/// Limits settlement gas costs (100 caps √ó 0.05 SUI = 5 SUI max)
public fun launchpad_max_unique_caps(): u64 { 100 }

/// Maximum number of init actions during DAO creation
public fun launchpad_max_init_actions(): u64 { 20 }

/// Estimated max gas per init action
public fun launchpad_max_gas_per_action(): u64 { 1_000_000 }

// === Validation Functions ===

/// Check if a fee is valid (not exceeding maximum)
public fun is_valid_fee(fee_bps: u64): bool {
    fee_bps <= max_fee_bps()
}

/// Check if a cap percentage is valid (not exceeding 100%)
public fun is_valid_cap_ppm(cap_ppm: u64): bool {
    cap_ppm <= ppm_denominator()
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

module futarchy_one_shot_utils::math;

use std::u128;
use std::u64;

// === Introduction ===
// Integer type conversion and integer methods

// === Errors ===
const EOverflow: u64 = 0;
const EDivideByZero: u64 = 1;
const EValueExceedsU64: u64 = 2;

// === Public Functions ===
// Multiplies two u64 values and divides by a third, checking for overflow
// Returns (a * b) / c
//
// SAFETY: The product of two u64 values can be at most (2^64 - 1)^2 = 2^128 - 2^65 + 1,
// which is less than 2^128 and therefore always fits in a u128. This property ensures
// that the intermediate multiplication a_128 * b_128 will never overflow.
// The division by c then reduces the result, and we verify it fits in u64 before casting.
public fun mul_div_to_64(a: u64, b: u64, c: u64): u64 {
    assert!(c != 0, EDivideByZero);

    // Cast to u128 to prevent overflow during multiplication
    // SAFE: Product of two u64s always fits in u128 (see safety note above)
    let a_128 = (a as u128);
    let b_128 = (b as u128);
    let c_128 = (c as u128);

    // Perform the multiplication and division
    let result = (a_128 * b_128) / c_128;

    // Ensure the result fits back into u64
    assert!(result <= (u64::max_value!() as u128), EOverflow);
    (result as u64)
}

public fun mul_div_to_128(a: u64, b: u64, c: u64): u128 {
    assert!(c != 0, EDivideByZero);
    // Use u256 for intermediate calculation to avoid overflow
    let a_256 = (a as u256);
    let b_256 = (b as u256);
    let c_256 = (c as u256);
    let result_256 = (a_256 * b_256) / c_256;
    // Ensure result fits in u128
    assert!(result_256 <= (u128::max_value!() as u256), EOverflow);
    (result_256 as u128)
}

public fun mul_div_mixed(a: u128, b: u64, c: u128): u128 {
    assert!(c != 0, EDivideByZero);
    let a_256 = (a as u256);
    let b_256 = (b as u256);
    let c_256 = (c as u256);
    let result = (a_256 * b_256) / c_256;
    assert!(result <= (u128::max_value!() as u256), EOverflow);
    (result as u128)
}

// Safely multiplies two u64 values and divides by a third, rounding up
// Returns ceil((a * b) / c)
//
// SAFETY: Same as mul_div_to_64 - the product of two u64s always fits in u128.
// The rounding up operation adds at most (c-1) to the numerator before division.
public fun mul_div_up(a: u64, b: u64, c: u64): u64 {
    assert!(c != 0, EDivideByZero);

    // Cast to u128 to prevent overflow during multiplication
    // SAFE: Product of two u64s always fits in u128
    let a_128 = (a as u128);
    let b_128 = (b as u128);
    let c_128 = (c as u128);

    // Calculate the numerator (product of a and b)
    let numerator = a_128 * b_128;

    // Perform division with rounding up
    let result = if (numerator == 0) {
        0
    } else {
        // Add (c-1) to round up: ceil(n/c) = floor((n + c - 1) / c)
        let sum = numerator + c_128 - 1;
        assert!(sum >= numerator, EOverflow); // Verify no overflow in addition
        sum / c_128
    };

    // Ensure the result fits back into u64
    assert!(result <= (u64::max_value!() as u128), EOverflow);
    (result as u64)
}

// Saturating addition that won't overflow
public fun saturating_add(a: u128, b: u128): u128 {
    if (u128::max_value!() - a < b) {
        u128::max_value!()
    } else {
        a + b
    }
}

// Saturating subtraction that won't underflow
public fun saturating_sub(a: u128, b: u128): u128 {
    if (a < b) {
        0
    } else {
        a - b
    }
}

public fun safe_u128_to_u64(value: u128): u64 {
    assert!(value <= (u64::max_value!() as u128), EValueExceedsU64);
    (value as u64)
}

// Check if a value is within a percentage tolerance
// Returns true if |a - b| <= (tolerance_bps * max(a,b)) / 10000
public fun within_tolerance(a: u64, b: u64, tolerance_bps: u64): bool {
    let diff = a.diff(b);
    let max_val = a.max(b);
    let tolerance = mul_div_to_64(max_val, tolerance_bps, 10000);
    diff <= tolerance
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

module futarchy_one_shot_utils::metadata;

use std::string::String;
use sui::table::{Self, Table};
use sui::vec_set::{Self, VecSet};

// === Errors ===
const EInvalidMetadataLength: u64 = 0; // Keys and values vectors must have same length
const EEmptyKey: u64 = 1; // Metadata key cannot be empty
const EKeyTooLong: u64 = 2; // Metadata key exceeds maximum length
const EValueTooLong: u64 = 3; // Metadata value exceeds maximum length
const EDuplicateKey: u64 = 4; // Duplicate key in metadata

// === Constants ===
const MAX_KEY_LENGTH: u64 = 64; // Maximum length for metadata keys
const MAX_VALUE_LENGTH: u64 = 256; // Maximum length for metadata values
const MAX_ENTRIES: u64 = 50; // Maximum number of metadata entries

// === Public Functions ===

/// Create a new metadata table from parallel vectors of keys and values
/// This is useful for entry functions that can't accept Table parameters
public fun new_from_vectors(
    keys: vector<String>,
    values: vector<String>,
    ctx: &mut TxContext,
): Table<String, String> {
    let keys_len = keys.length();
    let values_len = values.length();

    // Validate input
    assert!(keys_len == values_len, EInvalidMetadataLength);
    assert!(keys_len <= MAX_ENTRIES, EInvalidMetadataLength);

    let mut metadata = table::new<String, String>(ctx);
    let mut i = 0;

    while (i < keys_len) {
        let key = &keys[i];
        let value = &values[i];

        // Validate key and value
        assert!(key.length() > 0, EEmptyKey);
        assert!(key.length() <= MAX_KEY_LENGTH, EKeyTooLong);
        assert!(value.length() <= MAX_VALUE_LENGTH, EValueTooLong);

        // Check for duplicates
        assert!(!table::contains(&metadata, *key), EDuplicateKey);

        table::add(&mut metadata, *key, *value);
        i = i + 1;
    };

    metadata
}

/// Add a single key-value pair to an existing metadata table
public fun add_entry(metadata: &mut Table<String, String>, key: String, value: String) {
    // Validate
    assert!(key.length() > 0, EEmptyKey);
    assert!(key.length() <= MAX_KEY_LENGTH, EKeyTooLong);
    assert!(value.length() <= MAX_VALUE_LENGTH, EValueTooLong);
    assert!(table::length(metadata) < MAX_ENTRIES, EInvalidMetadataLength);

    if (table::contains(metadata, key)) {
        // Update existing entry
        table::remove(metadata, key);
        table::add(metadata, key, value);
    } else {
        // Add new entry
        table::add(metadata, key, value);
    }
}

/// Update an existing entry in the metadata table
public fun update_entry(metadata: &mut Table<String, String>, key: String, value: String) {
    assert!(value.length() <= MAX_VALUE_LENGTH, EValueTooLong);

    // Update existing entry
    if (table::contains(metadata, key)) {
        let val_ref = table::borrow_mut(metadata, key);
        *val_ref = value;
    } else {
        // Add new entry if it doesn't exist
        add_entry(metadata, key, value);
    }
}

/// Remove an entry from the metadata table
public fun remove_entry(metadata: &mut Table<String, String>, key: String): String {
    table::remove(metadata, key)
}

/// Check if a key exists in the metadata
public fun contains_key(metadata: &Table<String, String>, key: &String): bool {
    table::contains(metadata, *key)
}

/// Get a value from the metadata table
public fun get_value(metadata: &Table<String, String>, key: &String): &String {
    table::borrow(metadata, *key)
}

/// Get the number of entries in the metadata table
public fun length(metadata: &Table<String, String>): u64 {
    table::length(metadata)
}

/// Validate metadata without creating a table (useful for pre-validation)
///
/// Gas optimization: Uses VecSet (stack-based) instead of Bag (object-based)
/// for temporary uniqueness checking. For 50 keys:
/// - Old (Bag): 1 object creation + 50 dynamic field writes + 50 deletions
/// - New (VecSet): 50 in-memory insertions (O(log N) each)
public fun validate_metadata_vectors(
    keys: &vector<String>,
    values: &vector<String>,
) {
    let keys_len = keys.length();
    let values_len = values.length();

    assert!(keys_len == values_len, EInvalidMetadataLength);
    assert!(keys_len <= MAX_ENTRIES, EInvalidMetadataLength);

    let mut i = 0;
    let mut seen_keys = vec_set::empty<String>();

    while (i < keys_len) {
        let key = &keys[i];
        let value = &values[i];

        // Validate key and value
        assert!(key.length() > 0, EEmptyKey);
        assert!(key.length() <= MAX_KEY_LENGTH, EKeyTooLong);
        assert!(value.length() <= MAX_VALUE_LENGTH, EValueTooLong);

        // Check for duplicates
        assert!(!vec_set::contains(&seen_keys, key), EDuplicateKey);
        vec_set::insert(&mut seen_keys, *key);

        i = i + 1;
    };

    // No cleanup needed - VecSet automatically destroyed when it goes out of scope
}

// === Common Metadata Keys ===
// These constants define standard metadata keys used across the protocol

/// Website URL for the DAO or proposal
public fun key_website(): String { b"website".to_string() }

/// Twitter/X handle
public fun key_twitter(): String { b"twitter".to_string() }

/// Discord server invite link
public fun key_discord(): String { b"discord".to_string() }

/// GitHub organization or repository
public fun key_github(): String { b"github".to_string() }

/// Telegram group link
public fun key_telegram(): String { b"telegram".to_string() }

/// Documentation URL
public fun key_docs(): String { b"docs".to_string() }

/// Whitepaper or litepaper URL
public fun key_whitepaper(): String { b"whitepaper".to_string() }

/// Token contract address (for existing tokens)
public fun key_token_address(): String { b"token_address".to_string() }

/// Total token supply
public fun key_token_supply(): String { b"token_supply".to_string() }

/// Token distribution details
public fun key_token_distribution(): String { b"token_distribution".to_string() }

/// Team information
public fun key_team(): String { b"team".to_string() }

/// Roadmap URL or description
public fun key_roadmap(): String { b"roadmap".to_string() }

/// Legal entity information
public fun key_legal_entity(): String { b"legal_entity".to_string() }

/// Terms of service URL
public fun key_terms(): String { b"terms".to_string() }

/// Privacy policy URL
public fun key_privacy(): String { b"privacy".to_string() }
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Basic signed integer helpers for configurations that need negative values.
/// Stores a `u128` magnitude with an explicit sign flag to avoid relying on
/// signed primitives that Move does not provide.
module futarchy_types::signed;

// Comparison return values follow the same conventions as `std::option`:
// 0 = less, 1 = equal, 2 = greater.
const ORDERING_LESS: u8 = 0;
const ORDERING_EQUAL: u8 = 1;
const ORDERING_GREATER: u8 = 2;

/// Signed 128-bit integer encoded as magnitude + sign.
public struct SignedU128 has copy, drop, store {
    magnitude: u128,
    is_negative: bool,
}

/// Construct a new signed value.
public fun new(magnitude: u128, is_negative: bool): SignedU128 {
    SignedU128 { magnitude, is_negative }
}

/// Create a zero value.
public fun zero(): SignedU128 {
    SignedU128 { magnitude: 0, is_negative: false }
}

/// Construct from an unsigned value (positive).
public fun from_u64(value: u64): SignedU128 {
    SignedU128 { magnitude: (value as u128), is_negative: false }
}

/// Construct from an unsigned value (positive).
public fun from_u128(value: u128): SignedU128 {
    SignedU128 { magnitude: value, is_negative: false }
}

/// Return the magnitude.
public fun magnitude(value: &SignedU128): u128 {
    value.magnitude
}

/// True if the value is negative.
public fun is_negative(value: &SignedU128): bool {
    value.is_negative
}

/// Pack the value into a tuple (magnitude, is_negative).
/// Useful for constructing composite structs without exposing internal field
/// names to callers in other packages.
public fun to_parts(value: &SignedU128): (u128, bool) {
    (value.magnitude, value.is_negative)
}

/// Create from tuple parts.
public fun from_parts(magnitude: u128, is_negative: bool): SignedU128 {
    SignedU128 { magnitude, is_negative }
}

/// Convert an unsigned value with an explicit sign flag.
public fun from_signed_parts(magnitude: u128, is_negative: bool): SignedU128 {
    SignedU128 { magnitude, is_negative }
}

/// Compare two signed values.
/// Returns ORDERING_LESS (0), ORDERING_EQUAL (1), or ORDERING_GREATER (2).
public fun compare(lhs: &SignedU128, rhs: &SignedU128): u8 {
    if (lhs.is_negative != rhs.is_negative) {
        if (lhs.is_negative) {
            ORDERING_LESS
        } else {
            ORDERING_GREATER
        }
    } else {
        if (lhs.magnitude == rhs.magnitude) {
            ORDERING_EQUAL
        } else if (lhs.is_negative) {
            // Both negative: larger magnitude => smaller numeric value
            if (lhs.magnitude > rhs.magnitude) {
                ORDERING_LESS
            } else {
                ORDERING_GREATER
            }
        } else {
            // Both non-negative: standard comparison
            if (lhs.magnitude < rhs.magnitude) {
                ORDERING_LESS
            } else {
                ORDERING_GREATER
            }
        }
    }
}

/// Negate a signed value.
public fun negate(value: &SignedU128): SignedU128 {
    SignedU128 {
        magnitude: value.magnitude,
        is_negative: !value.is_negative,
    }
}

/// Convenience helper to treat an unsigned magnitude as signed.
public fun as_signed(is_negative: bool, magnitude: u128): SignedU128 {
    SignedU128 { magnitude, is_negative }
}

/// Serialize helpers for Move's BCS compatibility when callers need direct
/// access to the fields.
public fun magnitude_mut(value: &mut SignedU128): &mut u128 {
    &mut value.magnitude
}

public fun sign_mut(value: &mut SignedU128): &mut bool {
    &mut value.is_negative
}

public fun ordering_less(): u8 { ORDERING_LESS }

public fun ordering_equal(): u8 { ORDERING_EQUAL }

public fun ordering_greater(): u8 { ORDERING_GREATER }
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Module for validating action types in intents
module futarchy_core::action_validation;

use account_protocol::intents::ActionSpec;
use std::type_name::{Self, TypeName};

/// Error codes
const EActionTypeMismatch: u64 = 1;

/// Assert that an action spec matches the expected action type
/// This validates that the action type in the spec matches the type T
public fun assert_action_type<T>(spec: &ActionSpec) {
    use account_protocol::intents;
    let expected_type = type_name::with_defining_ids<T>();
    let actual_type = intents::action_spec_type(spec);
    assert!(actual_type == expected_type, EActionTypeMismatch);
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Proposal quota registry for allowlisted addresses
/// Tracks recurring proposal quotas (N proposals per period at reduced fee)
module futarchy_core::proposal_quota_registry;

use std::string::String;
use sui::clock::Clock;
use sui::event;
use sui::table::{Self, Table};

// === Errors ===
const EInvalidQuotaParams: u64 = 0;
const EWrongDao: u64 = 1;

// === Structs ===

/// Recurring quota: N proposals per period at reduced fee
public struct QuotaInfo has copy, drop, store {
    /// Number of proposals allowed per period
    quota_amount: u64,
    /// Time period in milliseconds (e.g., 30 days = 2_592_000_000)
    quota_period_ms: u64,
    /// Reduced fee (0 for free)
    reduced_fee: u64,
    /// Period start (aligned to boundaries, not drift)
    period_start_ms: u64,
    /// Usage in current period
    used_in_period: u64,
    /// Number of sponsorships allowed per period
    sponsor_quota_amount: u64,
    /// Sponsorships used in current period
    sponsor_quota_used: u64,
    /// Sponsorship period start (aligned to boundaries, not drift)
    sponsor_period_start_ms: u64,
}

/// Registry for a specific DAO's proposal quotas
public struct ProposalQuotaRegistry has key, store {
    id: UID,
    /// The DAO this registry belongs to
    dao_id: ID,
    /// Maps address to their quota info
    quotas: Table<address, QuotaInfo>,
}

// === Events ===

public struct QuotasSet has copy, drop {
    dao_id: ID,
    users: vector<address>,
    quota_amount: u64,
    quota_period_ms: u64,
    reduced_fee: u64,
    timestamp: u64,
}

public struct QuotasRemoved has copy, drop {
    dao_id: ID,
    users: vector<address>,
    timestamp: u64,
}

public struct QuotaUsed has copy, drop {
    dao_id: ID,
    user: address,
    remaining: u64,
    timestamp: u64,
}

public struct QuotaRefunded has copy, drop {
    dao_id: ID,
    user: address,
    remaining: u64,
    timestamp: u64,
    reason: String,
}

public struct SponsorQuotasSet has copy, drop {
    dao_id: ID,
    users: vector<address>,
    sponsor_quota_amount: u64,
    timestamp: u64,
}

public struct SponsorQuotaUsed has copy, drop {
    dao_id: ID,
    sponsor: address,
    proposal_id: ID,
    remaining: u64,
    timestamp: u64,
}

public struct SponsorQuotaRefunded has copy, drop {
    dao_id: ID,
    sponsor: address,
    proposal_id: ID,
    remaining: u64,
    timestamp: u64,
    reason: String,
}

// === Public Functions ===

/// Create a new quota registry for a DAO
public fun new(dao_id: ID, ctx: &mut TxContext): ProposalQuotaRegistry {
    ProposalQuotaRegistry {
        id: object::new(ctx),
        dao_id,
        quotas: table::new(ctx),
    }
}

/// Set quotas for multiple users (batch operation)
/// Pass empty quota_amount to remove quotas
public fun set_quotas(
    registry: &mut ProposalQuotaRegistry,
    dao_id: ID,
    users: vector<address>,
    quota_amount: u64,
    quota_period_ms: u64,
    reduced_fee: u64,
    clock: &Clock,
) {
    // Verify DAO ownership
    assert!(registry.dao_id == dao_id, EWrongDao);

    // Validate params if setting (not removing)
    if (quota_amount > 0) {
        assert!(quota_period_ms > 0, EInvalidQuotaParams);
    };

    let now = clock.timestamp_ms();
    let mut i = 0;
    let len = users.length();

    while (i < len) {
        let user = *users.borrow(i);

        if (quota_amount == 0) {
            // Remove quota
            if (registry.quotas.contains(user)) {
                registry.quotas.remove(user);
            };
        } else {
            // Set/update quota
            let info = QuotaInfo {
                quota_amount,
                quota_period_ms,
                reduced_fee,
                period_start_ms: now,
                used_in_period: 0,
                sponsor_quota_amount: 0, // Default: no sponsorship quota
                sponsor_quota_used: 0,
                sponsor_period_start_ms: now,
            };

            if (registry.quotas.contains(user)) {
                *registry.quotas.borrow_mut(user) = info;
            } else {
                registry.quotas.add(user, info);
            };
        };

        i = i + 1;
    };

    // Emit appropriate event
    if (quota_amount == 0) {
        event::emit(QuotasRemoved {
            dao_id,
            users,
            timestamp: now,
        });
    } else {
        event::emit(QuotasSet {
            dao_id,
            users,
            quota_amount,
            quota_period_ms,
            reduced_fee,
            timestamp: now,
        });
    };
}

/// Check quota availability (read-only, no state mutation)
/// Returns (has_quota, reduced_fee)
public fun check_quota_available(
    registry: &ProposalQuotaRegistry,
    dao_id: ID,
    user: address,
    clock: &Clock,
): (bool, u64) {
    // Verify DAO ownership
    assert!(registry.dao_id == dao_id, EWrongDao);

    if (!registry.quotas.contains(user)) {
        return (false, 0)
    };

    let info = registry.quotas.borrow(user);
    let now = clock.timestamp_ms();

    // Calculate periods elapsed for alignment (no drift)
    let periods_elapsed = (now - info.period_start_ms) / info.quota_period_ms;

    // If period expired, quota resets
    let used = if (periods_elapsed > 0) {
        0
    } else {
        info.used_in_period
    };

    let has_quota = used < info.quota_amount;
    (has_quota, info.reduced_fee)
}

/// Use one quota slot (called AFTER proposal succeeds)
/// This prevents quota loss if proposal creation fails
public fun use_quota(
    registry: &mut ProposalQuotaRegistry,
    dao_id: ID,
    user: address,
    clock: &Clock,
) {
    // Verify DAO ownership
    assert!(registry.dao_id == dao_id, EWrongDao);

    if (!registry.quotas.contains(user)) {
        return
    };

    let info = registry.quotas.borrow_mut(user);
    let now = clock.timestamp_ms();

    // Reset period if expired (aligned to boundaries)
    let periods_elapsed = (now - info.period_start_ms) / info.quota_period_ms;
    if (periods_elapsed > 0) {
        info.period_start_ms = info.period_start_ms + (periods_elapsed * info.quota_period_ms);
        info.used_in_period = 0;
    };

    // Use one slot (should always have quota here, but safe increment)
    if (info.used_in_period < info.quota_amount) {
        info.used_in_period = info.used_in_period + 1;

        event::emit(QuotaUsed {
            dao_id: registry.dao_id,
            user,
            remaining: info.quota_amount - info.used_in_period,
            timestamp: now,
        });
    };
}

/// Refund one quota slot (called when proposal using quota is evicted)
/// Only decrements if user has used quota in current period
public fun refund_quota(
    registry: &mut ProposalQuotaRegistry,
    dao_id: ID,
    user: address,
    clock: &Clock,
) {
    use std::string;

    // Verify DAO ownership
    assert!(registry.dao_id == dao_id, EWrongDao);

    if (!registry.quotas.contains(user)) {
        return
    };

    let info = registry.quotas.borrow_mut(user);
    let now = clock.timestamp_ms();

    // Reset period if expired (aligned to boundaries)
    let periods_elapsed = (now - info.period_start_ms) / info.quota_period_ms;
    if (periods_elapsed > 0) {
        info.period_start_ms = info.period_start_ms + (periods_elapsed * info.quota_period_ms);
        info.used_in_period = 0;

        // Emit event for period reset (no refund needed)
        event::emit(QuotaRefunded {
            dao_id: registry.dao_id,
            user,
            remaining: info.quota_amount, // Full quota available in new period
            timestamp: now,
            reason: string::utf8(b"period_expired"),
        });
        return
    };

    // Decrement usage if any quota was used
    if (info.used_in_period > 0) {
        info.used_in_period = info.used_in_period - 1;

        // Emit refund event
        event::emit(QuotaRefunded {
            dao_id: registry.dao_id,
            user,
            remaining: info.quota_amount - info.used_in_period,
            timestamp: now,
            reason: string::utf8(b"proposal_evicted"),
        });
    };
}

// === Sponsorship Quota Functions ===

/// Set sponsorship quotas for multiple users (batch operation)
/// Pass 0 to disable sponsorship quota for users
public fun set_sponsor_quotas(
    registry: &mut ProposalQuotaRegistry,
    dao_id: ID,
    users: vector<address>,
    sponsor_quota_amount: u64,
    clock: &Clock,
) {
    // Verify DAO ownership
    assert!(registry.dao_id == dao_id, EWrongDao);

    let now = clock.timestamp_ms();
    let mut i = 0;
    let len = users.length();

    while (i < len) {
        let user = *users.borrow(i);

        // Only update if user has existing quota info
        if (registry.quotas.contains(user)) {
            let info = registry.quotas.borrow_mut(user);
            info.sponsor_quota_amount = sponsor_quota_amount;
            info.sponsor_quota_used = 0; // Reset usage
            info.sponsor_period_start_ms = now; // Reset period
        };

        i = i + 1;
    };

    // Emit event
    event::emit(SponsorQuotasSet {
        dao_id,
        users,
        sponsor_quota_amount,
        timestamp: now,
    });
}

/// Check sponsorship quota availability (read-only, no state mutation)
/// Returns (has_quota, remaining)
public fun check_sponsor_quota_available(
    registry: &ProposalQuotaRegistry,
    dao_id: ID,
    sponsor: address,
    clock: &Clock,
): (bool, u64) {
    // Verify DAO ownership
    assert!(registry.dao_id == dao_id, EWrongDao);

    if (!registry.quotas.contains(sponsor)) {
        return (false, 0)
    };

    let info = registry.quotas.borrow(sponsor);
    let now = clock.timestamp_ms();

    // If no sponsor quota configured, return false
    if (info.sponsor_quota_amount == 0) {
        return (false, 0)
    };

    // Calculate periods elapsed for alignment (no drift)
    let periods_elapsed = (now - info.sponsor_period_start_ms) / info.quota_period_ms;

    // If period expired, quota resets
    let used = if (periods_elapsed > 0) {
        0
    } else {
        info.sponsor_quota_used
    };

    let remaining = info.sponsor_quota_amount - used;
    let has_quota = remaining > 0;
    (has_quota, remaining)
}

/// Use one sponsorship quota slot (called AFTER sponsorship succeeds)
public fun use_sponsor_quota(
    registry: &mut ProposalQuotaRegistry,
    dao_id: ID,
    sponsor: address,
    proposal_id: ID,
    clock: &Clock,
) {
    // Verify DAO ownership
    assert!(registry.dao_id == dao_id, EWrongDao);

    if (!registry.quotas.contains(sponsor)) {
        return
    };

    let info = registry.quotas.borrow_mut(sponsor);
    let now = clock.timestamp_ms();

    // Skip if no sponsor quota configured
    if (info.sponsor_quota_amount == 0) {
        return
    };

    // Reset period if expired (aligned to boundaries)
    let periods_elapsed = (now - info.sponsor_period_start_ms) / info.quota_period_ms;
    if (periods_elapsed > 0) {
        info.sponsor_period_start_ms = info.sponsor_period_start_ms + (periods_elapsed * info.quota_period_ms);
        info.sponsor_quota_used = 0;
    };

    // Use one slot (should always have quota here, but safe increment)
    if (info.sponsor_quota_used < info.sponsor_quota_amount) {
        info.sponsor_quota_used = info.sponsor_quota_used + 1;

        event::emit(SponsorQuotaUsed {
            dao_id: registry.dao_id,
            sponsor,
            proposal_id,
            remaining: info.sponsor_quota_amount - info.sponsor_quota_used,
            timestamp: now,
        });
    };
}

/// Refund one sponsorship quota slot (called when sponsored proposal is evicted/cancelled)
/// Only decrements if sponsor has used quota in current period
public fun refund_sponsor_quota(
    registry: &mut ProposalQuotaRegistry,
    dao_id: ID,
    sponsor: address,
    proposal_id: ID,
    clock: &Clock,
) {
    use std::string;

    // Verify DAO ownership
    assert!(registry.dao_id == dao_id, EWrongDao);

    if (!registry.quotas.contains(sponsor)) {
        return
    };

    let info = registry.quotas.borrow_mut(sponsor);
    let now = clock.timestamp_ms();

    // Skip if no sponsor quota configured
    if (info.sponsor_quota_amount == 0) {
        return
    };

    // Reset period if expired (aligned to boundaries)
    let periods_elapsed = (now - info.sponsor_period_start_ms) / info.quota_period_ms;
    if (periods_elapsed > 0) {
        info.sponsor_period_start_ms = info.sponsor_period_start_ms + (periods_elapsed * info.quota_period_ms);
        info.sponsor_quota_used = 0;

        // Emit event for period reset (no refund needed)
        event::emit(SponsorQuotaRefunded {
            dao_id: registry.dao_id,
            sponsor,
            proposal_id,
            remaining: info.sponsor_quota_amount, // Full quota available in new period
            timestamp: now,
            reason: string::utf8(b"period_expired"),
        });
        return
    };

    // Decrement usage if any quota was used
    if (info.sponsor_quota_used > 0) {
        info.sponsor_quota_used = info.sponsor_quota_used - 1;

        // Emit refund event
        event::emit(SponsorQuotaRefunded {
            dao_id: registry.dao_id,
            sponsor,
            proposal_id,
            remaining: info.sponsor_quota_amount - info.sponsor_quota_used,
            timestamp: now,
            reason: string::utf8(b"proposal_evicted_or_cancelled"),
        });
    };
}

// === View Functions ===

/// Get quota info with remaining count
/// Returns (has_quota, remaining, reduced_fee)
public fun get_quota_status(
    registry: &ProposalQuotaRegistry,
    user: address,
    clock: &Clock,
): (bool, u64, u64) {
    if (!registry.quotas.contains(user)) {
        return (false, 0, 0)
    };

    let info = registry.quotas.borrow(user);
    let now = clock.timestamp_ms();

    let periods_elapsed = (now - info.period_start_ms) / info.quota_period_ms;
    let used = if (periods_elapsed > 0) { 0 } else { info.used_in_period };
    let remaining = info.quota_amount - used;

    (remaining > 0, remaining, info.reduced_fee)
}

/// Get DAO ID
public fun dao_id(registry: &ProposalQuotaRegistry): ID {
    registry.dao_id
}

/// Check if user has any quota
public fun has_quota(registry: &ProposalQuotaRegistry, user: address): bool {
    registry.quotas.contains(user)
}

// === Getter Functions ===

public fun quota_amount(info: &QuotaInfo): u64 { info.quota_amount }

public fun quota_period_ms(info: &QuotaInfo): u64 { info.quota_period_ms }

public fun reduced_fee(info: &QuotaInfo): u64 { info.reduced_fee }

public fun period_start_ms(info: &QuotaInfo): u64 { info.period_start_ms }

public fun used_in_period(info: &QuotaInfo): u64 { info.used_in_period }

public fun sponsor_quota_amount(info: &QuotaInfo): u64 { info.sponsor_quota_amount }

public fun sponsor_quota_used(info: &QuotaInfo): u64 { info.sponsor_quota_used }

public fun sponsor_period_start_ms(info: &QuotaInfo): u64 { info.sponsor_period_start_ms }
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// DAO configuration management module
/// Provides centralized configuration structs and validation for futarchy DAOs
module futarchy_core::dao_config;

use futarchy_one_shot_utils::constants;
use futarchy_types::signed::{Self as signed, SignedU128};
use std::ascii::{Self, String as AsciiString};
use std::string::{Self, String};
use sui::url::{Self, Url};

// === Errors ===
const EInvalidMinAmount: u64 = 0; // Minimum amount must be positive
const EMinAmountTooLow: u64 = 16; // Minimum amount must be at least 100,000 (0.1 tokens with 6 decimals)
const EInvalidPeriod: u64 = 1; // Period must be positive
const EInvalidFee: u64 = 2; // Fee exceeds maximum (10000 bps = 100%)
const EInvalidMaxOutcomes: u64 = 3; // Max outcomes must be at least 2
const EInvalidTwapThreshold: u64 = 4; // TWAP threshold must be valid
const EInvalidProposalFee: u64 = 5; // Proposal fee must be positive
const EInvalidBondAmount: u64 = 6; // Bond amount must be positive
const EInvalidTwapParams: u64 = 7; // Invalid TWAP parameters
const EInvalidGracePeriod: u64 = 8; // Grace period too short
const EInvalidMaxConcurrentProposals: u64 = 9; // Max concurrent proposals must be positive
const EMaxOutcomesExceedsProtocol: u64 = 10; // Max outcomes exceeds protocol limit
const EMaxActionsExceedsProtocol: u64 = 11; // Max actions exceeds protocol limit
const EStateInconsistent: u64 = 12; // State would become inconsistent with this change
const EInvalidQuotaParams: u64 = 14; // Invalid quota parameters
const ENoConditionalMetadata: u64 = 15; // No conditional metadata available (neither CoinMetadata nor fallback config)
const ESponsoredThresholdMustBeNonPositive: u64 = 17; // Sponsored threshold must be ‚â§ 0
const ESponsoredThresholdExceedsProtocolMax: u64 = 18; // Sponsored threshold magnitude exceeds ¬±5%
const EProposalFeeExceedsMax: u64 = 19; // Proposal fee exceeds maximum allowed

// === Constants ===
// Most constants are now in futarchy_utils::constants
// Only keep module-specific error codes here

// Minimum liquidity amounts for conditional markets
// Ensures proposals NEVER blocked by quantum split k>=1000 check
//
// With min=100,000 and 99% ratio: spot keeps 100,000 * 1/100 = 1,000 each
// ‚Üí k = 1,000 * 1,000 = 1,000,000 ‚úÖ (well above AMM MINIMUM_LIQUIDITY = 1,000)
//
// Cost is trivial with common decimal counts:
// - 6 decimals (USDC): 100,000 = 0.1 tokens
// - 8 decimals (BTC-style): 100,000 = 0.001 tokens
// - 9 decimals (Sui): 100,000 = 0.0001 tokens (basically free)
const PROTOCOL_MIN_LIQUIDITY_AMOUNT: u64 = 100000;

// Protocol-level threshold bounds: ¬±5% maximum (duplicated here to avoid circular dependency)

// Maximum DAO-level proposal fees (10,000 tokens with 6 decimals)
// Prevents malicious DAOs from setting prohibitively high fees that block governance
// 10,000 tokens is high enough for any legitimate use case but prevents griefing
const MAX_PROPOSAL_CREATION_FEE: u64 = 10_000_000_000; // 10,000 tokens (6 decimals)
const MAX_PROPOSAL_FEE_PER_OUTCOME: u64 = 10_000_000_000; // 10,000 tokens (6 decimals)
const PROTOCOL_MAX_THRESHOLD_NEGATIVE: u128 = 50_000_000_000; // -5% (stored as magnitude, 0.05 * 1e12)

// === Structs ===

/// Trading parameters configuration
public struct TradingParams has copy, drop, store {
    // Range: PROTOCOL_MIN_LIQUIDITY_AMOUNT (100000) to u64::MAX
    min_asset_amount: u64,
    // Range: PROTOCOL_MIN_LIQUIDITY_AMOUNT (100000) to u64::MAX
    min_stable_amount: u64,
    // Range: constants::min_review_period_ms() to u64::MAX milliseconds
    review_period_ms: u64,
    // Range: constants::min_trading_period_ms() to u64::MAX milliseconds
    trading_period_ms: u64,
    // Range: 0 to constants::max_amm_fee_bps() (10000 = 100%) basis points
    conditional_amm_fee_bps: u64, // Fee for conditional AMMs (prediction markets)
    // Range: 0 to constants::max_amm_fee_bps() (10000 = 100%) basis points
    spot_amm_fee_bps: u64, // Fee for spot AMM (base pool)
    // Market operation review period (for conditional raise/buyback)
    // Can be 0 to skip review and start trading immediately after market init
    // Range: 0 to review_period_ms milliseconds
    market_op_review_period_ms: u64,
    // Max percentage (in basis points) of AMM reserves that can be auto-swapped per proposal
    // Default: 1000 bps (10%) - prevents market from becoming too illiquid for trading
    // Range: 0 to constants::max_fee_bps() (10000 = 100%) basis points
    max_amm_swap_percent_bps: u64,
    // Percentage of liquidity that moves to conditional markets when proposal launches
    // Base 100 precision (1 = 1%, 80 = 80%, 99 = 99%)
    // Valid range: 1-99 (enforced to ensure both spot and conditional pools have liquidity)
    // Default: 80 (80%) - balances price discovery with spot trading
    // Range: constants::min_conditional_liquidity_percent() to constants::max_conditional_liquidity_percent() (1-99)
    conditional_liquidity_ratio_percent: u64,
}

/// TWAP (Time-Weighted Average Price) configuration
public struct TwapConfig has copy, drop, store {
    // Range: 0 to u64::MAX milliseconds (can be 0 for immediate TWAP start)
    start_delay: u64,
    // Range: 1 to u64::MAX milliseconds (must be positive)
    step_max: u64,
    // Range: 1 to u128::MAX (must be positive, in 1e12 scale)
    initial_observation: u128,
    // Range: ¬±PROTOCOL_MAX_THRESHOLD (¬±50_000_000_000 = ¬±5% in 1e12 scale)
    threshold: SignedU128,
}

public struct GovernanceConfig has copy, drop, store {
    // Range: constants::min_outcomes() to constants::protocol_max_outcomes()
    max_outcomes: u64,
    // Range: 1 to constants::protocol_max_actions_per_outcome()
    max_actions_per_outcome: u64,
    // Range: 1 to MAX_PROPOSAL_CREATION_FEE (10_000_000_000 = 10,000 tokens with 6 decimals)
    proposal_creation_fee: u64, // Base fee to create a proposal (DAO-level, in StableType)
    // Range: 1 to MAX_PROPOSAL_FEE_PER_OUTCOME (10_000_000_000 = 10,000 tokens with 6 decimals)
    proposal_fee_per_outcome: u64, // Fee per additional outcome beyond initial 2 (DAO-level, in StableType)
    // Categories: true (accept new proposals), false (reject new proposals)
    accept_new_proposals: bool,
    // Range: 1 to u64::MAX
    max_intents_per_outcome: u64,
    // Range: constants::min_proposal_intent_expiry_ms() to u64::MAX milliseconds
    proposal_intent_expiry_ms: u64,
    // Categories: true (enable lock), false (disable lock)
    enable_premarket_reservation_lock: bool,
    // Categories: true (show proposal details in UI), false (hide details, show only intents)
    // WARNING: Proposal details are unverified text that may not match actual intent execution
    // Recommended: false (hide details by default for security)
    show_proposal_details: bool,  // show per outcome description in UI if true
}

/// Metadata configuration
public struct MetadataConfig has copy, drop, store {
    dao_name: AsciiString,
    icon_url: Url,
    description: String,
}

/// Conditional coin metadata configuration for proposals
public struct ConditionalCoinConfig has copy, drop, store {
    // Categories: true (append outcome index), false (don't append)
    use_outcome_index: bool, // If true, append outcome index to name
    // If Some(), use these hardcoded values for conditional tokens
    // If None(), derive conditional token names from base DAO token CoinMetadata
    conditional_metadata: Option<ConditionalMetadata>,
}

/// Metadata for conditional tokens (fallback if CoinMetadata can't be read)
public struct ConditionalMetadata has copy, drop, store {
    // Range: 0 to 255 (typically 6-18 for most tokens)
    decimals: u8, // Decimals for conditional coins
    coin_name_prefix: AsciiString, // Prefix for coin names (e.g., "MyDAO_")
    coin_icon_url: Url, // Icon URL for conditional coins
}

/// Quota system configuration
public struct QuotaConfig has copy, drop, store {
    // Categories: true (quota system active), false (quota system inactive)
    enabled: bool, // If true, quota system is active
    // Range: 1 to u64::MAX (must be positive if enabled)
    default_quota_amount: u64, // Default proposals per period for new allowlist members
    // Range: 1 to u64::MAX milliseconds (must be positive if enabled)
    default_quota_period_ms: u64, // Default period for quotas (e.g., 30 days)
    // Range: 0 to u64::MAX (0 = free)
    default_reduced_fee: u64, // Default reduced fee (0 for free)
}

/// Sponsorship system configuration
/// Allows team members to sponsor external proposals by setting a fixed threshold
public struct SponsorshipConfig has copy, drop, store {
    // Categories: true (sponsorship system active), false (sponsorship system inactive)
    enabled: bool, // If true, sponsorship system is active
    // Range: 0 or negative with magnitude ‚â§ PROTOCOL_MAX_THRESHOLD_NEGATIVE (50_000_000_000 = 5%)
    sponsored_threshold: SignedU128, // Fixed threshold for sponsored proposals (must be ‚â§ 0, e.g., 0 or -2%)
    // Categories: true (waive fees), false (don't waive fees)
    waive_advancement_fees: bool, // Does sponsorship also waive advancement fees?
    // Range: 1 to u64::MAX (must be positive if enabled)
    default_sponsor_quota_amount: u64, // Default sponsorships per period
}

/// Complete DAO configuration
public struct DaoConfig has copy, drop, store {
    trading_params: TradingParams,
    twap_config: TwapConfig,
    governance_config: GovernanceConfig,
    metadata_config: MetadataConfig,
    conditional_coin_config: ConditionalCoinConfig,
    quota_config: QuotaConfig,
    sponsorship_config: SponsorshipConfig,
}

// === Constructor Functions ===

/// Create a new trading parameters configuration
public fun new_trading_params(
    min_asset_amount: u64,
    min_stable_amount: u64,
    review_period_ms: u64,
    trading_period_ms: u64,
    conditional_amm_fee_bps: u64,
    spot_amm_fee_bps: u64,
    market_op_review_period_ms: u64,
    max_amm_swap_percent_bps: u64,
    conditional_liquidity_ratio_percent: u64,
): TradingParams {
    // Validate inputs
    assert!(min_asset_amount > 0, EInvalidMinAmount);
    assert!(min_stable_amount > 0, EInvalidMinAmount);
    assert!(min_asset_amount >= PROTOCOL_MIN_LIQUIDITY_AMOUNT, EMinAmountTooLow);
    assert!(min_stable_amount >= PROTOCOL_MIN_LIQUIDITY_AMOUNT, EMinAmountTooLow);
    assert!(review_period_ms >= constants::min_review_period_ms(), EInvalidPeriod);
    assert!(trading_period_ms >= constants::min_trading_period_ms(), EInvalidPeriod);
    assert!(conditional_amm_fee_bps <= constants::max_amm_fee_bps(), EInvalidFee);
    assert!(spot_amm_fee_bps <= constants::max_amm_fee_bps(), EInvalidFee);

    // Market op review period can be 0 for immediate trading
    // Should not exceed regular review period (market ops are meant to be faster or equal)
    assert!(market_op_review_period_ms <= review_period_ms, EInvalidPeriod);

    // Max swap percent must be reasonable (0-100%)
    assert!(max_amm_swap_percent_bps <= constants::max_fee_bps(), EInvalidFee);

    // Conditional liquidity ratio must be within valid range (base 100: 1-99%)
    // Ensures both spot and conditional pools always have liquidity
    assert!(
        conditional_liquidity_ratio_percent >= constants::min_conditional_liquidity_percent() &&
        conditional_liquidity_ratio_percent <= constants::max_conditional_liquidity_percent(),
        EInvalidFee,
    );

    TradingParams {
        min_asset_amount,
        min_stable_amount,
        review_period_ms,
        trading_period_ms,
        conditional_amm_fee_bps,
        spot_amm_fee_bps,
        market_op_review_period_ms,
        max_amm_swap_percent_bps,
        conditional_liquidity_ratio_percent,
    }
}

/// Create a new TWAP configuration
public fun new_twap_config(
    start_delay: u64,
    step_max: u64,
    initial_observation: u128,
    threshold: SignedU128,
): TwapConfig {
    // Validate inputs - start_delay can be 0 for immediate TWAP start
    // This is a valid use case for certain market configurations
    assert!(step_max > 0, EInvalidTwapParams);
    assert!(initial_observation > 0, EInvalidTwapParams);

    TwapConfig {
        start_delay,
        step_max,
        initial_observation,
        threshold,
    }
}

/// Create a new governance configuration
public fun new_governance_config(
    max_outcomes: u64,
    max_actions_per_outcome: u64,
    proposal_creation_fee: u64,
    proposal_fee_per_outcome: u64,
    accept_new_proposals: bool,
    max_intents_per_outcome: u64,
    proposal_intent_expiry_ms: u64,
    enable_premarket_reservation_lock: bool,
    show_proposal_details: bool,
): GovernanceConfig {
    assert!(max_outcomes >= constants::min_outcomes(), EInvalidMaxOutcomes);
    assert!(max_outcomes <= constants::protocol_max_outcomes(), EMaxOutcomesExceedsProtocol);
    assert!(
        max_actions_per_outcome > 0 && max_actions_per_outcome <= constants::protocol_max_actions_per_outcome(),
        EMaxActionsExceedsProtocol,
    );
    assert!(proposal_creation_fee > 0, EInvalidProposalFee);
    assert!(proposal_fee_per_outcome > 0, EInvalidProposalFee);
    assert!(max_intents_per_outcome > 0, EInvalidMaxOutcomes);

    GovernanceConfig {
        max_outcomes,
        max_actions_per_outcome,
        proposal_creation_fee,
        proposal_fee_per_outcome,
        accept_new_proposals,
        max_intents_per_outcome,
        proposal_intent_expiry_ms,
        enable_premarket_reservation_lock,
        show_proposal_details,
    }
}

/// Create a new metadata configuration
public fun new_metadata_config(
    dao_name: AsciiString,
    icon_url: Url,
    description: String,
): MetadataConfig {
    MetadataConfig {
        dao_name,
        icon_url,
        description,
    }
}

/// Create conditional coin config
public fun new_conditional_coin_config(
    use_outcome_index: bool,
    conditional_metadata: Option<ConditionalMetadata>,
): ConditionalCoinConfig {
    ConditionalCoinConfig {
        use_outcome_index,
        conditional_metadata,
    }
}

/// Create new conditional metadata
public fun new_conditional_metadata(
    decimals: u8,
    coin_name_prefix: AsciiString,
    coin_icon_url: Url,
): ConditionalMetadata {
    ConditionalMetadata {
        decimals,
        coin_name_prefix,
        coin_icon_url,
    }
}

/// Getters for ConditionalMetadata fields
public fun conditional_metadata_decimals(meta: &ConditionalMetadata): u8 { meta.decimals }

public fun conditional_metadata_prefix(meta: &ConditionalMetadata): AsciiString {
    meta.coin_name_prefix
}

public fun conditional_metadata_icon(meta: &ConditionalMetadata): Url { meta.coin_icon_url }

/// Create a new quota configuration
public fun new_quota_config(
    enabled: bool,
    default_quota_amount: u64,
    default_quota_period_ms: u64,
    default_reduced_fee: u64,
): QuotaConfig {
    if (enabled) {
        assert!(default_quota_amount > 0, EInvalidQuotaParams);
        assert!(default_quota_period_ms > 0, EInvalidPeriod);
    };
    QuotaConfig {
        enabled,
        default_quota_amount,
        default_quota_period_ms,
        default_reduced_fee,
    }
}

/// Create a new sponsorship configuration
public fun new_sponsorship_config(
    enabled: bool,
    sponsored_threshold: SignedU128,
    waive_advancement_fees: bool,
    default_sponsor_quota_amount: u64,
): SponsorshipConfig {
    if (enabled) {
        assert!(default_sponsor_quota_amount > 0, EInvalidQuotaParams);

        // Protocol-level validation: sponsored_threshold must be ‚â§ 0 and magnitude ‚â§ 5%
        let magnitude = signed::magnitude(&sponsored_threshold);
        let is_negative = signed::is_negative(&sponsored_threshold);

        // Must be zero or negative
        assert!(is_negative || magnitude == 0, ESponsoredThresholdMustBeNonPositive);

        // If negative, magnitude must be ‚â§ 5%
        if (is_negative) {
            assert!(magnitude <= PROTOCOL_MAX_THRESHOLD_NEGATIVE, ESponsoredThresholdExceedsProtocolMax);
        };
    };

    SponsorshipConfig {
        enabled,
        sponsored_threshold,
        waive_advancement_fees,
        default_sponsor_quota_amount,
    }
}


/// Create a complete DAO configuration
public fun new_dao_config(
    trading_params: TradingParams,
    twap_config: TwapConfig,
    governance_config: GovernanceConfig,
    metadata_config: MetadataConfig,
    conditional_coin_config: ConditionalCoinConfig,
    quota_config: QuotaConfig,
    sponsorship_config: SponsorshipConfig,
): DaoConfig {
    DaoConfig {
        trading_params,
        twap_config,
        governance_config,
        metadata_config,
        conditional_coin_config,
        quota_config,
        sponsorship_config,
    }
}

// === Getter Functions ===

// Trading params getters
public fun trading_params(config: &DaoConfig): &TradingParams { &config.trading_params }

public(package) fun trading_params_mut(config: &mut DaoConfig): &mut TradingParams {
    &mut config.trading_params
}

public fun min_asset_amount(params: &TradingParams): u64 { params.min_asset_amount }

public fun min_stable_amount(params: &TradingParams): u64 { params.min_stable_amount }

public fun review_period_ms(params: &TradingParams): u64 { params.review_period_ms }

public fun trading_period_ms(params: &TradingParams): u64 { params.trading_period_ms }

public fun conditional_amm_fee_bps(params: &TradingParams): u64 { params.conditional_amm_fee_bps }

public fun spot_amm_fee_bps(params: &TradingParams): u64 { params.spot_amm_fee_bps }

public fun market_op_review_period_ms(params: &TradingParams): u64 {
    params.market_op_review_period_ms
}

public fun max_amm_swap_percent_bps(params: &TradingParams): u64 { params.max_amm_swap_percent_bps }

public fun conditional_liquidity_ratio_percent(params: &TradingParams): u64 {
    params.conditional_liquidity_ratio_percent
}

// TWAP config getters
public fun twap_config(config: &DaoConfig): &TwapConfig { &config.twap_config }

public(package) fun twap_config_mut(config: &mut DaoConfig): &mut TwapConfig {
    &mut config.twap_config
}

public fun start_delay(twap: &TwapConfig): u64 { twap.start_delay }

public fun step_max(twap: &TwapConfig): u64 { twap.step_max }

public fun initial_observation(twap: &TwapConfig): u128 { twap.initial_observation }

public fun threshold(twap: &TwapConfig): &SignedU128 {
    &twap.threshold
}

// Governance config getters
public fun governance_config(config: &DaoConfig): &GovernanceConfig { &config.governance_config }

public fun governance_config_mut(config: &mut DaoConfig): &mut GovernanceConfig {
    &mut config.governance_config
}

public fun max_outcomes(gov: &GovernanceConfig): u64 { gov.max_outcomes }

public fun max_actions_per_outcome(gov: &GovernanceConfig): u64 { gov.max_actions_per_outcome }

public fun proposal_creation_fee(gov: &GovernanceConfig): u64 { gov.proposal_creation_fee }

public fun proposal_fee_per_outcome(gov: &GovernanceConfig): u64 { gov.proposal_fee_per_outcome }

public fun accept_new_proposals(gov: &GovernanceConfig): bool { gov.accept_new_proposals }

public fun max_intents_per_outcome(gov: &GovernanceConfig): u64 { gov.max_intents_per_outcome }

public fun proposal_intent_expiry_ms(gov: &GovernanceConfig): u64 { gov.proposal_intent_expiry_ms }

public fun enable_premarket_reservation_lock(gov: &GovernanceConfig): bool {
    gov.enable_premarket_reservation_lock
}

public fun show_proposal_details(gov: &GovernanceConfig): bool {
    gov.show_proposal_details
}

// Metadata config getters
public fun metadata_config(config: &DaoConfig): &MetadataConfig { &config.metadata_config }

public(package) fun metadata_config_mut(config: &mut DaoConfig): &mut MetadataConfig {
    &mut config.metadata_config
}

public fun dao_name(meta: &MetadataConfig): &AsciiString { &meta.dao_name }

public fun icon_url(meta: &MetadataConfig): &Url { &meta.icon_url }

public fun description(meta: &MetadataConfig): &String { &meta.description }

// Conditional coin config getters
public fun conditional_coin_config(config: &DaoConfig): &ConditionalCoinConfig {
    &config.conditional_coin_config
}

public(package) fun conditional_coin_config_mut(
    config: &mut DaoConfig,
): &mut ConditionalCoinConfig { &mut config.conditional_coin_config }

public fun use_outcome_index(coin_config: &ConditionalCoinConfig): bool {
    coin_config.use_outcome_index
}

public fun conditional_metadata(coin_config: &ConditionalCoinConfig): &Option<ConditionalMetadata> {
    &coin_config.conditional_metadata
}

/// Get the coin name prefix from conditional metadata (if available)
/// Returns None if no conditional metadata is set
public fun coin_name_prefix(coin_config: &ConditionalCoinConfig): Option<AsciiString> {
    if (coin_config.conditional_metadata.is_some()) {
        option::some(coin_config.conditional_metadata.borrow().coin_name_prefix)
    } else {
        option::none()
    }
}

// ConditionalMetadata getters
public fun conditional_decimals(meta: &ConditionalMetadata): u8 { meta.decimals }

public fun conditional_coin_name_prefix(meta: &ConditionalMetadata): &AsciiString {
    &meta.coin_name_prefix
}

public fun conditional_coin_icon_url(meta: &ConditionalMetadata): &Url { &meta.coin_icon_url }

/// Derive conditional token metadata from base token's CoinMetadata (PREFERRED)
/// Reads decimals, symbol, and icon from the base DAO token and derives conditional token metadata
/// Returns: (decimals, name_prefix, icon_url)
///
/// Example: Base token "MYDAO" ‚Üí Conditional prefix "c_MYDAO_"
public fun derive_conditional_metadata_from_coin<CoinType>(
    metadata: &sui::coin::CoinMetadata<CoinType>,
): (u8, AsciiString, Url) {
    let decimals = metadata.get_decimals();
    let symbol = metadata.get_symbol();
    let icon = metadata.get_icon_url().extract().inner_url();

    // Derive conditional token prefix: c_SYMBOL_
    let prefix_bytes = b"c_";
    let symbol_bytes = symbol.into_bytes();
    let suffix_bytes = b"_";

    let mut combined = vector::empty<u8>();
    vector::append(&mut combined, prefix_bytes);
    vector::append(&mut combined, symbol_bytes);
    vector::append(&mut combined, suffix_bytes);

    (decimals, combined.to_ascii_string(), url::new_unsafe(icon))
}

/// Get conditional token metadata from hardcoded fallback config
/// Use only if CoinMetadata is unavailable/lost to prevent DAO from bricking
/// Returns: (decimals, name_prefix, icon_url)
/// Aborts if no fallback metadata is configured
public fun get_conditional_metadata_from_config(
    coin_config: &ConditionalCoinConfig,
): (u8, AsciiString, Url) {
    assert!(coin_config.conditional_metadata.is_some(), ENoConditionalMetadata);
    let meta = coin_config.conditional_metadata.borrow();
    (meta.decimals, *&meta.coin_name_prefix, *&meta.coin_icon_url)
}

// Quota config getters
public fun quota_config(config: &DaoConfig): &QuotaConfig { &config.quota_config }

public(package) fun quota_config_mut(config: &mut DaoConfig): &mut QuotaConfig {
    &mut config.quota_config
}

public fun quota_enabled(quota: &QuotaConfig): bool { quota.enabled }

public fun default_quota_amount(quota: &QuotaConfig): u64 { quota.default_quota_amount }

public fun default_quota_period_ms(quota: &QuotaConfig): u64 { quota.default_quota_period_ms }

public fun default_reduced_fee(quota: &QuotaConfig): u64 { quota.default_reduced_fee }

// Sponsorship config getters
public fun sponsorship_config(config: &DaoConfig): &SponsorshipConfig { &config.sponsorship_config }

public fun sponsorship_config_mut(config: &mut DaoConfig): &mut SponsorshipConfig {
    &mut config.sponsorship_config
}

public fun sponsorship_enabled(sponsorship: &SponsorshipConfig): bool { sponsorship.enabled }

public fun sponsored_threshold(sponsorship: &SponsorshipConfig): SignedU128 { sponsorship.sponsored_threshold }

public fun waive_advancement_fees(sponsorship: &SponsorshipConfig): bool { sponsorship.waive_advancement_fees }

public fun default_sponsor_quota_amount(sponsorship: &SponsorshipConfig): u64 { sponsorship.default_sponsor_quota_amount }

// === Update Functions ===

// === State Validation Functions ===

/// Check if a config update would cause state inconsistency
/// Returns true if the update is safe, false otherwise
public fun validate_config_update(
    current_config: &DaoConfig,
    new_config: &DaoConfig,
    active_proposals: u64,
): bool {
    let current_gov = governance_config(current_config);
    let new_gov = governance_config(new_config);

    // Check 1: Can't reduce max_outcomes below what existing proposals might have
    // This is a conservative check - in production you'd check actual proposals
    if (max_outcomes(new_gov) < max_outcomes(current_gov)) {
        if (active_proposals > 0) {
            return false // Unsafe to reduce when proposals are active
        }
    };

    // Check 3: Can't reduce max_actions_per_outcome if proposals are active
    if (max_actions_per_outcome(new_gov) < max_actions_per_outcome(current_gov)) {
        if (active_proposals > 0) {
            return false // Unsafe to reduce when proposals are active
        }
    };

    // Check 4: Trading periods must be reasonable
    let new_trading = trading_params(new_config);
    if (review_period_ms(new_trading) == 0 || trading_period_ms(new_trading) == 0) {
        return false
    };

    true
}

// === Direct Field Setters (Package-level) ===
// These functions provide efficient in-place field updates without struct copying

// Trading params direct setters
public(package) fun set_min_asset_amount(params: &mut TradingParams, amount: u64) {
    assert!(amount > 0, EInvalidMinAmount);
    assert!(amount >= PROTOCOL_MIN_LIQUIDITY_AMOUNT, EMinAmountTooLow);
    params.min_asset_amount = amount;
}

public(package) fun set_min_stable_amount(params: &mut TradingParams, amount: u64) {
    assert!(amount > 0, EInvalidMinAmount);
    assert!(amount >= PROTOCOL_MIN_LIQUIDITY_AMOUNT, EMinAmountTooLow);
    params.min_stable_amount = amount;
}

public(package) fun set_review_period_ms(params: &mut TradingParams, period: u64) {
    assert!(period >= constants::min_review_period_ms(), EInvalidPeriod);
    params.review_period_ms = period;
}

public(package) fun set_trading_period_ms(params: &mut TradingParams, period: u64) {
    assert!(period >= constants::min_trading_period_ms(), EInvalidPeriod);
    params.trading_period_ms = period;
}

public(package) fun set_conditional_amm_fee_bps(params: &mut TradingParams, fee_bps: u64) {
    assert!(fee_bps <= constants::max_amm_fee_bps(), EInvalidFee);
    params.conditional_amm_fee_bps = fee_bps;
}

public(package) fun set_spot_amm_fee_bps(params: &mut TradingParams, fee_bps: u64) {
    assert!(fee_bps <= constants::max_amm_fee_bps(), EInvalidFee);
    params.spot_amm_fee_bps = fee_bps;
}

public(package) fun set_market_op_review_period_ms(params: &mut TradingParams, period: u64) {
    // Market op review can be 0 for immediate trading
    // But should not exceed regular review period
    assert!(period <= params.review_period_ms, EInvalidPeriod);
    params.market_op_review_period_ms = period;
}

public(package) fun set_max_amm_swap_percent_bps(params: &mut TradingParams, percent_bps: u64) {
    assert!(percent_bps <= constants::max_fee_bps(), EInvalidFee);
    params.max_amm_swap_percent_bps = percent_bps;
}

public(package) fun set_conditional_liquidity_ratio_percent(
    params: &mut TradingParams,
    ratio_percent: u64,
) {
    // Enforce valid range using configurable constants (base 100: 1-99%)
    assert!(
        ratio_percent >= constants::min_conditional_liquidity_percent() &&
        ratio_percent <= constants::max_conditional_liquidity_percent(),
        EInvalidFee,
    );
    params.conditional_liquidity_ratio_percent = ratio_percent;
}

// TWAP config direct setters
public(package) fun set_start_delay(twap: &mut TwapConfig, delay: u64) {
    // Allow 0 for testing
    twap.start_delay = delay;
}

public(package) fun set_step_max(twap: &mut TwapConfig, max: u64) {
    assert!(max > 0, EInvalidTwapParams);
    twap.step_max = max;
}

public(package) fun set_initial_observation(twap: &mut TwapConfig, obs: u128) {
    assert!(obs > 0, EInvalidTwapParams);
    twap.initial_observation = obs;
}

public(package) fun set_threshold(twap: &mut TwapConfig, threshold: SignedU128) {
    twap.threshold = threshold;
}

// Governance config direct setters
public(package) fun set_max_outcomes(gov: &mut GovernanceConfig, max: u64) {
    assert!(max >= constants::min_outcomes(), EInvalidMaxOutcomes);
    assert!(max <= constants::protocol_max_outcomes(), EMaxOutcomesExceedsProtocol);
    // Note: Caller must ensure no active proposals exceed this limit
    gov.max_outcomes = max;
}

public(package) fun set_max_actions_per_outcome(gov: &mut GovernanceConfig, max: u64) {
    assert!(
        max > 0 && max <= constants::protocol_max_actions_per_outcome(),
        EMaxActionsExceedsProtocol,
    );
    // Note: Caller must ensure no active proposals exceed this limit
    gov.max_actions_per_outcome = max;
}

public fun set_proposal_creation_fee(gov: &mut GovernanceConfig, fee: u64) {
    assert!(fee > 0, EInvalidProposalFee);
    assert!(fee <= MAX_PROPOSAL_CREATION_FEE, EProposalFeeExceedsMax);
    gov.proposal_creation_fee = fee;
}

public fun set_proposal_fee_per_outcome(gov: &mut GovernanceConfig, fee: u64) {
    assert!(fee > 0, EInvalidProposalFee);
    assert!(fee <= MAX_PROPOSAL_FEE_PER_OUTCOME, EProposalFeeExceedsMax);
    gov.proposal_fee_per_outcome = fee;
}

public(package) fun set_accept_new_proposals(gov: &mut GovernanceConfig, accept: bool) {
    gov.accept_new_proposals = accept;
}

public(package) fun set_max_intents_per_outcome(gov: &mut GovernanceConfig, max: u64) {
    assert!(max > 0, EInvalidMaxOutcomes);
    gov.max_intents_per_outcome = max;
}

public(package) fun set_proposal_intent_expiry_ms(gov: &mut GovernanceConfig, period: u64) {
    assert!(period >= constants::min_proposal_intent_expiry_ms(), EInvalidGracePeriod);
    gov.proposal_intent_expiry_ms = period;
}

public(package) fun set_enable_premarket_reservation_lock(
    gov: &mut GovernanceConfig,
    enabled: bool,
) {
    gov.enable_premarket_reservation_lock = enabled;
}

public(package) fun set_show_proposal_details(
    gov: &mut GovernanceConfig,
    show: bool,
) {
    gov.show_proposal_details = show;
}

// Metadata config direct setters
public(package) fun set_dao_name(meta: &mut MetadataConfig, name: AsciiString) {
    meta.dao_name = name;
}

public(package) fun set_icon_url(meta: &mut MetadataConfig, url: Url) {
    meta.icon_url = url;
}

public(package) fun set_description(meta: &mut MetadataConfig, desc: String) {
    meta.description = desc;
}

// Conditional coin config direct setters

public(package) fun set_conditional_metadata(
    coin_config: &mut ConditionalCoinConfig,
    metadata: Option<ConditionalMetadata>,
) {
    coin_config.conditional_metadata = metadata;
}

public(package) fun set_use_outcome_index(
    coin_config: &mut ConditionalCoinConfig,
    use_index: bool,
) {
    coin_config.use_outcome_index = use_index;
}

// Quota config direct setters

public(package) fun set_quota_enabled(quota: &mut QuotaConfig, enabled: bool) {
    quota.enabled = enabled;
}

public(package) fun set_default_quota_amount(quota: &mut QuotaConfig, amount: u64) {
    if (quota.enabled) {
        assert!(amount > 0, EInvalidQuotaParams);
    };
    quota.default_quota_amount = amount;
}

public(package) fun set_default_quota_period_ms(quota: &mut QuotaConfig, period: u64) {
    if (quota.enabled) {
        assert!(period > 0, EInvalidPeriod);
    };
    quota.default_quota_period_ms = period;
}

public(package) fun set_default_reduced_fee(quota: &mut QuotaConfig, fee: u64) {
    quota.default_reduced_fee = fee;
}

// Sponsorship config direct setters

public fun set_sponsorship_enabled(sponsorship: &mut SponsorshipConfig, enabled: bool) {
    sponsorship.enabled = enabled;
}

public fun set_sponsored_threshold(sponsorship: &mut SponsorshipConfig, threshold: SignedU128) {
    // Protocol-level validation: sponsored_threshold must be ‚â§ 0 and magnitude ‚â§ 5%
    let magnitude = signed::magnitude(&threshold);
    let is_negative = signed::is_negative(&threshold);

    // Must be zero or negative
    assert!(is_negative || magnitude == 0, ESponsoredThresholdMustBeNonPositive);

    // If negative, magnitude must be ‚â§ 5%
    if (is_negative) {
        assert!(magnitude <= PROTOCOL_MAX_THRESHOLD_NEGATIVE, ESponsoredThresholdExceedsProtocolMax);
    };

    sponsorship.sponsored_threshold = threshold;
}

public fun set_waive_advancement_fees(sponsorship: &mut SponsorshipConfig, waive: bool) {
    sponsorship.waive_advancement_fees = waive;
}

public fun set_default_sponsor_quota_amount(sponsorship: &mut SponsorshipConfig, amount: u64) {
    if (sponsorship.enabled) {
        assert!(amount > 0, EInvalidQuotaParams);
    };
    sponsorship.default_sponsor_quota_amount = amount;
}

// === String conversion wrapper functions ===

/// Set DAO name from String (converts to AsciiString)
public(package) fun set_dao_name_string(meta: &mut MetadataConfig, name: String) {
    meta.dao_name = string::to_ascii(name);
}

/// Set icon URL from String (creates Url from AsciiString)
public(package) fun set_icon_url_string(meta: &mut MetadataConfig, url_str: String) {
    let ascii_url = string::to_ascii(url_str);
    meta.icon_url = url::new_unsafe(ascii_url);
}

/// Update trading parameters (returns new config)
public fun update_trading_params(config: &DaoConfig, new_params: TradingParams): DaoConfig {
    DaoConfig {
        trading_params: new_params,
        twap_config: config.twap_config,
        governance_config: config.governance_config,
        metadata_config: config.metadata_config,
        conditional_coin_config: config.conditional_coin_config,
        quota_config: config.quota_config,
        sponsorship_config: config.sponsorship_config,
    }
}

/// Update TWAP configuration (returns new config)
public fun update_twap_config(config: &DaoConfig, new_twap: TwapConfig): DaoConfig {
    DaoConfig {
        trading_params: config.trading_params,
        twap_config: new_twap,
        governance_config: config.governance_config,
        metadata_config: config.metadata_config,
        conditional_coin_config: config.conditional_coin_config,
        quota_config: config.quota_config,
        sponsorship_config: config.sponsorship_config,
    }
}

/// Update governance configuration (returns new config)
public fun update_governance_config(config: &DaoConfig, new_gov: GovernanceConfig): DaoConfig {
    DaoConfig {
        trading_params: config.trading_params,
        twap_config: config.twap_config,
        governance_config: new_gov,
        metadata_config: config.metadata_config,
        conditional_coin_config: config.conditional_coin_config,
        quota_config: config.quota_config,
        sponsorship_config: config.sponsorship_config,
    }
}

/// Update metadata configuration (returns new config)
public fun update_metadata_config(config: &DaoConfig, new_meta: MetadataConfig): DaoConfig {
    DaoConfig {
        trading_params: config.trading_params,
        twap_config: config.twap_config,
        governance_config: config.governance_config,
        metadata_config: new_meta,
        conditional_coin_config: config.conditional_coin_config,
        quota_config: config.quota_config,
        sponsorship_config: config.sponsorship_config,
    }
}

/// Update conditional coin configuration (returns new config)
public fun update_conditional_coin_config(
    config: &DaoConfig,
    new_coin_config: ConditionalCoinConfig,
): DaoConfig {
    DaoConfig {
        trading_params: config.trading_params,
        twap_config: config.twap_config,
        governance_config: config.governance_config,
        metadata_config: config.metadata_config,
        conditional_coin_config: new_coin_config,
        quota_config: config.quota_config,
        sponsorship_config: config.sponsorship_config,
    }
}

/// Update quota configuration (returns new config)
public fun update_quota_config(config: &DaoConfig, new_quota: QuotaConfig): DaoConfig {
    DaoConfig {
        trading_params: config.trading_params,
        twap_config: config.twap_config,
        governance_config: config.governance_config,
        metadata_config: config.metadata_config,
        conditional_coin_config: config.conditional_coin_config,
        quota_config: new_quota,
        sponsorship_config: config.sponsorship_config,
    }
}

/// Update sponsorship configuration (returns new config)
public fun update_sponsorship_config(config: &DaoConfig, new_sponsorship: SponsorshipConfig): DaoConfig {
    DaoConfig {
        trading_params: config.trading_params,
        twap_config: config.twap_config,
        governance_config: config.governance_config,
        metadata_config: config.metadata_config,
        conditional_coin_config: config.conditional_coin_config,
        quota_config: config.quota_config,
        sponsorship_config: new_sponsorship,
    }
}

// === Default Configuration ===

/// Get default trading parameters for testing
public fun default_trading_params(): TradingParams {
    TradingParams {
        min_asset_amount: 1000000, // 1 token with 6 decimals
        min_stable_amount: 1000000, // 1 stable with 6 decimals
        review_period_ms: 86400000, // 24 hours
        trading_period_ms: 604800000, // 7 days
        conditional_amm_fee_bps: 30, // 0.3% for conditional markets
        spot_amm_fee_bps: 30, // 0.3% for spot pool
        market_op_review_period_ms: 0, // 0 = immediate (allows atomic market init)
        max_amm_swap_percent_bps: 1000, // 10% max swap per proposal (prevents illiquidity)
        conditional_liquidity_ratio_percent: constants::default_conditional_liquidity_percent(), // 80% to conditional markets (base 100)
    }
}

/// Get default TWAP configuration for testing
public fun default_twap_config(): TwapConfig {
    TwapConfig {
        start_delay: 300000, // 5 minutes
        step_max: 300000, // 5 minutes
        initial_observation: 1000000000000, // Initial price observation
        threshold: signed::from_u64(10), // 10% threshold
    }
}

/// Get default governance configuration for testing
public fun default_governance_config(): GovernanceConfig {
    GovernanceConfig {
        max_outcomes: constants::default_max_outcomes(),
        max_actions_per_outcome: constants::default_max_actions_per_outcome(),
        proposal_creation_fee: 500000, // 0.5 of stable token
        proposal_fee_per_outcome: 1000000, // 1.0 of stable token per outcome
        accept_new_proposals: true,
        max_intents_per_outcome: 10,
        proposal_intent_expiry_ms: constants::default_proposal_intent_expiry_ms(),
        enable_premarket_reservation_lock: true,
        show_proposal_details: false, // Default: false for security
    }
}

/// Get default conditional coin configuration (dynamic mode - derives from base token)
public fun default_conditional_coin_config(): ConditionalCoinConfig {
    ConditionalCoinConfig {
        use_outcome_index: true,
        conditional_metadata: option::none(), // Derive from base DAO token
    }
}

/// Get default quota configuration
public fun default_quota_config(): QuotaConfig {
    QuotaConfig {
        enabled: false, // Opt-in feature
        default_quota_amount: 1, // 1 proposal per period by default
        default_quota_period_ms: 2_592_000_000, // 30 days
        default_reduced_fee: 0, // Free by default
    }
}

/// Get default sponsorship configuration
public fun default_sponsorship_config(): SponsorshipConfig {
    SponsorshipConfig {
        enabled: false, // Opt-in feature
        sponsored_threshold: signed::from_u64(0), // Zero threshold by default
        waive_advancement_fees: false, // Don't waive fees by default
        default_sponsor_quota_amount: 1, // 1 sponsorship per period by default
    }
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Pure configuration struct for Futarchy governance systems
/// This is the configuration object used with Account
/// All dynamic state and object references are stored as dynamic fields on the Account
module futarchy_core::futarchy_config;

use account_protocol::package_registry::PackageRegistry;
use account_protocol::account::{Self, Account};
use account_protocol::deps::{Self, Deps};
use account_protocol::version_witness::VersionWitness;
use futarchy_core::dao_config::{Self, DaoConfig};
use futarchy_core::version;
use futarchy_types::signed::SignedU128;
use std::option::{Self, Option};
use std::string::{Self, String};
use std::type_name;
use sui::clock::Clock;
use sui::dynamic_field as df;
use sui::object::ID;
use sui::tx_context::TxContext;

// === Constants ===

// Operational states
const DAO_STATE_ACTIVE: u8 = 0;      // Normal operation - proposals can be created
const DAO_STATE_TERMINATED: u8 = 1;  // Permanent shutdown - no new proposals (irreversible)

// TWAP scale factor (prices are in 1e12 scale)
const TWAP_SCALE: u128 = 1_000_000_000_000; // 1e12

// Protocol-level threshold bounds: ¬±5% maximum
// This prevents DAOs from setting extreme thresholds that could break markets
const PROTOCOL_MAX_THRESHOLD_POSITIVE: u128 = 50_000_000_000; // +5% (0.05 * 1e12)
const PROTOCOL_MAX_THRESHOLD_NEGATIVE: u128 = 50_000_000_000; // -5% (stored as magnitude)

/// Get the TWAP scale factor (1e12)
public fun twap_scale(): u128 {
    TWAP_SCALE
}

/// Get the protocol maximum positive threshold (+5%)
public fun protocol_max_threshold_positive(): u128 {
    PROTOCOL_MAX_THRESHOLD_POSITIVE
}

/// Get the protocol maximum negative threshold magnitude (5%)
public fun protocol_max_threshold_negative(): u128 {
    PROTOCOL_MAX_THRESHOLD_NEGATIVE
}

// === Errors ===

const ELaunchpadPriceAlreadySet: u64 = 101;
const EThresholdExceedsProtocolMax: u64 = 102;
const EDAOTerminated: u64 = 103; // DAO is terminated, operation not allowed

// === Structs ===

/// Early resolve configuration - per DAO
/// Enables proposals to resolve early when markets reach consensus
///
/// To disable: set min_proposal_duration_ms = max_proposal_duration_ms (no early resolve window)
public struct EarlyResolveConfig has copy, drop, store {
    // Time bounds
    // Range: 0 to u64::MAX milliseconds (must be <= max_proposal_duration_ms)
    min_proposal_duration_ms: u64, // e.g., 43_200_000 (12 hours) - safety floor
    // Range: 0 to u64::MAX milliseconds (must be >= min_proposal_duration_ms)
    max_proposal_duration_ms: u64, // e.g., 172_800_000 (48 hours) - max capital lock
    // Winner stability thresholds - TWAP-based
    // Range: 0 to PROTOCOL_MAX_THRESHOLD_POSITIVE (50_000_000_000 = 5% in 1e12 scale)
    min_winner_spread: u128, // e.g., 50_000_000_000 (5% in 1e12 scale)
    // Range: 0 to u64::MAX milliseconds
    min_time_since_last_flip_ms: u64, // e.g., 14_400_000 (4 hours) - simple stability check
    // NEW: Flip-based stability (window approach)
    // Range: 0 to u64::MAX flips (RECOMMENDED: 1 flip max)
    max_flips_in_window: u64, // e.g., 1 (RECOMMENDED: 1 flip max)
    // Range: 0 to u64::MAX milliseconds
    flip_window_duration_ms: u64, // e.g., 86_400_000 (24 hours)
    // NEW: TWAP-scaled flip tolerance
    // If enabled: Higher TWAP spread = more flip tolerance
    // Formula: effective_max_flips = max_flips_in_window * (current_spread / min_winner_spread)
    // Example: If spread is 30% and min is 5%, allow 6x more flips (1 ‚Üí 6 flips)
    // Categories: true (enable TWAP scaling), false (use fixed flip limit - RECOMMENDED)
    enable_twap_scaling: bool, // RECOMMENDED: false (use fixed flip limit)
    // Keeper incentives
    // Range: 0 to 10000 basis points (0-100%)
    keeper_reward_bps: u64, // e.g., 10 bps (0.1%) of protocol fees
}

/// Pure Futarchy configuration struct
/// All dynamic state and object references are stored on the Account object
public struct FutarchyConfig has copy, drop, store {
    // Type information
    asset_type: String,
    stable_type: String,
    // Core DAO configuration
    config: DaoConfig,
    // Reward configuration (paid from protocol revenue in SUI)
    // Range: 0 to u64::MAX (in SUI smallest units)
    outcome_win_reward: u64, // Reward for winning outcome creator (in SUI, default: 0)
    // Verification configuration
    // Categories: 0 = unverified, 1 = basic, 2 = standard, 3 = premium
    verification_level: u8, // 0 = unverified, 1 = basic, 2 = standard, 3 = premium
    // Range: 0 to u64::MAX (higher = better, admin-set only)
    dao_score: u64, // DAO quality score (0-unlimited, higher = better, admin-set only)
    // Admin review text for verification
    admin_review_text: String, // Admin's review notes/commentary
    // Write-once immutable starting price from launchpad raise
    // Once set to Some(price), can NEVER be changed
    // Used to enforce: 1) AMM initialization ratio, 2) founder reward minimum price
    // Range: None or Some(0 to u128::MAX in 1e12 scale)
    launchpad_initial_price: Option<u128>,
    // Early resolve configuration
    early_resolve_config: EarlyResolveConfig,
}

/// Dynamic state stored on Account via dynamic fields
public struct DaoState has store {
    // Categories: 0 = DAO_STATE_ACTIVE (normal operation), 1 = DAO_STATE_TERMINATED (permanent shutdown)
    operational_state: u8,
    // Range: 0 to u64::MAX
    active_proposals: u64,
    // Range: 0 to u64::MAX
    total_proposals: u64,
    attestation_url: String,
    // Categories: true (verification in progress), false (not pending)
    verification_pending: bool,
    // Dissolution fields (set when DAO terminated)
    // Range: None or Some(0 to u64::MAX milliseconds)
    terminated_at_ms: Option<u64>,  // When DAO was terminated
    // Range: None or Some(0 to u64::MAX milliseconds)
    dissolution_unlock_delay_ms: Option<u64>,  // How long to wait before redemption
    // Categories: true (capability created), false (not yet created)
    dissolution_capability_created: bool,  // Prevent multiple capability creation
}

/// Key for storing DaoState as a dynamic field
public struct DaoStateKey has copy, drop, store {}

/// Key for storing SpotAMM as a dynamic field
public struct SpotAMMKey has copy, drop, store {}

/// Key for storing FeeManager as a dynamic field
public struct FeeManagerKey has copy, drop, store {}

/// Key for storing OperatingAgreement as a dynamic field
public struct OperatingAgreementKey has copy, drop, store {}

/// Key for storing Treasury as a dynamic field
public struct TreasuryKey has copy, drop, store {}

// === Constructors ===

/// Create default early resolve config (disabled by default: min = max)
public fun default_early_resolve_config(): EarlyResolveConfig {
    EarlyResolveConfig {
        min_proposal_duration_ms: 86_400_000, // 24 hours
        max_proposal_duration_ms: 86_400_000, // 24 hours (same = disabled)
        min_winner_spread: 50_000_000_000, // 0.05 (5%)
        min_time_since_last_flip_ms: 14_400_000, // 4 hours
        max_flips_in_window: 1, // RECOMMENDED: 1 flip max
        flip_window_duration_ms: 86_400_000, // 24 hours
        enable_twap_scaling: false, // RECOMMENDED: false (conservative)
        keeper_reward_bps: 10, // 0.1% of fees
    }
}

/// Create custom early resolve config
public fun new_early_resolve_config(
    min_proposal_duration_ms: u64,
    max_proposal_duration_ms: u64,
    min_winner_spread: u128,
    min_time_since_last_flip_ms: u64,
    max_flips_in_window: u64,
    flip_window_duration_ms: u64,
    enable_twap_scaling: bool,
    keeper_reward_bps: u64,
): EarlyResolveConfig {
    EarlyResolveConfig {
        min_proposal_duration_ms,
        max_proposal_duration_ms,
        min_winner_spread,
        min_time_since_last_flip_ms,
        max_flips_in_window,
        flip_window_duration_ms,
        enable_twap_scaling,
        keeper_reward_bps,
    }
}

/// Creates a new pure FutarchyConfig
public fun new<AssetType: drop, StableType: drop>(
    dao_config: DaoConfig,
): FutarchyConfig {
    FutarchyConfig {
        asset_type: type_name::get<AssetType>().into_string().to_string(),
        stable_type: type_name::get<StableType>().into_string().to_string(),
        config: dao_config,
        outcome_win_reward: 0, // No default reward (DAO must configure)
        verification_level: 0, // Unverified by default
        dao_score: 0, // No score by default
        admin_review_text: string::utf8(b""), // Empty by default
        launchpad_initial_price: option::none(), // Not set initially
        early_resolve_config: default_early_resolve_config(), // Disabled by default
    }
}

/// Creates a new DaoState for dynamic storage
public fun new_dao_state(): DaoState {
    DaoState {
        operational_state: DAO_STATE_ACTIVE,
        active_proposals: 0,
        total_proposals: 0,
        attestation_url: b"".to_string(),
        verification_pending: false,
        terminated_at_ms: option::none(),
        dissolution_unlock_delay_ms: option::none(),
        dissolution_capability_created: false,
    }
}

// === Getters for FutarchyConfig ===

public fun asset_type(config: &FutarchyConfig): &String {
    &config.asset_type
}

public fun stable_type(config: &FutarchyConfig): &String {
    &config.stable_type
}

public fun dao_config(config: &FutarchyConfig): &DaoConfig {
    &config.config
}

public fun dao_config_mut(config: &mut FutarchyConfig): &mut DaoConfig {
    &mut config.config
}

public fun outcome_win_reward(config: &FutarchyConfig): u64 {
    config.outcome_win_reward
}

public fun verification_level(config: &FutarchyConfig): u8 {
    config.verification_level
}

public fun dao_score(config: &FutarchyConfig): u64 {
    config.dao_score
}

public fun admin_review_text(config: &FutarchyConfig): &String {
    &config.admin_review_text
}

public fun early_resolve_config(config: &FutarchyConfig): &EarlyResolveConfig {
    &config.early_resolve_config
}

// === Getters for EarlyResolveConfig ===

/// Check if early resolution is enabled (min_duration < max_duration)
public fun early_resolve_enabled(config: &EarlyResolveConfig): bool {
    config.min_proposal_duration_ms < config.max_proposal_duration_ms
}

public fun early_resolve_min_duration(config: &EarlyResolveConfig): u64 {
    config.min_proposal_duration_ms
}

public fun early_resolve_max_duration(config: &EarlyResolveConfig): u64 {
    config.max_proposal_duration_ms
}

public fun early_resolve_min_spread(config: &EarlyResolveConfig): u128 {
    config.min_winner_spread
}

public fun early_resolve_min_time_since_flip(config: &EarlyResolveConfig): u64 {
    config.min_time_since_last_flip_ms
}

public fun early_resolve_keeper_reward_bps(config: &EarlyResolveConfig): u64 {
    config.keeper_reward_bps
}

public fun early_resolve_max_flips_in_window(config: &EarlyResolveConfig): u64 {
    config.max_flips_in_window
}

public fun early_resolve_flip_window_duration(config: &EarlyResolveConfig): u64 {
    config.flip_window_duration_ms
}

public fun early_resolve_twap_scaling_enabled(config: &EarlyResolveConfig): bool {
    config.enable_twap_scaling
}

// === Getters for DaoState ===

public fun operational_state(state: &DaoState): u8 {
    state.operational_state
}

public fun active_proposals(state: &DaoState): u64 {
    state.active_proposals
}

public fun total_proposals(state: &DaoState): u64 {
    state.total_proposals
}

public fun attestation_url(state: &DaoState): &String {
    &state.attestation_url
}

public fun verification_pending(state: &DaoState): bool {
    state.verification_pending
}

/// Check if DAO is operational (can create/accept proposals)
public fun is_operational(state: &DaoState): bool {
    state.operational_state == DAO_STATE_ACTIVE
}

/// Check if DAO is terminated (no new proposals allowed)
public fun is_terminated(state: &DaoState): bool {
    state.operational_state == DAO_STATE_TERMINATED
}

/// Assert DAO is not terminated (use before operations that require active state)
/// Only allows ACTIVE state (rejects TERMINATED state)
public fun assert_not_terminated(state: &DaoState) {
    assert!(state.operational_state == DAO_STATE_ACTIVE, EDAOTerminated);
}

// === Setters for DaoState (mutable) ===

public fun set_operational_state(state: &mut DaoState, new_state: u8) {
    state.operational_state = new_state;
}

/// Set dissolution parameters when terminating DAO
public fun set_dissolution_params(
    state: &mut DaoState,
    terminated_at_ms: u64,
    unlock_delay_ms: u64,
) {
    state.terminated_at_ms = option::some(terminated_at_ms);
    state.dissolution_unlock_delay_ms = option::some(unlock_delay_ms);
}

/// Mark that dissolution capability has been created (one-time flag)
public fun mark_dissolution_capability_created(state: &mut DaoState) {
    state.dissolution_capability_created = true;
}

/// Get dissolution unlock time (terminated_at + delay)
/// Returns none if DAO not terminated
public fun dissolution_unlock_time(state: &DaoState): Option<u64> {
    if (state.terminated_at_ms.is_some() && state.dissolution_unlock_delay_ms.is_some()) {
        let terminated_at = *state.terminated_at_ms.borrow();
        let delay = *state.dissolution_unlock_delay_ms.borrow();
        option::some(terminated_at + delay)
    } else {
        option::none()
    }
}

/// Get termination timestamp
public fun terminated_at(state: &DaoState): Option<u64> {
    state.terminated_at_ms
}

/// Check if dissolution capability has been created
public fun dissolution_capability_created(state: &DaoState): bool {
    state.dissolution_capability_created
}

public fun increment_active_proposals(state: &mut DaoState) {
    state.active_proposals = state.active_proposals + 1;
}

public fun decrement_active_proposals(state: &mut DaoState) {
    assert!(state.active_proposals > 0, 0);
    state.active_proposals = state.active_proposals - 1;
}

public fun increment_total_proposals(state: &mut DaoState) {
    state.total_proposals = state.total_proposals + 1;
}

public fun set_attestation_url(state: &mut DaoState, url: String) {
    state.attestation_url = url;
}

public fun set_verification_pending(state: &mut DaoState, pending: bool) {
    state.verification_pending = pending;
}

public fun set_verification_level(config: &mut FutarchyConfig, level: u8) {
    config.verification_level = level;
}

public fun set_dao_score(config: &mut FutarchyConfig, score: u64) {
    config.dao_score = score;
}

public fun set_admin_review_text(config: &mut FutarchyConfig, review_text: String) {
    config.admin_review_text = review_text;
}

// === FutarchyOutcome Type ===

/// Outcome for futarchy proposals - represents the intent execution metadata
public struct FutarchyOutcome has copy, drop, store {
    // Intent key is the primary identifier - links to the intent in account storage
    intent_key: String,
    // These fields are set when proposal is created/approved
    proposal_id: Option<ID>,
    market_id: Option<ID>,
    // Categories: true (proposal passed/approved), false (not approved)
    approved: bool,
    // Range: 0 to u64::MAX milliseconds (timestamp when execution is allowed)
    min_execution_time: u64,
}

/// Creates a new FutarchyOutcome for intent creation (before proposal exists)
public fun new_futarchy_outcome(intent_key: String, min_execution_time: u64): FutarchyOutcome {
    FutarchyOutcome {
        intent_key,
        proposal_id: option::none(),
        market_id: option::none(),
        approved: false,
        min_execution_time,
    }
}

/// Public constructor for FutarchyOutcome with all fields
public fun new_futarchy_outcome_full(
    intent_key: String,
    proposal_id: Option<ID>,
    market_id: Option<ID>,
    approved: bool,
    min_execution_time: u64,
): FutarchyOutcome {
    FutarchyOutcome {
        intent_key,
        proposal_id,
        market_id,
        approved,
        min_execution_time,
    }
}

/// Updates proposal and market IDs after proposal creation
public fun set_outcome_proposal_and_market(
    outcome: &mut FutarchyOutcome,
    proposal_id: ID,
    market_id: ID,
) {
    outcome.proposal_id = option::some(proposal_id);
    outcome.market_id = option::some(market_id);
}

/// Marks outcome as approved after proposal passes
public fun set_outcome_approved(outcome: &mut FutarchyOutcome, approved: bool) {
    outcome.approved = approved;
}

/// Sets the intent key for an outcome
public fun set_outcome_intent_key(outcome: &mut FutarchyOutcome, intent_key: String) {
    outcome.intent_key = intent_key;
}

/// Gets the minimum execution time
public fun outcome_min_execution_time(outcome: &FutarchyOutcome): u64 {
    outcome.min_execution_time
}

// === Delegated Getters from dao_config ===

public fun review_period_ms(config: &FutarchyConfig): u64 {
    dao_config::review_period_ms(dao_config::trading_params(&config.config))
}

public fun trading_period_ms(config: &FutarchyConfig): u64 {
    dao_config::trading_period_ms(dao_config::trading_params(&config.config))
}

public fun min_asset_amount(config: &FutarchyConfig): u64 {
    dao_config::min_asset_amount(dao_config::trading_params(&config.config))
}

public fun min_stable_amount(config: &FutarchyConfig): u64 {
    dao_config::min_stable_amount(dao_config::trading_params(&config.config))
}

public fun amm_twap_start_delay(config: &FutarchyConfig): u64 {
    dao_config::start_delay(dao_config::twap_config(&config.config))
}

public fun amm_twap_initial_observation(config: &FutarchyConfig): u128 {
    dao_config::initial_observation(dao_config::twap_config(&config.config))
}

public fun amm_twap_step_max(config: &FutarchyConfig): u64 {
    dao_config::step_max(dao_config::twap_config(&config.config))
}

public fun twap_threshold(config: &FutarchyConfig): &SignedU128 {
    dao_config::threshold(dao_config::twap_config(&config.config))
}

public fun conditional_amm_fee_bps(config: &FutarchyConfig): u64 {
    dao_config::conditional_amm_fee_bps(dao_config::trading_params(&config.config))
}

public fun spot_amm_fee_bps(config: &FutarchyConfig): u64 {
    dao_config::spot_amm_fee_bps(dao_config::trading_params(&config.config))
}

public fun amm_total_fee_bps(config: &FutarchyConfig): u64 {
    dao_config::conditional_amm_fee_bps(dao_config::trading_params(&config.config))
}

public fun max_outcomes(config: &FutarchyConfig): u64 {
    dao_config::max_outcomes(dao_config::governance_config(&config.config))
}

public fun enable_premarket_reservation_lock(config: &FutarchyConfig): bool {
    dao_config::enable_premarket_reservation_lock(dao_config::governance_config(&config.config))
}

public fun market_op_review_period_ms(config: &FutarchyConfig): u64 {
    dao_config::market_op_review_period_ms(dao_config::trading_params(&config.config))
}

public fun max_amm_swap_percent_bps(config: &FutarchyConfig): u64 {
    dao_config::max_amm_swap_percent_bps(dao_config::trading_params(&config.config))
}

public fun conditional_liquidity_ratio_percent(config: &FutarchyConfig): u64 {
    dao_config::conditional_liquidity_ratio_percent(dao_config::trading_params(&config.config))
}

/// Create witness for authorized operations
public fun witness(): ConfigWitness {
    ConfigWitness {}
}

/// Get ACTIVE state constant (0)
public fun state_active(): u8 {
    DAO_STATE_ACTIVE
}

/// Get TERMINATED state constant (1)
public fun state_terminated(): u8 {
    DAO_STATE_TERMINATED
}

public fun internal_config_mut(
    account: &mut Account,
    registry: &PackageRegistry,
    version: account_protocol::version_witness::VersionWitness,
): &mut FutarchyConfig {
    account::config_mut<FutarchyConfig, ConfigWitness>(account, registry, version, ConfigWitness {})
}

/// Get mutable access to the DaoState stored as a dynamic field on the Account
/// This requires access to the Account object, not just the FutarchyConfig
public fun state_mut_from_account(account: &mut Account, registry: &PackageRegistry): &mut DaoState {
    account::borrow_managed_data_mut(account, registry, DaoStateKey {}, version::current())
}

/// Witness for internal config operations
public struct ConfigWitness has copy, drop {}

/// Create a DaoStateKey (for use in modules that can't directly instantiate it)
public fun new_dao_state_key(): DaoStateKey {
    DaoStateKey {}
}

public fun set_dao_name(config: &mut FutarchyConfig, name: String) {
    // Get mutable access to the metadata config through the config field
    let metadata_cfg = dao_config::metadata_config_mut(&mut config.config);
    dao_config::set_dao_name_string(metadata_cfg, name);
}

public fun set_icon_url(config: &mut FutarchyConfig, url: String) {
    // Get mutable access to the config field
    let metadata_cfg = dao_config::metadata_config_mut(&mut config.config);
    dao_config::set_icon_url_string(metadata_cfg, url);
}

public fun set_description(config: &mut FutarchyConfig, desc: String) {
    // Get mutable access to the config field
    let metadata_cfg = dao_config::metadata_config_mut(&mut config.config);
    dao_config::set_description(metadata_cfg, desc);
}

public fun set_min_asset_amount(config: &mut FutarchyConfig, amount: u64) {
    let trading_params = dao_config::trading_params_mut(&mut config.config);
    dao_config::set_min_asset_amount(trading_params, amount);
}

public fun set_min_stable_amount(config: &mut FutarchyConfig, amount: u64) {
    let trading_params = dao_config::trading_params_mut(&mut config.config);
    dao_config::set_min_stable_amount(trading_params, amount);
}

public fun set_review_period_ms(config: &mut FutarchyConfig, period: u64) {
    let trading_params = dao_config::trading_params_mut(&mut config.config);
    dao_config::set_review_period_ms(trading_params, period);
}

public fun set_trading_period_ms(config: &mut FutarchyConfig, period: u64) {
    let trading_params = dao_config::trading_params_mut(&mut config.config);
    dao_config::set_trading_period_ms(trading_params, period);
}

public fun set_conditional_amm_fee_bps(config: &mut FutarchyConfig, fee: u16) {
    let trading_params = dao_config::trading_params_mut(&mut config.config);
    dao_config::set_conditional_amm_fee_bps(trading_params, (fee as u64));
}

public fun set_spot_amm_fee_bps(config: &mut FutarchyConfig, fee: u16) {
    let trading_params = dao_config::trading_params_mut(&mut config.config);
    dao_config::set_spot_amm_fee_bps(trading_params, (fee as u64));
}

public fun set_amm_twap_start_delay(config: &mut FutarchyConfig, delay: u64) {
    let twap_cfg = dao_config::twap_config_mut(&mut config.config);
    dao_config::set_start_delay(twap_cfg, delay);
}

public fun set_amm_twap_step_max(config: &mut FutarchyConfig, max: u64) {
    let twap_cfg = dao_config::twap_config_mut(&mut config.config);
    dao_config::set_step_max(twap_cfg, max);
}

public fun set_amm_twap_initial_observation(config: &mut FutarchyConfig, obs: u128) {
    let twap_cfg = dao_config::twap_config_mut(&mut config.config);
    dao_config::set_initial_observation(twap_cfg, obs);
}

public fun set_twap_threshold(config: &mut FutarchyConfig, threshold: SignedU128) {
    use futarchy_types::signed;

    // Protocol-level validation: threshold must be within ¬±5%
    let magnitude = signed::magnitude(&threshold);
    assert!(magnitude <= PROTOCOL_MAX_THRESHOLD_POSITIVE, EThresholdExceedsProtocolMax);

    let twap_cfg = dao_config::twap_config_mut(&mut config.config);
    dao_config::set_threshold(twap_cfg, threshold);
}

public fun set_max_outcomes(config: &mut FutarchyConfig, max: u64) {
    let gov_cfg = dao_config::governance_config_mut(&mut config.config);
    dao_config::set_max_outcomes(gov_cfg, max);
}

public fun set_max_actions_per_outcome(config: &mut FutarchyConfig, max: u64) {
    let gov_cfg = dao_config::governance_config_mut(&mut config.config);
    dao_config::set_max_actions_per_outcome(gov_cfg, max);
}

// Removed: queue_entry_bond field no longer exists in GovernanceConfig
// public fun set_queue_entry_bond(config: &mut FutarchyConfig, amount: u64) {
//     let gov_cfg = dao_config::governance_config_mut(&mut config.config);
//     dao_config::set_queue_entry_bond(gov_cfg, amount);
// }

public fun set_max_intents_per_outcome(config: &mut FutarchyConfig, max: u64) {
    let gov_cfg = dao_config::governance_config_mut(&mut config.config);
    dao_config::set_max_intents_per_outcome(gov_cfg, max);
}

public fun set_proposal_intent_expiry_ms(config: &mut FutarchyConfig, expiry: u64) {
    let gov_cfg = dao_config::governance_config_mut(&mut config.config);
    dao_config::set_proposal_intent_expiry_ms(gov_cfg, expiry);
}

public fun set_proposal_creation_fee(config: &mut FutarchyConfig, fee: u64) {
    let gov_cfg = dao_config::governance_config_mut(&mut config.config);
    dao_config::set_proposal_creation_fee(gov_cfg, fee);
}

public fun set_proposal_fee_per_outcome(config: &mut FutarchyConfig, fee: u64) {
    let gov_cfg = dao_config::governance_config_mut(&mut config.config);
    dao_config::set_proposal_fee_per_outcome(gov_cfg, fee);
}

public fun set_accept_new_proposals(config: &mut FutarchyConfig, accept: bool) {
    let gov_cfg = dao_config::governance_config_mut(&mut config.config);
    dao_config::set_accept_new_proposals(gov_cfg, accept);
}

// Removed: queue_fullness_multiplier_bps field no longer exists in GovernanceConfig
// public fun set_queue_fullness_multiplier_bps(config: &mut FutarchyConfig, points: u64) {
//     let gov_cfg = dao_config::governance_config_mut(&mut config.config);
//     dao_config::set_queue_fullness_multiplier_bps(gov_cfg, points);
// }

public fun set_enable_premarket_reservation_lock(config: &mut FutarchyConfig, enabled: bool) {
    let gov_cfg = dao_config::governance_config_mut(&mut config.config);
    dao_config::set_enable_premarket_reservation_lock(gov_cfg, enabled);
}

public fun set_show_proposal_details(config: &mut FutarchyConfig, show: bool) {
    let gov_cfg = dao_config::governance_config_mut(&mut config.config);
    dao_config::set_show_proposal_details(gov_cfg, show);
}

public fun set_market_op_review_period_ms(config: &mut FutarchyConfig, period: u64) {
    let trading_params = dao_config::trading_params_mut(&mut config.config);
    dao_config::set_market_op_review_period_ms(trading_params, period);
}

public fun set_max_amm_swap_percent_bps(config: &mut FutarchyConfig, percent_bps: u64) {
    let trading_params = dao_config::trading_params_mut(&mut config.config);
    dao_config::set_max_amm_swap_percent_bps(trading_params, percent_bps);
}

public fun set_conditional_liquidity_ratio_percent(
    config: &mut FutarchyConfig,
    ratio_percent: u64,
) {
    let trading_params = dao_config::trading_params_mut(&mut config.config);
    dao_config::set_conditional_liquidity_ratio_percent(trading_params, ratio_percent);
}

public fun set_use_outcome_index(config: &mut FutarchyConfig, use_index: bool) {
    let coin_config = dao_config::conditional_coin_config_mut(&mut config.config);
    dao_config::set_use_outcome_index(coin_config, use_index);
}

public fun set_conditional_metadata(
    config: &mut FutarchyConfig,
    metadata: Option<dao_config::ConditionalMetadata>,
) {
    let coin_config = dao_config::conditional_coin_config_mut(&mut config.config);
    dao_config::set_conditional_metadata(coin_config, metadata);
}

public fun set_early_resolve_config(
    config: &mut FutarchyConfig,
    early_resolve_config: EarlyResolveConfig,
) {
    config.early_resolve_config = early_resolve_config;
}

/// Set proposal enablement state
///
/// IMPORTANT: Disabling proposals when in ACTIVE state moves to TERMINATED.
/// TERMINATED state is IRREVERSIBLE - cannot return to ACTIVE.
///
/// # State Transitions:
/// - ACTIVE + enabled=false  ‚Üí TERMINATED ‚úÖ (one-way door)
/// - TERMINATED + enabled=true ‚Üí NO CHANGE ‚ùå (can't resurrect)
/// - TERMINATED + enabled=false ‚Üí NO CHANGE (already terminated)
public fun set_proposals_enabled(state: &mut DaoState, enabled: bool) {
    if (!enabled && state.operational_state == DAO_STATE_ACTIVE) {
        // One-way transition to terminated state
        state.operational_state = DAO_STATE_TERMINATED;
    }
    // Note: No logic to re-enable from TERMINATED - intentionally irreversible
}

// === Account Creation Functions ===

/// Creates a new account with PackageRegistry validation for use with the Futarchy config
public fun new_with_package_registry(
    registry: &PackageRegistry,
    config: FutarchyConfig,
    ctx: &mut TxContext,
): Account {
    // Create dependencies using PackageRegistry for validation
    // All packages must be registered in the global registry
    let deps = deps::new(registry);

    // Create account with FutarchyConfig using the config witness
    account::new(
        config,
        deps,
        registry,
        version::current(),
        ConfigWitness {},
        ctx,
    )
}

/// Test version that creates account with PackageRegistry
#[test_only]
public fun new_account_test(config: FutarchyConfig, registry: &PackageRegistry, ctx: &mut TxContext): Account {
    // Create dependencies for testing with the actual registry
    let deps = deps::new_for_testing_with_config_and_registry(
        b"futarchy_core".to_string(),
        @futarchy_core,
        registry
    );

    // Create account with FutarchyConfig using the config witness
    account::new(
        config,
        deps,
        registry,
        version::current(),
        ConfigWitness {},
        ctx,
    )
}

/// Get mutable access to internal config for test scenarios
#[test_only]
public fun internal_config_mut_test(account: &mut Account, registry: &PackageRegistry): &mut FutarchyConfig {
    account::config_mut<FutarchyConfig, ConfigWitness>(
        account,
        registry,
        version::current(),
        ConfigWitness {},
    )
}

#[test_only]
/// Create Auth for testing
public fun new_auth_for_testing(
    account: &Account,
    registry: &PackageRegistry,
): account_protocol::account::Auth {
    account::new_auth<FutarchyConfig, ConfigWitness>(
        account,
        registry,
        version::current(),
        ConfigWitness {},
    )
}

/// Create auth witness for this account config
public fun authenticate(account: &Account, ctx: &TxContext): ConfigWitness {
    let _ = account;
    let _ = ctx;
    ConfigWitness {}
}

// === Launchpad Initial Price Functions ===

/// Set the launchpad initial price (WRITE-ONCE, IMMUTABLE after set)
///
/// SECURITY MODEL:
/// - Write-once: Can only be set when launchpad_initial_price is None
/// - Called during DAO initialization by launchpad factory
/// - Once set to Some(price), can NEVER be changed (no governance action exists to modify it)
/// - Prevents manipulation of grant enforcement after DAO creation
///
/// This is the canonical price from the launchpad raise: tokens_for_sale / final_raise_amount
/// Used to enforce: 1) AMM initialization ratio, 2) founder reward minimum price
///
/// @param config - Mutable FutarchyConfig (only accessible during initialization or via internal_config_mut)
/// @param price - Initial launchpad price in 1e12 scale (e.g., $2.00 = 2_000_000_000_000)
public fun set_launchpad_initial_price(config: &mut FutarchyConfig, price: u128) {
    assert!(config.launchpad_initial_price.is_none(), ELaunchpadPriceAlreadySet);
    config.launchpad_initial_price = option::some(price);
}

/// Get the launchpad initial price
/// Returns None if DAO was not created via launchpad or price hasn't been set
public fun get_launchpad_initial_price(config: &FutarchyConfig): Option<u128> {
    config.launchpad_initial_price
}

// === Test-Only Functions ===

#[test_only]
/// Destroy a DaoState object (only for testing)
public fun destroy_dao_state_for_testing(state: DaoState) {
    let DaoState {
        operational_state: _,
        active_proposals: _,
        total_proposals: _,
        attestation_url: _,
        verification_pending: _,
        dissolution_capability_created: _,
        dissolution_unlock_delay_ms: _,
        terminated_at_ms: _,
    } = state;
}

/// Destroy a FutarchyConfig during migration
/// This is called when migrating from FutarchyConfig to a new config type
/// Validates that critical data has been preserved before allowing destruction
///
/// Note: FutarchyConfig has drop ability so this is optional - configs will auto-destruct
/// This function exists for explicit validation and documentation of the migration pattern
public(package) fun destroy_for_migration(config: FutarchyConfig) {
    let FutarchyConfig {
        asset_type: _,
        stable_type: _,
        config: _,
        outcome_win_reward: _,
        verification_level: _,
        dao_score: _,
        admin_review_text: _,
        launchpad_initial_price: _,
        early_resolve_config: _,
    } = config;

    // Could add validation logic here to ensure:
    // - Important fields were preserved in migration
    // - No critical data was lost
    // For now, just allow destruction
}

// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Version tracking for the futarchy package
module futarchy_core::version;

use account_protocol::version_witness::{Self, VersionWitness};

// === Constants ===
const VERSION: u64 = 1;

// === Structs ===
public struct V1() has drop;

// === Public Functions ===

/// Get the current version witness
public fun current(): VersionWitness {
    version_witness::new(V1())
}

/// Get the version number
public fun get(): u64 {
    VERSION
}

// === Test Functions ===

#[test_only]
public struct Witness() has drop;

#[test_only]
public fun witness(): Witness {
    Witness()
}

#[test_only]
/// Get a test version witness for the futarchy package
public fun test_version(): VersionWitness {
    // Create a proper version witness for testing
    version_witness::new(V1())
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

module futarchy_core::resource_requests;

use std::string::{Self, String};
use std::type_name::{Self, TypeName};
use std::vector;
use sui::dynamic_field;
use sui::event;
use sui::object::{Self, ID, UID};
use sui::tx_context::TxContext;

// === Errors ===
const ERequestNotFulfilled: u64 = 1;
const EInvalidRequestID: u64 = 2;
const EResourceTypeMismatch: u64 = 3;
const EAlreadyFulfilled: u64 = 4;
const EInvalidContext: u64 = 5;

// === Events ===

public struct ResourceRequested has copy, drop {
    request_id: ID,
    action_type: TypeName,
    resource_count: u64,
}

public struct ResourceFulfilled has copy, drop {
    request_id: ID,
    action_type: TypeName,
}

// === Core Types ===

/// Generic hot potato for requesting resources - MUST be fulfilled in same transaction
/// The phantom type T represents the action type requesting resources
/// Has no abilities, forcing immediate consumption
#[allow(lint(missing_key))]
public struct ResourceRequest<phantom T> {
    id: UID,
    /// Store any action-specific data needed for fulfillment
    /// Using dynamic fields allows complete flexibility
    context: UID,
}

/// Generic receipt confirming resources were provided
/// Has drop to allow easy cleanup
public struct ResourceReceipt<phantom T> has drop {
    request_id: ID,
}

// === Generic Request Creation ===

/// Create a new resource request with context
/// The phantom type T ensures type safety between request and fulfillment
public fun new_request<T>(ctx: &mut TxContext): ResourceRequest<T> {
    let id = object::new(ctx);
    let context = object::new(ctx);
    let request_id = object::uid_to_inner(&id);

    event::emit(ResourceRequested {
        request_id,
        action_type: type_name::with_defining_ids<T>(),
        resource_count: 0, // Will be determined by what's added to context
    });

    ResourceRequest<T> {
        id,
        context,
    }
}

/// Add context data to a request (can be called multiple times)
/// This allows actions to store any data they need for fulfillment
public fun add_context<T, V: store>(request: &mut ResourceRequest<T>, key: String, value: V) {
    dynamic_field::add(&mut request.context, key, value);
}

/// Get context data from a request
public fun get_context<T, V: store + copy>(request: &ResourceRequest<T>, key: String): V {
    *dynamic_field::borrow(&request.context, key)
}

/// Check if context exists
public fun has_context<T>(request: &ResourceRequest<T>, key: String): bool {
    dynamic_field::exists_(&request.context, key)
}

// === Generic Fulfillment ===

/// Consume a request and return a receipt
/// The actual resource provision happens in the action-specific fulfill function
public fun fulfill<T>(request: ResourceRequest<T>): ResourceReceipt<T> {
    let ResourceRequest { id, context } = request;
    let request_id = object::uid_to_inner(&id);

    event::emit(ResourceFulfilled {
        request_id,
        action_type: type_name::with_defining_ids<T>(),
    });

    // Clean up
    object::delete(id);
    object::delete(context);

    ResourceReceipt<T> {
        request_id,
    }
}

// === Getters ===

public fun request_id<T>(request: &ResourceRequest<T>): ID {
    object::uid_to_inner(&request.id)
}

public fun receipt_id<T>(receipt: &ResourceReceipt<T>): ID {
    receipt.request_id
}

// === Mutable Context Access ===

/// Take context data from a request (for fulfillment)
public fun take_context<T, V: store>(request: &mut ResourceRequest<T>, key: String): V {
    dynamic_field::remove(&mut request.context, key)
}

/// Get mutable context access
public fun context_mut<T>(request: &mut ResourceRequest<T>): &mut UID {
    &mut request.context
}

// === Action-Specific Helpers ===

/// Create a new resource request with an action stored as context
public fun new_resource_request<T: store>(action: T, ctx: &mut TxContext): ResourceRequest<T> {
    let mut request = new_request<T>(ctx);
    add_context(&mut request, string::utf8(b"action"), action);
    request
}

/// Extract the action from a resource request
public fun extract_action<T: store>(mut request: ResourceRequest<T>): T {
    let action = take_context<T, T>(&mut request, string::utf8(b"action"));
    // Clean up the request
    let ResourceRequest { id, context } = request;
    object::delete(id);
    object::delete(context);
    action
}

/// Create a receipt after fulfilling a request with an action
public fun create_receipt<T: drop>(action: T): ResourceReceipt<T> {
    // Drop the action since it's been processed
    let _ = action;

    // Create a dummy receipt (ID doesn't matter since action is dropped)
    ResourceReceipt<T> {
        request_id: object::id_from_address(@0x0),
    }
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Minimal resource handling for intent execution
///
/// PATTERN:
/// 1. Create intent (actions are pure data)
/// 2. At execution: attach Bag of resources to Executable
/// 3. Actions take what they need from the Bag
/// 4. Bag must be empty when execution completes
///
/// This is the ONLY resource pattern you need.
module futarchy_core::executable_resources;

use std::string::String;
use std::type_name;
use sui::bag::{Self, Bag};
use sui::coin::Coin;
use sui::dynamic_field as df;
use sui::object::UID;
use sui::tx_context::TxContext;

// === Errors ===
const EResourceNotFound: u64 = 1;
const EResourcesNotEmpty: u64 = 2;

// === Key for attaching Bag to Executable ===
public struct ResourceBagKey has copy, drop, store {}

// === Resource Management (called by action executors) ===

/// Provision a coin into executable's resource bag
/// Call this before/during execution to provide resources
public fun provide_coin<T, CoinType>(
    executable_uid: &mut UID,
    name: String,
    coin: Coin<CoinType>,
    ctx: &mut TxContext,
) {
    let bag = get_or_create_bag(executable_uid, ctx);
    let key = coin_key<CoinType>(name);
    bag::add(bag, key, coin);
}

/// Take a coin from executable's resource bag
/// Actions call this to get resources they need
public fun take_coin<T, CoinType>(
    executable_uid: &mut UID,
    name: String,
): Coin<CoinType> {
    let bag = borrow_bag_mut(executable_uid);
    let key = coin_key<CoinType>(name);
    assert!(bag::contains(bag, key), EResourceNotFound);
    bag::remove(bag, key)
}

/// Check if a coin resource exists
public fun has_coin<T, CoinType>(
    executable_uid: &UID,
    name: String,
): bool {
    if (!df::exists_(executable_uid, ResourceBagKey {})) return false;
    let bag: &Bag = df::borrow(executable_uid, ResourceBagKey {});
    let key = coin_key<CoinType>(name);
    bag::contains(bag, key)
}

/// Destroy resource bag (must be empty)
/// Call this after execution completes
public fun destroy_resources(executable_uid: &mut UID) {
    if (!df::exists_(executable_uid, ResourceBagKey {})) return;
    let bag: Bag = df::remove(executable_uid, ResourceBagKey {});
    assert!(bag::is_empty(&bag), EResourcesNotEmpty);
    bag::destroy_empty(bag);
}

// === Internal Helpers ===

fun get_or_create_bag(executable_uid: &mut UID, ctx: &mut TxContext): &mut Bag {
    if (!df::exists_(executable_uid, ResourceBagKey {})) {
        let bag = bag::new(ctx);
        df::add(executable_uid, ResourceBagKey {}, bag);
    };
    df::borrow_mut(executable_uid, ResourceBagKey {})
}

fun borrow_bag_mut(executable_uid: &mut UID): &mut Bag {
    df::borrow_mut(executable_uid, ResourceBagKey {})
}

fun coin_key<CoinType>(name: String): String {
    let mut key = name;
    key.append(b"::".to_string());
    key.append(type_name::into_string(type_name::with_defining_ids<CoinType>()).to_string());
    key
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Utilities for conditional tokens:
/// - Validation (treasury cap, supply checks)
/// - Metadata generation and updates for conditional coins
/// - Helper functions for building coin names/symbols
module futarchy_markets_core::conditional_coin_utils;

use futarchy_core::dao_config::ConditionalCoinConfig;
use std::ascii::{Self, String as AsciiString};
use std::string::{Self, String};
use std::vector;
use sui::coin::{Self, TreasuryCap, CoinMetadata};

// === Errors ===
const ESupplyNotZero: u64 = 0;

// === Validation Functions ===

/// Validates that a coin's total supply is zero
public fun assert_zero_supply<T>(treasury_cap: &TreasuryCap<T>) {
    assert!(treasury_cap.total_supply() == 0, ESupplyNotZero);
}

/// Check if supply is zero without aborting
public fun is_supply_zero<T>(treasury_cap: &TreasuryCap<T>): bool {
    treasury_cap.total_supply() == 0
}

// === Metadata Update Functions ===

/// Update conditional CoinMetadata with DAO naming pattern
/// Pattern: c_<outcome_index>_<BASE_SYMBOL>
/// Uses TreasuryCap to update the owned CoinMetadata object
/// Also copies the icon_url from the base metadata
public fun update_conditional_metadata<ConditionalCoinType>(
    treasury_cap: &TreasuryCap<ConditionalCoinType>,
    metadata: &mut CoinMetadata<ConditionalCoinType>,
    coin_config: &ConditionalCoinConfig,
    outcome_index: u64,
    base_coin_name: &String,
    base_coin_symbol: &AsciiString,
    base_icon_url: &AsciiString,
) {
    // Build conditional coin symbol: prefix + outcome_index + _ + base_symbol
    // Example: "c_0_SUI", "c_1_USDC"
    let symbol_ascii = build_conditional_symbol_ascii(coin_config, outcome_index, base_coin_symbol);

    // Build conditional coin name (human-readable)
    // Example: "Conditional 0: Sui", "Conditional 1: USD Coin"
    let name_str = build_conditional_name(outcome_index, base_coin_name);

    // Build description
    let description_str = build_conditional_description(outcome_index, base_coin_name);

    // Update CoinMetadata using old pattern with TreasuryCap
    coin::update_symbol(treasury_cap, metadata, symbol_ascii);
    coin::update_name(treasury_cap, metadata, name_str);
    coin::update_description(treasury_cap, metadata, description_str);

    // Copy icon URL from base currency to conditional coin
    // This ensures conditional coins visually match their base asset/stable
    if (!ascii::is_empty(base_icon_url)) {
        coin::update_icon_url(treasury_cap, metadata, *base_icon_url);
    };
}

// === Helper Functions ===

/// Build conditional coin symbol as ASCII: prefix + outcome_index + _ + base_symbol
/// Example: "c_0_SUI", "c_1_USDC"
/// Returns ASCII string for use with old CoinMetadata pattern
public fun build_conditional_symbol_ascii(
    coin_config: &ConditionalCoinConfig,
    outcome_index: u64,
    base_coin_symbol: &AsciiString,
): AsciiString {
    use futarchy_core::dao_config;

    let mut symbol_bytes = vector::empty<u8>();

    // Add prefix (e.g., "c_") if configured
    let prefix_opt = dao_config::coin_name_prefix(coin_config);
    if (prefix_opt.is_some()) {
        let prefix = prefix_opt.destroy_some();
        let prefix_bytes_val = ascii::as_bytes(&prefix);
        vector::append(&mut symbol_bytes, *prefix_bytes_val);
    } else {
        prefix_opt.destroy_none();
    };

    // Add outcome index if configured
    if (dao_config::use_outcome_index(coin_config)) {
        vector::append(&mut symbol_bytes, u64_to_string(outcome_index));
        vector::push_back(&mut symbol_bytes, 95); // '_' = ASCII 95
    };

    // Add base coin symbol (e.g., "SUI", "USDC")
    let base_bytes = ascii::as_bytes(base_coin_symbol);
    vector::append(&mut symbol_bytes, *base_bytes);

    ascii::string(symbol_bytes)
}

/// Build conditional coin symbol as UTF-8: prefix + outcome_index + _ + base_symbol
/// Example: "c_0_SUI", "c_1_USDC"
/// Returns UTF-8 string for logging/display
public fun build_conditional_symbol(
    coin_config: &ConditionalCoinConfig,
    outcome_index: u64,
    base_coin_symbol: &String,
): String {
    use futarchy_core::dao_config;

    let mut symbol_str = string::utf8(b"");

    // Add prefix (e.g., "c_") if configured
    let prefix_opt = dao_config::coin_name_prefix(coin_config);
    if (prefix_opt.is_some()) {
        let prefix = prefix_opt.destroy_some();
        let prefix_bytes = ascii::as_bytes(&prefix);
        string::append_utf8(&mut symbol_str, *prefix_bytes);
    } else {
        prefix_opt.destroy_none();
    };

    // Add outcome index if configured
    if (dao_config::use_outcome_index(coin_config)) {
        string::append_utf8(&mut symbol_str, u64_to_string(outcome_index));
        string::append_utf8(&mut symbol_str, b"_");
    };

    // Add base coin symbol (e.g., "SUI", "USDC")
    string::append(&mut symbol_str, *base_coin_symbol);

    symbol_str
}

/// Build conditional coin name (human-readable)
/// Example: "Conditional 0: Sui", "Conditional 1: USD Coin"
public fun build_conditional_name(outcome_index: u64, base_coin_name: &String): String {
    let mut name_str = string::utf8(b"Conditional ");
    string::append_utf8(&mut name_str, u64_to_string(outcome_index));
    string::append_utf8(&mut name_str, b": ");
    string::append(&mut name_str, *base_coin_name);
    name_str
}

/// Build conditional coin description
/// Example: "Conditional token for outcome 0 backed by Sui"
public fun build_conditional_description(outcome_index: u64, base_coin_name: &String): String {
    let mut description_str = string::utf8(b"Conditional token for outcome ");
    string::append_utf8(&mut description_str, u64_to_string(outcome_index));
    string::append_utf8(&mut description_str, b" backed by ");
    string::append(&mut description_str, *base_coin_name);
    description_str
}

/// Convert u64 to UTF-8 string (for use in names/descriptions)
public fun u64_to_string(mut num: u64): vector<u8> {
    if (num == 0) {
        return b"0"
    };

    let mut digits = vector::empty<u8>();
    while (num > 0) {
        let digit = ((num % 10) as u8) + 48; // ASCII '0' = 48
        vector::push_back(&mut digits, digit);
        num = num / 10;
    };

    // Reverse digits
    vector::reverse(&mut digits);
    digits
}

/// Convert u64 to ASCII string
public fun u64_to_ascii(mut num: u64): AsciiString {
    if (num == 0) {
        return ascii::string(b"0")
    };

    let mut digits = vector::empty<u8>();
    while (num > 0) {
        let digit = ((num % 10) as u8) + 48; // ASCII '0' = 48
        vector::push_back(&mut digits, digit);
        num = num / 10;
    };

    // Reverse digits
    vector::reverse(&mut digits);
    ascii::string(digits)
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Core swap primitives (building blocks)
///
/// Internal library providing low-level swap functions used by other modules.
/// Users don't call this directly - use swap_entry.move instead.
module futarchy_markets_core::swap_core;

use futarchy_markets_core::proposal::{Self, Proposal};
use futarchy_markets_primitives::coin_escrow::{Self, TokenEscrow};
use futarchy_markets_primitives::conditional_balance;
use sui::clock::Clock;
use sui::coin::Coin;
use sui::object::ID;

// === Introduction ===
// Core swap functions for TreasuryCap-based conditional coins
// Swaps work by: burn input ‚Üí update AMM reserves ‚Üí mint output
//
// Hot potato pattern ensures session validation:
// 1. begin_swap_session() - creates SwapSession hot potato
// 2. swap_*() - validates session, performs swaps
// 3. finalize_swap_session() - consumes hot potato

// === Errors ===
const EInvalidOutcome: u64 = 0;
const EInvalidState: u64 = 3;
const EInsufficientOutput: u64 = 5;
const ESessionMismatch: u64 = 6;
const EProposalMismatch: u64 = 7;

// === Constants ===
const STATE_TRADING: u8 = 2; // Must match proposal.move STATE_TRADING

// === Structs ===

/// Hot potato that enforces session finalization
/// No abilities = must be consumed by finalize_swap_session()
public struct SwapSession {
    market_id: ID, // Track which market this session is for
}

// === Session Management ===

/// Begin a swap session (creates hot potato)
/// Must be called before any swaps in a PTB
///
/// Creates a hot potato that must be consumed by finalize_swap_session().
/// This ensures metrics are updated exactly once after all swaps complete.
public fun begin_swap_session<AssetType, StableType>(
    escrow: &TokenEscrow<AssetType, StableType>,
): SwapSession {
    let market_state = coin_escrow::get_market_state(escrow);
    let market_id = futarchy_markets_primitives::market_state::market_id(market_state);
    SwapSession {
        market_id,
    }
}

/// Finalize swap session (consumes hot potato)
/// Must be called at end of PTB to consume the SwapSession
public fun finalize_swap_session<AssetType, StableType>(
    session: SwapSession,
    escrow: &mut TokenEscrow<AssetType, StableType>,
) {
    let SwapSession { market_id } = session;

    // Validate session matches this market
    let market_state = coin_escrow::get_market_state_mut(escrow);
    let escrow_market_id = futarchy_markets_primitives::market_state::market_id(market_state);
    assert!(market_id == escrow_market_id, ESessionMismatch);
}

// === Core Swap Functions ===

/// Swap conditional asset coins to conditional stable coins
/// Uses TreasuryCap system: burn input ‚Üí AMM calculation ‚Üí mint output
/// Requires valid SwapSession to ensure metrics are updated at end of PTB
public fun swap_asset_to_stable<AssetType, StableType, AssetConditionalCoin, StableConditionalCoin>(
    session: &SwapSession,
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    asset_in: Coin<AssetConditionalCoin>,
    min_amount_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<StableConditionalCoin> {
    assert!(proposal::state(proposal) == STATE_TRADING, EInvalidState);
    assert!(outcome_idx < proposal::outcome_count(proposal), EInvalidOutcome);

    let amount_in = asset_in.value();

    // Step 1: Validate session and market
    {
        let market_state = coin_escrow::get_market_state(escrow); // Immutable borrow
        let market_id = futarchy_markets_primitives::market_state::market_id(market_state);
        assert!(session.market_id == market_id, ESessionMismatch);
    }; // market_state dropped here

    // Step 2: Burn input conditional asset coins
    coin_escrow::burn_conditional_asset<AssetType, StableType, AssetConditionalCoin>(
        escrow,
        outcome_idx,
        asset_in,
    );

    // Step 3: Calculate swap through AMM and update price leaderboard
    let amount_out = {
        let market_state = coin_escrow::get_market_state_mut(escrow);
        let market_id = futarchy_markets_primitives::market_state::market_id(market_state);

        // Execute swap
        let pool = futarchy_markets_primitives::market_state::get_pool_mut_by_outcome(
            market_state,
            (outcome_idx as u8),
        );
        let amount_out = pool.swap_asset_to_stable(
            market_id,
            amount_in,
            min_amount_out,
            clock,
            ctx,
        );

        amount_out
    }; // market_state dropped here

    assert!(amount_out >= min_amount_out, EInsufficientOutput);

    // Step 4: Mint output conditional stable coins
    coin_escrow::mint_conditional_stable<AssetType, StableType, StableConditionalCoin>(
        escrow,
        outcome_idx,
        amount_out,
        ctx,
    )
}

// DELETED: swap_asset_to_stable_entry
// Old entry function - replaced by swap_clean.move functions

/// Swap conditional stable coins to conditional asset coins
/// Requires valid SwapSession to ensure metrics are updated at end of PTB
public fun swap_stable_to_asset<AssetType, StableType, AssetConditionalCoin, StableConditionalCoin>(
    session: &SwapSession,
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    stable_in: Coin<StableConditionalCoin>,
    min_amount_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<AssetConditionalCoin> {
    assert!(proposal::state(proposal) == STATE_TRADING, EInvalidState);
    assert!(outcome_idx < proposal::outcome_count(proposal), EInvalidOutcome);

    let amount_in = stable_in.value();

    // Step 1: Validate session and market
    {
        let market_state = coin_escrow::get_market_state(escrow); // Immutable borrow
        let market_id = futarchy_markets_primitives::market_state::market_id(market_state);
        assert!(session.market_id == market_id, ESessionMismatch);
    }; // market_state dropped here

    // Step 2: Burn input conditional stable coins
    coin_escrow::burn_conditional_stable<AssetType, StableType, StableConditionalCoin>(
        escrow,
        outcome_idx,
        stable_in,
    );

    // Step 3: Calculate swap through AMM and update price leaderboard
    let amount_out = {
        let market_state = coin_escrow::get_market_state_mut(escrow);
        let market_id = futarchy_markets_primitives::market_state::market_id(market_state);

        // Execute swap
        let pool = futarchy_markets_primitives::market_state::get_pool_mut_by_outcome(
            market_state,
            (outcome_idx as u8),
        );
        let amount_out = pool.swap_stable_to_asset(
            market_id,
            amount_in,
            min_amount_out,
            clock,
            ctx,
        );

        amount_out
    }; // market_state dropped here

    assert!(amount_out >= min_amount_out, EInsufficientOutput);

    // Step 4: Mint output conditional asset coins
    coin_escrow::mint_conditional_asset<AssetType, StableType, AssetConditionalCoin>(
        escrow,
        outcome_idx,
        amount_out,
        ctx,
    )
}

// === CONDITIONAL TRADER CONSTRAINTS ===
//
// Conditional traders CANNOT perform cross-market arbitrage without complete sets.
// The quantum liquidity model prevents burning tokens from one outcome and withdrawing
// spot tokens, as this would break the invariant: spot_balance == Cond0_supply == Cond1_supply
//
// Available operations for conditional traders:
// 1. Swap within same outcome: Cond0_Stable ‚Üî Cond0_Asset (using swap_stable_to_asset/swap_asset_to_stable)
// 2. Acquire complete sets: Get tokens from ALL outcomes ‚Üí burn complete set ‚Üí withdraw spot
//
// Cross-market routing requires spot tokens, which conditional traders cannot obtain
// without first acquiring a complete set (tokens from ALL outcomes).
//
// See arbitrage_executor.move for spot trader arbitrage pattern with complete sets.

// === BALANCE-BASED SWAP FUNCTIONS ===
//
// These functions work with ConditionalMarketBalance instead of typed coins.
// This ELIMINATES type explosion - works for ANY outcome count without N type parameters.
//
// Key benefits:
// 1. No type parameters for conditional coins (just AssetType, StableType)
// 2. Works for 2, 3, 4, 5, 200 outcomes without separate modules
// 3. Same swap logic, different input/output handling
//
// Used by: arbitrage with balance tracking, unified swap entry functions

/// Swap from balance: conditional asset ‚Üí conditional stable
///
/// Works for ANY outcome count by operating on balance indices.
/// No conditional coin type parameters needed!
///
/// # Arguments
/// * `balance` - Balance object to update (decreases asset, increases stable)
/// * `outcome_idx` - Which outcome to swap in (0, 1, 2, ...)
/// * `amount_in` - Asset amount to swap
/// * `min_amount_out` - Minimum stable amount to receive (slippage protection)
///
/// # Example
/// ```move
/// // Swap 1000 asset ‚Üí stable in outcome 0 (works for 2, 3, 4, ... outcomes!)
/// swap_balance_asset_to_stable(
///     &session, &mut escrow, &mut balance,
///     0, 1000, 950, &clock, ctx
/// );
/// // Balance updated: outcome 0 asset -1000, outcome 0 stable +~950
/// ```
public fun swap_balance_asset_to_stable<AssetType, StableType>(
    session: &SwapSession,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    balance: &mut conditional_balance::ConditionalMarketBalance<AssetType, StableType>,
    outcome_idx: u8,
    amount_in: u64,
    min_amount_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): u64 {
    // Get market state and validate everything from it
    let market_state = coin_escrow::get_market_state_mut(escrow);
    let market_id = futarchy_markets_primitives::market_state::market_id(market_state);

    // Validate market is active
    futarchy_markets_primitives::market_state::assert_trading_active(market_state);

    // Validate session matches market
    assert!(session.market_id == market_id, ESessionMismatch);

    // CRITICAL SECURITY: Validate balance belongs to this market
    // Prevents exploiting price differences between markets
    assert!(conditional_balance::market_id(balance) == market_id, EProposalMismatch);

    // Validate outcome exists in market
    let market_outcome_count = futarchy_markets_primitives::market_state::outcome_count(market_state);
    assert!((outcome_idx as u64) < market_outcome_count, EInvalidOutcome);

    // Lazy init price leaderboard on first swap (after init actions complete)
    // TODO: Re-enable when price_leaderboard functions are implemented
    // if (!futarchy_markets_primitives::market_state::has_price_leaderboard(market_state)) {
    //     futarchy_markets_primitives::market_state::init_price_leaderboard(market_state, ctx);
    // };

    // Subtract from asset balance (input)
    // Note: sub_from_balance validates balance sufficiency internally
    conditional_balance::sub_from_balance(balance, outcome_idx, true, amount_in);

    // Calculate swap through AMM (reuse market_state and market_id)
    let pool = futarchy_markets_primitives::market_state::get_pool_mut_by_outcome(
        market_state,
        outcome_idx,
    );
    let amount_out = pool.swap_asset_to_stable(
        market_id,
        amount_in,
        min_amount_out,
        clock,
        ctx,
    );

    assert!(amount_out >= min_amount_out, EInsufficientOutput);

    // Update price in leaderboard (O(log N))
    // TODO: Re-enable when price_leaderboard functions are implemented
    // let new_price = pool.get_current_price();
    // futarchy_markets_primitives::market_state::update_price_in_leaderboard(
    //     market_state,
    //     (outcome_idx as u64),
    //     new_price,
    // );

    // Add to stable balance (output)
    conditional_balance::add_to_balance(balance, outcome_idx, false, amount_out);

    amount_out
}

/// Swap from balance: conditional stable ‚Üí conditional asset
///
/// Works for ANY outcome count by operating on balance indices.
/// No conditional coin type parameters needed!
///
/// # Arguments
/// * `balance` - Balance object to update (decreases stable, increases asset)
/// * `outcome_idx` - Which outcome to swap in (0, 1, 2, ...)
/// * `amount_in` - Stable amount to swap
/// * `min_amount_out` - Minimum asset amount to receive (slippage protection)
///
/// # Example
/// ```move
/// // Swap 1000 stable ‚Üí asset in outcome 1 (works for 2, 3, 4, ... outcomes!)
/// swap_balance_stable_to_asset(
///     &session, &mut escrow, &mut balance,
///     1, 1000, 950, &clock, ctx
/// );
/// // Balance updated: outcome 1 stable -1000, outcome 1 asset +~950
/// ```
public fun swap_balance_stable_to_asset<AssetType, StableType>(
    session: &SwapSession,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    balance: &mut conditional_balance::ConditionalMarketBalance<AssetType, StableType>,
    outcome_idx: u8,
    amount_in: u64,
    min_amount_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): u64 {
    // Get market state and validate everything from it
    let market_state = coin_escrow::get_market_state_mut(escrow);
    let market_id = futarchy_markets_primitives::market_state::market_id(market_state);

    // Validate market is active
    futarchy_markets_primitives::market_state::assert_trading_active(market_state);

    // Validate session matches market
    assert!(session.market_id == market_id, ESessionMismatch);

    // CRITICAL SECURITY: Validate balance belongs to this market
    // Prevents exploiting price differences between markets
    assert!(conditional_balance::market_id(balance) == market_id, EProposalMismatch);

    // Validate outcome exists in market
    let market_outcome_count = futarchy_markets_primitives::market_state::outcome_count(market_state);
    assert!((outcome_idx as u64) < market_outcome_count, EInvalidOutcome);

    // Lazy init price leaderboard on first swap (after init actions complete)
    // TODO: Re-enable when price_leaderboard functions are implemented
    // if (!futarchy_markets_primitives::market_state::has_price_leaderboard(market_state)) {
    //     futarchy_markets_primitives::market_state::init_price_leaderboard(market_state, ctx);
    // };

    // Subtract from stable balance (input)
    // Note: sub_from_balance validates balance sufficiency internally
    conditional_balance::sub_from_balance(balance, outcome_idx, false, amount_in);

    // Calculate swap through AMM (reuse market_state and market_id)
    let pool = futarchy_markets_primitives::market_state::get_pool_mut_by_outcome(
        market_state,
        outcome_idx,
    );
    let amount_out = pool.swap_stable_to_asset(
        market_id,
        amount_in,
        min_amount_out,
        clock,
        ctx,
    );

    assert!(amount_out >= min_amount_out, EInsufficientOutput);

    // Update price in leaderboard (O(log N))
    // TODO: Re-enable when price_leaderboard functions are implemented
    // let new_price = pool.get_current_price();
    // futarchy_markets_primitives::market_state::update_price_in_leaderboard(
    //     market_state,
    //     (outcome_idx as u64),
    //     new_price,
    // );

    // Add to asset balance (output)
    conditional_balance::add_to_balance(balance, outcome_idx, true, amount_out);

    amount_out
}

// === Test Helpers ===

#[test_only]
/// Create a test swap session for testing
public fun create_test_swap_session(market_id: ID): SwapSession {
    SwapSession { market_id }
}

#[test_only]
/// Destroy a swap session for testing
public fun destroy_test_swap_session(session: SwapSession) {
    let SwapSession { market_id: _ } = session;
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

module futarchy_markets_core::liquidity_initialize;

use futarchy_markets_primitives::coin_escrow::TokenEscrow;
use futarchy_markets_primitives::conditional_amm::{Self, LiquidityPool};
use sui::balance::Balance;
use sui::clock::Clock;

// === Introduction ===
// Method to initialize AMM liquidity using TreasuryCap-based conditional coins
// Assumes TreasuryCaps have been registered with escrow before calling this

// === Errors ===
const EInitAssetReservesMismatch: u64 = 100;
const EInitStableReservesMismatch: u64 = 101;
const EInitPoolCountMismatch: u64 = 102;
const EInitPoolOutcomeMismatch: u64 = 103;
const EInitZeroLiquidity: u64 = 104;
const ECapsNotRegistered: u64 = 105;

// === Public Functions ===
/// Create outcome markets using TreasuryCap-based conditional coins
/// IMPORTANT: TreasuryCaps must be registered with escrow BEFORE calling this function
/// The caller (PTB) must have called register_conditional_caps() N times before this
public fun create_outcome_markets<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_count: u64,
    asset_amounts: vector<u64>,
    stable_amounts: vector<u64>,
    twap_start_delay: u64,
    twap_initial_observation: u128,
    twap_step_max: u64,
    amm_total_fee_bps: u64,
    initial_asset: Balance<AssetType>,
    initial_stable: Balance<StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
): vector<LiquidityPool> {
    assert!(asset_amounts.length() == outcome_count, EInitAssetReservesMismatch);
    assert!(stable_amounts.length() == outcome_count, EInitStableReservesMismatch);

    // Validate that all amounts are non-zero to prevent division by zero in AMM calculations
    let mut j = 0;
    while (j < outcome_count) {
        assert!(asset_amounts[j] > 0, EInitZeroLiquidity);
        assert!(stable_amounts[j] > 0, EInitZeroLiquidity);
        j = j + 1;
    };

    let mut amm_pools = vector[];

    // 1. Deposit spot liquidity into escrow (quantum liquidity model)
    escrow.deposit_spot_liquidity(initial_asset, initial_stable);

    // 2. Create AMM pools for each outcome
    let mut i = 0;
    while (i < outcome_count) {
        let asset_amt = asset_amounts[i];
        let stable_amt = stable_amounts[i];

        let ms = escrow.get_market_state();
        let market_id = futarchy_markets_primitives::market_state::market_id(ms);
        let pool = conditional_amm::new_pool(
            market_id,
            (i as u8),
            amm_total_fee_bps,
            asset_amt,
            stable_amt,
            twap_initial_observation,
            twap_start_delay,
            twap_step_max,
            clock,
            ctx,
        );
        amm_pools.push_back(pool);

        i = i + 1;
    };

    amm_pools
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// ============================================================================
/// DETERMINISTIC RNG FOR PROPERTY-BASED TESTING
/// ============================================================================
///
/// A simple Linear Congruential Generator (LCG) for reproducible fuzzing.
/// This is NOT cryptographically secure - only for deterministic test generation.
///
/// **Why not use Sui's native randomness?**
/// - Sui's `Random` object is great for on-chain apps
/// - But for unit tests we need DETERMINISTIC, REPRODUCIBLE results
/// - This LCG ensures tests pass/fail consistently across runs
///
/// ============================================================================

#[test_only]
module futarchy_markets_core::rng;

/// 64-bit LCG state (uses u128 arithmetic internally to avoid overflow)
public struct Rng has copy, drop {
    state: u64,
}

/// Create a new RNG with deterministic seed
/// Same seed always produces same sequence (reproducible tests)
public fun seed(seed_hi: u64, seed_lo: u64): Rng {
    // Combine seeds with XOR to create single u64 state
    Rng {
        state: seed_hi ^ seed_lo,
    }
}

/// Generate next random u64
/// Uses LCG with u128 arithmetic to prevent overflow, then truncates to u64
public fun next_u64(r: &mut Rng): u64 {
    // LCG constants from glibc (a = 1103515245, c = 12345)
    // Do arithmetic in u128 to avoid overflow, then mod 2^64
    let state_u128 = (r.state as u128);
    let next_u128 = state_u128 * 1103515245u128 + 12345u128;

    // Truncate to u64 by taking mod 2^64
    // Use bitwise AND to extract lower 64 bits (guaranteed to fit in u64)
    let truncated = next_u128 & 0xFFFFFFFFFFFFFFFF;
    let next_u64 = (truncated as u64);
    r.state = next_u64;
    next_u64
}

/// Generate random u64 in range [lo, hi_inclusive]
public fun next_range(r: &mut Rng, lo: u64, hi_inclusive: u64): u64 {
    if (hi_inclusive <= lo) return lo;
    let span = hi_inclusive - lo + 1;
    lo + (next_u64(r) % span)
}

/// Bernoulli trial with probability p (in basis points [0, 10000])
/// Returns true with probability p/10000
public fun coin(r: &mut Rng, p_bps: u64): bool {
    (next_u64(r) % 10000) < p_bps
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// ============================================================================
/// N-OUTCOME ARBITRAGE MATH - EFFICIENT B-PARAMETERIZATION
/// ============================================================================
///
/// IMPROVEMENTS IMPLEMENTED:
/// ‚úÖ 1. B-parameterization - No square roots, cleaner math
/// ‚úÖ 2. Early exit checks - BOTH directions optimized
/// ‚úÖ 3. Bidirectional solving - Catches all opportunities
/// ‚úÖ 4. Min profit threshold - Simple profitability check
/// ‚úÖ 5. u256 arithmetic - Accurate overflow-free calculations
/// ‚úÖ 6. Ternary search precision - max(1%, MIN_COARSE_THRESHOLD) to prevent infinite loops
/// ‚úÖ 7. Concavity proof - F(b) is strictly concave, ternary search is optimal
/// ‚úÖ 8. Smart bounding - 95%+ gas reduction via 1.1x user swap hint
///
/// SMART BOUNDING INSIGHT:
/// The optimization is mathematically correct because the max arbitrage opportunity
/// ‚â§ the swap that created it! User swaps 1,000 tokens ‚Üí search [0, 1,100] not [0, 10^18].
/// This is not an approximation - it's exact search in a tighter, correct bound.
///
/// ‚ö†Ô∏è CRITICAL: TERNARY SEARCH INFINITE LOOP PREVENTION ‚ö†Ô∏è
///
/// **MATHEMATICAL PROOF OF INSTABILITY:**
///
/// Ternary search uses integer division: third = (right - left) / 3
///
/// When coarse_threshold < 3, the loop can enter an infinite loop:
///
///   while (right - left > threshold) {
///       let third = (right - left) / 3;
///       let m1 = left + third;
///       let m2 = right - third;
///       // ... update left or right
///   }
///
/// **Case 1: threshold = 1**
///   Loop continues when right - left = 2
///   ‚Üí third = 2 / 3 = 0 (integer division rounds down!)
///   ‚Üí m1 = left + 0 = left
///   ‚Üí m2 = right - 0 = right
///   ‚Üí Loop never updates left or right ‚Üí INFINITE LOOP ‚Üí TIMEOUT
///
/// **Case 2: threshold = 2** (MINIMUM SAFE)
///   Loop continues when right - left = 3, 4, 5...
///   ‚Üí third = 3 / 3 = 1 (minimum)
///   ‚Üí third ‚â• 1 for all iterations
///   ‚Üí Loop always makes progress
///   ‚úÖ SAFE (mathematical minimum)
///
/// **Case 3: threshold = 3** (MINIMUM SAFE + 50% SAFETY MARGIN)
///   Loop continues when right - left = 4, 5, 6...
///   ‚Üí third ‚â• 1 for all iterations
///   ‚Üí 50% buffer over mathematical minimum
///   ‚úÖ ENGINEERING SAFE
///
/// **Our Choice: threshold = 3**
///   - Mathematical minimum is 2 (proven safe by feedback)
///   - We use 3 for 50% engineering safety margin
///   - 3.3x better precision than threshold=10 for small pools
///   - Negligible gas cost difference (< 0.01%)
///
/// **Defense in Depth: Two Layers of Safety**
///   Layer 1: Threshold = 3 (prevents loop from running when gap ‚â§ 3)
///   Layer 2: Ceiling division (guarantees progress even if Layer 1 is bypassed)
///
///   Why both?
///   - Threshold=3: Efficiency + safety margin over mathematical minimum (2)
///   - Ceiling division: Future-proof against accidental threshold changes
///   - Together: Termination guaranteed both by policy (threshold) and math (ceiling)
///   - Cost: One addition per iteration (~0.0001% gas), zero behavior change
///   - Audit benefit: Two independent proofs of termination
///
/// **Tests validating this:**
/// - test_ternary_search_stability() - Verifies small search spaces don't timeout
/// - test_worst_case_tiny_search_space() - Tests threshold behavior at boundaries
///
/// ============================================================================
///
/// ARCHITECTURAL NOTE (For Auditors):
/// Spot‚ÜíConditional and Conditional‚ÜíSpot have different implementations by design:
/// - Spot‚ÜíCond: Uses T,A,B parameterization (bottleneck = max_i constraint)
/// - Cond‚ÜíSpot: Direct calculation (must buy from ALL pools = max_i constraint due to quantum liquidity)
/// Both use MAX semantics (not sum) because splitting base USDC creates ALL conditional types simultaneously.
/// This is NOT duplication - it reflects fundamentally different mathematical structures.
/// The ternary search pattern IS duplicated (~40 lines) because Move lacks closures.
///
/// MATH FOUNDATION:
///
/// Instead of searching for optimal input x, we search for optimal output b.
/// For constant product AMMs with quantum liquidity constraint:
///
/// x(b) = max_i [b √ó A_i / (T_i - b √ó B_i)]  (no square root!)
/// F(b) = b - x(b)                            (profit function)
///
/// Where:
///   T_i = (R_i_stable √ó Œ±_i) √ó (R_spot_asset √ó Œ≤)
///   A_i = R_i_asset √ó R_spot_stable
///   B_i = Œ≤ √ó (R_i_asset + Œ±_i √ó R_spot_asset)
///
/// Domain: b ‚àà [0, U_b) where U_b = min_i(T_i/B_i)
///
/// ============================================================================

module futarchy_markets_core::arbitrage_math;

use futarchy_markets_core::unified_spot_pool::{Self, UnifiedSpotPool};
use futarchy_markets_primitives::conditional_amm::{Self, LiquidityPool};
use futarchy_one_shot_utils::constants;
use futarchy_one_shot_utils::math;

// === Errors ===
const ETooManyConditionals: u64 = 0;
const EInvalidFee: u64 = 1;

// === Constants ===
// MAX_CONDITIONALS coupled with protocol_max_outcomes - ensures consistency across futarchy system
const BPS_SCALE: u64 = 10000; // Basis points scale
const SMART_BOUND_MARGIN_NUM: u64 = 11; // Smart bound = 1.1x user swap (110%)
const SMART_BOUND_MARGIN_DENOM: u64 = 10;
const TERNARY_SEARCH_DIVISOR: u64 = 100; // Search to 1% of space (or MIN_COARSE_THRESHOLD min)

/// Minimum safe threshold for ternary search to prevent infinite loops.
///
/// **Mathematical Requirement:** threshold ‚â• 2
/// - When threshold = 1, loop can continue with right-left=2
/// - Then third = 2/3 = 0 (integer division) ‚Üí infinite loop
/// - When threshold ‚â• 2, loop only runs when right-left ‚â• 3
/// - Then third = 3/3 = 1 (minimum progress guaranteed)
///
/// **Our Choice:** 3 (minimum safe + 50% engineering safety margin)
/// - Provides 3.3x better precision than threshold=10 for small pools
/// - Example: 500 SUI pool ‚Üí ¬±2 SUI precision (vs ¬±10 SUI with threshold=10)
/// - Negligible gas cost: ~3 extra iterations max (< 0.01% total gas)
const MIN_COARSE_THRESHOLD: u64 = 3;

// Gas cost estimates (with smart bounding):
//   N=10:   ~3k gas   ‚úÖ Instant
//   N=50:   ~8k gas   ‚úÖ Very fast (protocol limit)
//
// Protocol limit: N=50 (constants::protocol_max_outcomes)
// Complexity: O(log(1.1*user_swap) √ó N) from ternary search
// Smart bounding reduces search space by 95%+

// === Public API ===

/// **PRIMARY N-OUTCOME FUNCTION** - Compute optimal arbitrage after user swap
/// Returns (optimal_amount, expected_profit, is_spot_to_cond)
///
/// **SMART BOUNDING OPTIMIZATION**:
/// Uses user's swap output as upper bound (1.1x for safety margin).
/// Key insight: Max arbitrage ‚â§ swap that created the imbalance!
/// Searches [0, min(1.1 * user_output, upper_bound_b)] instead of [0, 10^18].
///
/// **Why This Works**:
/// User swap creates the imbalance - you can't extract more arbitrage than
/// the imbalance size. No meaningful trade-off, massive gas savings.
///
/// **Algorithm**:
/// 1. Spot ‚Üí Conditional: Buy from spot, sell to ALL conditionals, burn complete set
/// 2. Conditional ‚Üí Spot: Buy from ALL conditionals, recombine, sell to spot
/// 3. Compare profits, return better direction
///
/// **Performance**: O(log(1.1*user_output) √ó N) = ~95%+ gas reduction vs global search
public fun compute_optimal_arbitrage_for_n_outcomes<AssetType, StableType>(
    spot: &UnifiedSpotPool<AssetType, StableType>,
    conditionals: &vector<LiquidityPool>,
    user_swap_output: u64, // Hint from user's swap (0 = use global bound)
    min_profit: u64,
): (u64, u128, bool) {
    // Validate outcome count
    let outcome_count = vector::length(conditionals);
    if (outcome_count == 0) return (0, 0, false);

    assert!(outcome_count <= constants::protocol_max_outcomes(), ETooManyConditionals);

    // Try Spot ‚Üí Conditional arbitrage
    let (x_stc, profit_stc) = compute_optimal_spot_to_conditional(
        spot,
        conditionals,
        user_swap_output,
        min_profit,
    );

    // Try Conditional ‚Üí Spot arbitrage
    let (x_cts, profit_cts) = compute_optimal_conditional_to_spot(
        spot,
        conditionals,
        user_swap_output,
        min_profit,
    );

    // Return more profitable direction
    if (profit_stc >= profit_cts) {
        (x_stc, profit_stc, true) // Spot ‚Üí Conditional
    } else {
        (x_cts, profit_cts, false) // Conditional ‚Üí Spot
    }
}

/// Compute optimal Spot ‚Üí Conditional arbitrage with smart bounding
public fun compute_optimal_spot_to_conditional<AssetType, StableType>(
    spot: &UnifiedSpotPool<AssetType, StableType>,
    conditionals: &vector<LiquidityPool>,
    user_swap_output: u64, // Hint: 0 = use global bound
    min_profit: u64,
): (u64, u128) {
    let num_conditionals = vector::length(conditionals);
    if (num_conditionals == 0) return (0, 0);

    assert!(num_conditionals <= constants::protocol_max_outcomes(), ETooManyConditionals);

    // Check for zero liquidity in any conditional pool (early rejection)
    let mut i = 0;
    while (i < num_conditionals) {
        let conditional = vector::borrow(conditionals, i);
        let (cond_asset, cond_stable) = conditional_amm::get_reserves(conditional);
        if (cond_asset == 0 || cond_stable == 0) {
            return (0, 0) // Zero liquidity makes arbitrage impossible
        };
        i = i + 1;
    };

    // Get spot reserves and fee
    let (spot_asset, spot_stable) = unified_spot_pool::get_reserves(spot);
    if (spot_asset == 0 || spot_stable == 0) {
        return (0, 0) // Zero liquidity in spot makes arbitrage impossible
    };
    let spot_fee_bps = unified_spot_pool::get_fee_bps(spot);

    // Build T, A, B constants
    let (ts, as_vals, bs) = build_tab_constants(
        spot_asset,
        spot_stable,
        spot_fee_bps,
        conditionals,
    );

    // Early exit - check if arbitrage is obviously impossible
    if (early_exit_check_spot_to_cond(&ts, &as_vals)) {
        return (0, 0)
    };

    // Smart bounding (95%+ gas reduction)
    let global_ub = upper_bound_b(&ts, &bs);
    let smart_bound = if (user_swap_output == 0) {
        global_ub
    } else {
        let hint_u128 =
            (user_swap_output as u128) * (SMART_BOUND_MARGIN_NUM as u128) / (SMART_BOUND_MARGIN_DENOM as u128);
        let hint_u64 = if (hint_u128 > (std::u64::max_value!() as u128)) {
            std::u64::max_value!()
        } else {
            (hint_u128 as u64)
        };
        global_ub.min(hint_u64)
    };

    // B-parameterization ternary search (F(b) is concave)
    let (b_star, profit) = optimal_b_search_bounded(
        &ts,
        &as_vals,
        &bs,
        smart_bound,
    );

    // Check min profit threshold
    if (profit < (min_profit as u128)) {
        return (0, 0)
    };

    // Convert b* to x* (input amount needed)
    let x_star = x_required_for_b(&ts, &as_vals, &bs, b_star);

    (x_star, profit)
}

/// Compute optimal Conditional ‚Üí Spot arbitrage with smart bounding
public fun compute_optimal_conditional_to_spot<AssetType, StableType>(
    spot: &UnifiedSpotPool<AssetType, StableType>,
    conditionals: &vector<LiquidityPool>,
    user_swap_output: u64, // Hint: 0 = use global bound
    min_profit: u64,
): (u64, u128) {
    let num_conditionals = vector::length(conditionals);
    if (num_conditionals == 0) return (0, 0);

    assert!(num_conditionals <= constants::protocol_max_outcomes(), ETooManyConditionals);

    // Check for zero liquidity in any conditional pool (early rejection)
    let mut i = 0;
    while (i < num_conditionals) {
        let conditional = vector::borrow(conditionals, i);
        let (cond_asset, cond_stable) = conditional_amm::get_reserves(conditional);
        if (cond_asset == 0 || cond_stable == 0) {
            return (0, 0) // Zero liquidity makes arbitrage impossible
        };
        i = i + 1;
    };

    // Get spot reserves and fee
    let (spot_asset, spot_stable) = unified_spot_pool::get_reserves(spot);
    if (spot_asset == 0 || spot_stable == 0) {
        return (0, 0) // Zero liquidity in spot makes arbitrage impossible
    };
    let spot_fee_bps = unified_spot_pool::get_fee_bps(spot);

    // FIX: Validate fee to prevent underflow in beta calculation
    assert!(spot_fee_bps <= BPS_SCALE, EInvalidFee);
    let beta = BPS_SCALE - spot_fee_bps;

    // OPTIMIZATION 1: Early exit check - compare derivatives at b=0
    // F'(0) = S'(0) - C'(0) where:
    // S'(0) = (R_spot_stable * Œ≤) / (R_spot_asset * BPS_SCALE)
    // C'(0) = max_i(c'_i(0)) where c'_i(0) = (R_i_stable * BPS_SCALE) / (R_i_asset * Œ±_i)
    // Need F'(0) > 0 for profit to exist [quantum liquidity uses MAX not SUM]
    if (early_exit_check_cond_to_spot(spot_asset, spot_stable, beta, conditionals)) {
        return (0, 0)
    };

    // Find smallest conditional reserve (for global upper bound)
    let mut global_ub = std::u64::max_value!();
    let mut i = 0;
    while (i < num_conditionals) {
        let conditional = vector::borrow(conditionals, i);
        let (cond_asset, _cond_stable) = conditional_amm::get_reserves(conditional);
        if (cond_asset < global_ub) {
            global_ub = cond_asset;
        };
        i = i + 1;
    };

    // Need reasonable liquidity for arbitrage
    if (global_ub < 2) return (0, 0);

    // Use global_ub - 1 to stay just inside boundary (avoid asymptote)
    global_ub = global_ub - 1;

    // Smart bounding (95%+ gas reduction)
    let smart_bound = if (user_swap_output == 0) {
        global_ub
    } else {
        let hint_u128 =
            (user_swap_output as u128) * (SMART_BOUND_MARGIN_NUM as u128) / (SMART_BOUND_MARGIN_DENOM as u128);
        let hint_u64 = if (hint_u128 > (std::u64::max_value!() as u128)) {
            std::u64::max_value!()
        } else {
            (hint_u128 as u64)
        };
        global_ub.min(hint_u64)
    };

    // Ternary search for optimal b (F(b) is concave, single peak)
    let mut best_b = 0u64;
    let mut best_profit = 0u128;
    let mut left = 0u64;
    let mut right = smart_bound;

    // FIX B2 (Precision): Guarantee convergence to unit precision by setting fixed threshold.
    // Defense in depth Layer 1: threshold=3 prevents loop when gap ‚â§ 3
    // Defense in depth Layer 2: ceiling division guarantees progress if Layer 1 bypassed
    let final_threshold = MIN_COARSE_THRESHOLD;

    while (right - left > final_threshold) {
        // Layer 2: Ceiling division guarantees third ‚â• 1 for any positive gap
        // ceil(gap/3) = (gap + 2) / 3, mathematically ensures loop always makes progress
        // Layer 1 (threshold=3) prevents this from ever being needed, but Layer 2 is bulletproof
        let gap = right - left;
        let third = (gap + 2) / 3; // Ceiling division
        let m1 = left + third;
        let m2 = right - third;

        let profit_m1 = profit_conditional_to_spot(
            spot_asset,
            spot_stable,
            beta,
            conditionals,
            m1,
        );
        let profit_m2 = profit_conditional_to_spot(
            spot_asset,
            spot_stable,
            beta,
            conditionals,
            m2,
        );

        // Track best seen
        if (profit_m1 > best_profit) {
            best_profit = profit_m1;
            best_b = m1;
        };
        if (profit_m2 > best_profit) {
            best_profit = profit_m2;
            best_b = m2;
        };

        if (profit_m1 >= profit_m2) {
            right = m2;
        } else {
            left = m1;
        }
    };

    // Final endpoint check
    let profit_left = profit_conditional_to_spot(
        spot_asset,
        spot_stable,
        beta,
        conditionals,
        left,
    );
    if (profit_left > best_profit) {
        best_profit = profit_left;
        best_b = left;
    };

    let profit_right = profit_conditional_to_spot(
        spot_asset,
        spot_stable,
        beta,
        conditionals,
        right,
    );
    if (profit_right > best_profit) {
        best_profit = profit_right;
        best_b = right;
    };

    // Check min profit threshold
    if (best_profit < (min_profit as u128)) {
        return (0, 0)
    };

    (best_b, best_profit)
}

/// Original x-parameterization interface (for compatibility)
/// Now uses b-parameterization with smart bounding internally
/// spot_swap_is_stable_to_asset: true if spot swap is stable‚Üíasset, false if asset‚Üístable
public fun compute_optimal_spot_arbitrage<AssetType, StableType>(
    spot: &UnifiedSpotPool<AssetType, StableType>,
    conditionals: &vector<LiquidityPool>,
    spot_swap_is_stable_to_asset: bool,
): (u64, u128) {
    // Use new bidirectional solver with 0 min_profit and no hint (global search)
    let (amount, profit, is_spot_to_cond) = compute_optimal_arbitrage_for_n_outcomes(
        spot,
        conditionals,
        0, // No user_swap_output hint: use global bound
        0, // No min profit for compatibility
    );

    // Return based on direction match
    if (spot_swap_is_stable_to_asset == is_spot_to_cond) {
        (amount, profit)
    } else {
        (0, 0) // Direction mismatch
    }
}

// === Core B-Parameterization Functions ===

/// Find optimal b using ternary search with smart bounding
/// F(b) = b - x(b) is concave (single peak) since x(b) = max of convex functions
/// Ternary search converges to 0.01% of search space - high precision for concave functions
fun optimal_b_search_bounded(
    ts: &vector<u128>,
    as_vals: &vector<u128>,
    bs: &vector<u128>,
    upper_bound: u64, // Smart bound: 1.1x user swap or global bound
): (u64, u128) {
    let n = vector::length(ts);
    if (n == 0) return (0, 0);
    if (upper_bound == 0) return (0, 0);

    let mut best_b = 0u64;
    let mut best_profit = 0u128;
    let mut left = 0u64;
    let mut right = upper_bound;

    // FIX B2 (Precision): Guarantee convergence to unit precision by setting fixed threshold.
    // Defense in depth Layer 1: threshold=3 prevents loop when gap ‚â§ 3
    // Defense in depth Layer 2: ceiling division guarantees progress if Layer 1 bypassed
    let final_threshold = MIN_COARSE_THRESHOLD;

    while (right - left > final_threshold) {
        // Layer 2: Ceiling division guarantees third ‚â• 1 for any positive gap
        // ceil(gap/3) = (gap + 2) / 3, mathematically ensures loop always makes progress
        // Layer 1 (threshold=3) prevents this from ever being needed, but Layer 2 is bulletproof
        let gap = right - left;
        let third = (gap + 2) / 3; // Ceiling division
        let m1 = left + third;
        let m2 = right - third;

        let profit_m1 = profit_at_b(ts, as_vals, bs, m1);
        let profit_m2 = profit_at_b(ts, as_vals, bs, m2);

        // Track best seen
        if (profit_m1 > best_profit) {
            best_profit = profit_m1;
            best_b = m1;
        };
        if (profit_m2 > best_profit) {
            best_profit = profit_m2;
            best_b = m2;
        };

        if (profit_m1 >= profit_m2) {
            right = m2;
        } else {
            left = m1;
        }
    };

    // Final endpoint check
    let profit_left = profit_at_b(ts, as_vals, bs, left);
    if (profit_left > best_profit) {
        best_profit = profit_left;
        best_b = left;
    };

    let profit_right = profit_at_b(ts, as_vals, bs, right);
    if (profit_right > best_profit) {
        best_profit = profit_right;
        best_b = right;
    };

    (best_b, best_profit)
}

/// Calculate profit at given b value
/// F(b) = b - x(b) where x(b) = max_i x_i(b)
fun profit_at_b(ts: &vector<u128>, as_vals: &vector<u128>, bs: &vector<u128>, b: u64): u128 {
    let x = x_required_for_b(ts, as_vals, bs, b);
    if (b > x) {
        ((b - x) as u128)
    } else {
        0
    }
}

/// Calculate input x required to achieve output b
/// x(b) = max_i [b √ó A_i / (T_i - b √ó B_i)]
///
/// OVERFLOW PROTECTION: Uses u256 arithmetic for all critical multiplications
/// to prevent underestimating required input (which would inflate profit estimates)
fun x_required_for_b(ts: &vector<u128>, as_vals: &vector<u128>, bs: &vector<u128>, b: u64): u64 {
    let n = vector::length(ts);
    if (n == 0) return 0;

    let b_u256 = (b as u256);
    let mut x_max_u256 = 0u256;

    let mut i = 0;
    while (i < n) {
        let ti = *vector::borrow(ts, i);
        let ai = *vector::borrow(as_vals, i);
        let bi = *vector::borrow(bs, i);

        // Convert to u256 for overflow-free arithmetic
        let ti_u256 = (ti as u256);
        let ai_u256 = (ai as u256);
        let bi_u256 = (bi as u256);

        // Calculate b √ó B_i in u256 (no overflow possible)
        let bbi_u256 = b_u256 * bi_u256;

        // x_i(b) = ceil(b √ó A_i / (T_i - b √ó B_i))
        // If b √ó B_i >= T_i, this value of b is infeasible for this pool
        if (bbi_u256 >= ti_u256) {
            // This b value exceeds this pool's capacity
            // Return max value as this pool is the bottleneck
            return std::u64::max_value!()
        };

        let denom_u256 = ti_u256 - bbi_u256;

        // Calculate b √ó A_i in u256 (no overflow possible)
        let numer_u256 = b_u256 * ai_u256;

        // Ceiling division: ceil(n/d) = (n + d - 1) / d
        // Handle case where denom_u256 is 0 (already checked above, but defensive)
        if (denom_u256 == 0) {
            return std::u64::max_value!()
        };

        let xi_u256 = (numer_u256 + denom_u256 - 1) / denom_u256;

        // Track maximum x_i across all pools
        if (xi_u256 > x_max_u256) {
            x_max_u256 = xi_u256;
        };

        i = i + 1;
    };

    // Convert back to u64, saturating if necessary
    if (x_max_u256 > (std::u64::max_value!() as u256)) {
        std::u64::max_value!()
    } else {
        (x_max_u256 as u64)
    }
}

/// Upper bound on b: floor(min_i (T_i - 1) / B_i)
///
/// **Conservative Design (Intentional Trade-off):**
/// - If ANY pool has bi == 0 or ti <= 1, we set global U_b = 0 (reject all trades)
/// - This is CORRECT for Spot‚ÜíCond because feasibility requires ALL pools to accept b
/// - Side effect: Rejects barely-feasible small trades when ti ‚âà 1
///
/// **Why ti - 1 instead of ti:**
/// - Prevents vertical asymptote at b = T_i/B_i (division by zero in x(b) formula)
/// - The "‚àí1" adds safety margin to avoid numerical instability near the boundary
///
/// **Alternative (not implemented):**
/// - Could make margin tunable (e.g., T_i - safety_margin) if rejecting small trades is a problem
/// - For now, strictness prioritized over capturing tiny arbitrage opportunities
///
/// SECURITY FIX: Treat ti <= 1 as ub_i = 0 (not skip) to avoid inflating U_b
fun upper_bound_b(ts: &vector<u128>, bs: &vector<u128>): u64 {
    let n = vector::length(ts);
    if (n == 0) return 0;

    let mut ub: u128 = std::u64::max_value!() as u128;

    let mut i = 0;
    while (i < n) {
        let ti = *vector::borrow(ts, i);
        let bi = *vector::borrow(bs, i);

        // FIX: If ti <= 1 or bi == 0, treat as ub_i = 0 (not skip!)
        // Skipping incorrectly inflates the upper bound
        let ub_i = if (bi == 0 || ti <= 1) {
            0u128
        } else {
            (ti - 1) / bi
        };

        if (ub_i < ub) {
            ub = ub_i;
        };

        i = i + 1;
    };

    if (ub > (std::u64::max_value!() as u128)) {
        std::u64::max_value!()
    } else {
        (ub as u64)
    }
}

// === Optimization Functions ===

/// Early exit check: if ANY conditional is cheaper/equal to spot, no Spot‚ÜíCond arbitrage
///
/// MATHEMATICAL PROOF:
/// F'(0) = 1 - max_i(A_i/T_i)
/// For profit to exist, need F'(0) > 0 ‚ü∫ max_i(A_i/T_i) < 1 ‚ü∫ ALL A_i < T_i
///
/// Since x(b) = max_i[x_i(b)], a SINGLE "too-cheap" pool (T_i ‚â§ A_i) dominates
/// the max and kills profitability everywhere. Therefore:
/// - Need ALL pools expensive (T_i > A_i) for arbitrage to exist
/// - If ANY pool has T_i ‚â§ A_i ‚Üí return true (exit early, no profit possible)
fun early_exit_check_spot_to_cond(ts: &vector<u128>, as_vals: &vector<u128>): bool {
    let n = vector::length(ts);

    let mut i = 0;
    while (i < n) {
        let ti = *vector::borrow(ts, i);
        let ai = *vector::borrow(as_vals, i);

        // If ANY pool has T_i ‚â§ A_i, then max_i(A_i/T_i) ‚â• 1 ‚Üí F'(0) ‚â§ 0 ‚Üí no profit
        if (safe_cross_product_le(ti, 1, ai, 1)) {
            return true // Exit early: this "cheap" pool kills all arbitrage
        };

        i = i + 1;
    };

    false // All pools have T_i > A_i ‚Üí arbitrage may exist
}

/// Early exit check: if spot derivative <= cost derivative at b=0, no Cond‚ÜíSpot arbitrage
///
/// MATHEMATICAL PROOF:
/// F(b) = S(b) - C(b) where:
/// - S(b) = (R_spot_stable * b * Œ≤) / (R_spot_asset * BPS_SCALE + b * Œ≤)
/// - C(b) = max_i (R_i_stable * b * BPS_SCALE) / ((R_i_asset - b) * Œ±_i)  [quantum liquidity!]
///
/// Derivatives at b=0:
/// S'(0) = (R_spot_stable * Œ≤) / (R_spot_asset * BPS_SCALE)
/// C'(0) = max_i(c'_i(0)) where c'_i(0) = (R_i_stable * BPS_SCALE) / (R_i_asset * Œ±_i)
///
/// For profit: F'(0) > 0 ‚ü∫ S'(0) > C'(0) = max_i(c'_i(0))  [quantum liquidity max semantics]
/// Return true (exit early) if S'(0) ‚â§ C'(0)
///
/// CONSERVATIVE CHECK: If S'(0) ‚â§ ANY c'_i(0), then S'(0) ‚â§ max_i(c'_i(0)) = C'(0).
/// This correctly catches unprofitable cases (spot revenue slope too shallow).
fun early_exit_check_cond_to_spot(
    spot_asset: u64,
    spot_stable: u64,
    beta: u64,
    conditionals: &vector<LiquidityPool>,
): bool {
    // Calculate S'(0) = (R_spot_stable * Œ≤) / (R_spot_asset * BPS_SCALE)
    let spot_stable_u256 = (spot_stable as u256);
    let beta_u256 = (beta as u256);
    let spot_asset_u256 = (spot_asset as u256);
    let bps_u256 = (BPS_SCALE as u256);

    // S'(0) numerator: R_spot_stable * Œ≤
    let s_prime_num = spot_stable_u256 * beta_u256;
    // S'(0) denominator: R_spot_asset * BPS_SCALE
    let s_prime_denom = spot_asset_u256 * bps_u256;

    // Check: if S'(0) <= ANY c'_i(0), then S'(0) <= max_i(c'_i(0)) = C'(0)
    // Quantum liquidity uses MAX semantics, not sum!

    let n = vector::length(conditionals);
    let mut i = 0;
    while (i < n) {
        let conditional = vector::borrow(conditionals, i);
        let (cond_asset, cond_stable) = conditional_amm::get_reserves(conditional);
        let cond_fee_bps = conditional_amm::get_fee_bps(conditional);

        // FIX: Validate fee to prevent underflow in alpha_i calculation
        assert!(cond_fee_bps <= BPS_SCALE, EInvalidFee);
        let alpha_i = BPS_SCALE - cond_fee_bps;

        // c'_i(0) = (R_i_stable * BPS_SCALE) / (R_i_asset * Œ±_i)
        let c_i_num = (cond_stable as u256) * bps_u256;
        let c_i_denom = (cond_asset as u256) * (alpha_i as u256);

        // Check if s_prime_num / s_prime_denom <= c_i_num / c_i_denom
        // ‚ü∫ s_prime_num * c_i_denom <= s_prime_denom * c_i_num
        if (s_prime_num * c_i_denom <= s_prime_denom * c_i_num) {
            // Spot slope ‚â§ this conditional's slope
            // Since C'(0) = max_i(c'_i) ‚â• c'_i ‚â• S'(0), definitely no profit
            return true
        };

        i = i + 1;
    };

    // S'(0) > all individual c'_i(0)
    // Since C'(0) = max_i(c'_i) and S'(0) > every c'_i, we have S'(0) > C'(0)
    // Arbitrage may be profitable - let ternary search find optimal b
    false
}

/// Safe cross-product comparison: Check if a * b <= c * d without overflow
/// Uses u256 for exact comparison (no precision loss)
///
/// Returns true if a √ó b <= c √ó d
fun safe_cross_product_le(a: u128, b: u128, c: u128, d: u128): bool {
    // u256 multiplication handles all cases correctly, including zeros
    // No special cases needed - simpler and correct
    ((a as u256) * (b as u256)) <= ((c as u256) * (d as u256))
}

// === TAB Constants Builder ===

/// Build T, A, B constants for b-parameterization from pool reserves
/// These constants encode AMM state and fees for efficient arbitrage calculation
fun build_tab_constants(
    spot_asset_reserve: u64,
    spot_stable_reserve: u64,
    spot_fee_bps: u64,
    conditionals: &vector<LiquidityPool>,
): (vector<u128>, vector<u128>, vector<u128>) {
    let num_conditionals = vector::length(conditionals);
    let mut ts_vec = vector::empty<u128>();
    let mut as_vec = vector::empty<u128>();
    let mut bs_vec = vector::empty<u128>();

    // FIX #7: Validate spot fee to prevent underflow
    assert!(spot_fee_bps <= BPS_SCALE, EInvalidFee);
    let beta = BPS_SCALE - spot_fee_bps;

    let mut i = 0;
    while (i < num_conditionals) {
        let conditional = vector::borrow(conditionals, i);
        let (cond_asset, cond_stable) = conditional_amm::get_reserves(conditional);
        let cond_fee_bps = conditional_amm::get_fee_bps(conditional);

        // FIX #7: Validate conditional fee to prevent underflow
        assert!(cond_fee_bps <= BPS_SCALE, EInvalidFee);
        let alpha_i = BPS_SCALE - cond_fee_bps;

        // T_i = (cond_stable * alpha_i * spot_asset * beta) / BPS¬≤
        // FIX #8: Use u256 for entire calculation with SINGLE division to avoid double-rounding
        let cond_stable_u256 = (cond_stable as u256);
        let alpha_i_u256 = (alpha_i as u256);
        let spot_asset_u256 = (spot_asset_reserve as u256);
        let beta_u256 = (beta as u256);
        let bps_u256 = (BPS_SCALE as u256);

        // CRITICAL: Multiply ALL terms FIRST, then divide ONCE to avoid precision loss
        // Old (wrong): (a/b) * (c/d) causes TWO truncations
        // New (correct): (a * c) / (b * d) causes ONE truncation
        let ti_u256 =
            (cond_stable_u256 * alpha_i_u256 * spot_asset_u256 * beta_u256)
            / (bps_u256 * bps_u256);

        // Clamp to u128 max if needed
        let ti = if (ti_u256 > (std::u128::max_value!() as u256)) {
            std::u128::max_value!()
        } else {
            (ti_u256 as u128)
        };

        // A_i = cond_asset * spot_stable (use u256 to prevent overflow)
        let cond_asset_u256 = (cond_asset as u256);
        let spot_stable_u256 = (spot_stable_reserve as u256);
        let ai_u256 = cond_asset_u256 * spot_stable_u256;

        let ai = if (ai_u256 > (std::u128::max_value!() as u256)) {
            std::u128::max_value!()
        } else {
            (ai_u256 as u128)
        };

        // B_i = Œ≤ * (R_i,asset * BPS + Œ±_i * R_spot,asset) / BPS¬≤
        // FIX: Use SINGLE division to avoid double-rounding (same fix as T_i)
        // Old (wrong): temp = a + b/c; result = temp * d / c (TWO divisions)
        // New (correct): result = d * (a * c + b) / c¬≤ (ONE division)
        let bi_u256 =
            (beta_u256 * (cond_asset_u256 * bps_u256 + alpha_i_u256 * spot_asset_u256))
            / (bps_u256 * bps_u256);

        let bi = if (bi_u256 > (std::u128::max_value!() as u256)) {
            std::u128::max_value!()
        } else {
            (bi_u256 as u128)
        };

        vector::push_back(&mut ts_vec, ti);
        vector::push_back(&mut as_vec, ai);
        vector::push_back(&mut bs_vec, bi);

        i = i + 1;
    };

    (ts_vec, as_vec, bs_vec)
}

// === Simulation Functions (For Verification) ===

/// Calculate arbitrage profit for specific amount (simulation)
/// spot_swap_is_stable_to_asset: true = Spot‚ÜíConditional (buy from spot, sell to conditionals)
/// spot_swap_is_stable_to_asset: false = Conditional‚ÜíSpot (buy from conditionals, sell to spot)
public fun calculate_spot_arbitrage_profit<AssetType, StableType>(
    spot: &UnifiedSpotPool<AssetType, StableType>,
    conditionals: &vector<LiquidityPool>,
    arbitrage_amount: u64,
    spot_swap_is_stable_to_asset: bool,
): u128 {
    if (spot_swap_is_stable_to_asset) {
        // Spot‚ÜíConditional: Buy asset from spot (stable‚Üíasset swap), sell to conditionals
        simulate_spot_to_conditional_profit(
            spot,
            conditionals,
            arbitrage_amount,
            spot_swap_is_stable_to_asset,
        )
    } else {
        // Conditional‚ÜíSpot: Buy from conditionals, recombine, sell to spot (asset‚Üístable swap)
        simulate_conditional_to_spot_profit(spot, conditionals, arbitrage_amount)
    }
}

fun simulate_spot_to_conditional_profit<AssetType, StableType>(
    spot: &UnifiedSpotPool<AssetType, StableType>,
    conditionals: &vector<LiquidityPool>,
    arbitrage_amount: u64,
    spot_swap_is_stable_to_asset: bool,
): u128 {
    let spot_output = if (spot_swap_is_stable_to_asset) {
        unified_spot_pool::simulate_swap_stable_to_asset(spot, arbitrage_amount)
    } else {
        unified_spot_pool::simulate_swap_asset_to_stable(spot, arbitrage_amount)
    };

    if (spot_output == 0) return 0;

    let num_outcomes = vector::length(conditionals);
    let mut min_conditional_output = std::u64::max_value!();

    let mut i = 0;
    while (i < num_outcomes) {
        let conditional = vector::borrow(conditionals, i);

        let cond_output = if (spot_swap_is_stable_to_asset) {
            conditional_amm::simulate_swap_asset_to_stable(conditional, spot_output)
        } else {
            conditional_amm::simulate_swap_stable_to_asset(conditional, spot_output)
        };

        min_conditional_output = min_conditional_output.min(cond_output);
        i = i + 1;
    };

    if (min_conditional_output > arbitrage_amount) {
        ((min_conditional_output - arbitrage_amount) as u128)
    } else {
        0
    }
}

/// Simulate Conditional ‚Üí Spot arbitrage profit (for testing/verification)
public fun simulate_conditional_to_spot_profit<AssetType, StableType>(
    spot: &UnifiedSpotPool<AssetType, StableType>,
    conditionals: &vector<LiquidityPool>,
    arbitrage_amount: u64,
): u128 {
    // Conditional ‚Üí Spot simulation:
    // 1. Calculate cost to buy b conditional tokens from EACH pool
    // 2. Recombine b complete sets ‚Üí b base assets
    // 3. Sell b base assets to spot ‚Üí get stable
    // 4. Profit = spot_revenue - total_cost_from_all_pools

    let num_outcomes = vector::length(conditionals);
    if (num_outcomes == 0) return 0;

    // Calculate total cost to buy from ALL conditional pools
    let total_cost = calculate_conditional_cost(conditionals, arbitrage_amount);

    // If cost is infinite (insufficient liquidity), no profit
    if (total_cost == std::u128::max_value!()) {
        return 0
    };

    // Get spot revenue from selling recombined base assets
    let (spot_asset, spot_stable) = unified_spot_pool::get_reserves(spot);
    let spot_fee_bps = unified_spot_pool::get_fee_bps(spot);
    let beta = BPS_SCALE - spot_fee_bps;

    let spot_revenue = calculate_spot_revenue(
        spot_asset,
        spot_stable,
        beta,
        arbitrage_amount,
    );

    // Profit = revenue - cost
    if (spot_revenue > total_cost) {
        spot_revenue - total_cost
    } else {
        0
    }
}

/// Conditional arbitrage (legacy compatibility)
public fun calculate_conditional_arbitrage_profit<AssetType, StableType>(
    spot: &UnifiedSpotPool<AssetType, StableType>,
    conditionals: &vector<LiquidityPool>,
    swapped_outcome_idx: u8,
    arbitrage_amount: u64,
    is_asset_to_stable: bool,
): u128 {
    let swapped_conditional = vector::borrow(conditionals, (swapped_outcome_idx as u64));

    // FIX: Correct swap direction to match is_asset_to_stable flag
    let cond_output = if (is_asset_to_stable) {
        // We are SELLING asset to get stable
        conditional_amm::simulate_swap_asset_to_stable(swapped_conditional, arbitrage_amount)
    } else {
        // We are BUYING asset with stable
        conditional_amm::simulate_swap_stable_to_asset(swapped_conditional, arbitrage_amount)
    };

    if (cond_output == 0) return 0;

    // Then swap in opposite direction in spot pool
    let spot_output = if (is_asset_to_stable) {
        // We got stable from conditional, now buy asset back from spot
        unified_spot_pool::simulate_swap_stable_to_asset(spot, cond_output)
    } else {
        // We got asset from conditional, now sell it for stable in spot
        unified_spot_pool::simulate_swap_asset_to_stable(spot, cond_output)
    };

    if (spot_output > arbitrage_amount) {
        ((spot_output - arbitrage_amount) as u128)
    } else {
        0
    }
}

// === Conditional ‚Üí Spot Helper Functions ===

/// Calculate profit for Conditional ‚Üí Spot arbitrage at given b
/// F(b) = S(b) - C(b)
/// where:
/// - S(b) = spot output from selling b base assets
/// - C(b) = total cost to buy b conditional assets from all pools
fun profit_conditional_to_spot(
    spot_asset: u64,
    spot_stable: u64,
    beta: u64, // spot fee multiplier (BPS_SCALE - fee_bps)
    conditionals: &vector<LiquidityPool>,
    b: u64,
): u128 {
    if (b == 0) return 0;

    // Calculate spot revenue: S(b) = spot output from selling b base assets
    let spot_revenue = calculate_spot_revenue(spot_asset, spot_stable, beta, b);

    // Calculate total cost from all conditional pools: C(b) = max_i(c_i(b)) [quantum liquidity!]
    let total_cost = calculate_conditional_cost(conditionals, b);

    // Profit: S(b) - C(b)
    if (spot_revenue > total_cost) {
        spot_revenue - total_cost
    } else {
        0
    }
}

/// Calculate revenue from selling b base assets to spot
/// S(b) = (R_spot_stable * b * Œ≤) / (R_spot_asset * BPS_SCALE + b * Œ≤)
///
/// Derivation:
/// - Before swap: (R_spot_asset, R_spot_stable)
/// - Add b assets (after fee: b * Œ≤ / BPS_SCALE)
/// - Remove stable_out
/// - Constant product: R_spot_asset * R_spot_stable = (R_spot_asset + b*Œ≤/BPS_SCALE) * (R_spot_stable - stable_out)
/// - Solving: stable_out = R_spot_stable * (b*Œ≤/BPS_SCALE) / (R_spot_asset + b*Œ≤/BPS_SCALE)
/// - Simplify: stable_out = (R_spot_stable * b * Œ≤) / (R_spot_asset * BPS_SCALE + b * Œ≤)
fun calculate_spot_revenue(spot_asset: u64, spot_stable: u64, beta: u64, b: u64): u128 {
    // Use u256 for accurate overflow-free arithmetic
    let b_u256 = (b as u256);
    let beta_u256 = (beta as u256);
    let spot_stable_u256 = (spot_stable as u256);
    let spot_asset_u256 = (spot_asset as u256);

    // Numerator: R_spot_stable * b * Œ≤ (in u256 space)
    let b_beta = b_u256 * beta_u256;
    let numerator_u256 = spot_stable_u256 * b_beta;

    // Denominator: R_spot_asset * BPS_SCALE + b * Œ≤ (in u256 space)
    let spot_asset_scaled = spot_asset_u256 * (BPS_SCALE as u256);
    let denominator_u256 = spot_asset_scaled + b_beta;

    if (denominator_u256 == 0) return 0;

    // Compute result in u256 space
    let result_u256 = numerator_u256 / denominator_u256;

    // Saturate to u128 if needed
    if (result_u256 > (std::u128::max_value!() as u256)) {
        std::u128::max_value!()
    } else {
        (result_u256 as u128)
    }
}

/// Calculate cost to buy b conditional assets from all pools (QUANTUM LIQUIDITY)
/// C(b) = max_i(c_i(b)) where c_i(b) = (R_i_stable * b * BPS_SCALE) / ((R_i_asset - b) * Œ±_i)
///
/// **CRITICAL: Uses MAX not SUM due to quantum liquidity!**
///
/// When you split base USDC, you get conditional tokens for ALL outcomes simultaneously:
///   Split 60 base ‚Üí 60 YES_USDC + 60 NO_USDC + 60 MAYBE_USDC + ...
///
/// To buy b from each pool:
///   Pool 1 costs 60 YES_USDC, Pool 2 costs 50 NO_USDC
///   ‚Üí Split max(60, 50) = 60 base USDC (NOT 60 + 50 = 110!)
///
/// Cost derivation for pool i:
/// - Before swap: (R_i_asset, R_i_stable)
/// - Add stable_in (after fee: stable_in * Œ±_i / BPS_SCALE)
/// - Remove b assets
/// - Constant product: R_i_asset * R_i_stable = (R_i_asset - b) * (R_i_stable + stable_in*Œ±_i/BPS_SCALE)
/// - Solving: stable_in = (R_i_stable * b * BPS_SCALE) / ((R_i_asset - b) * Œ±_i)
fun calculate_conditional_cost(conditionals: &vector<LiquidityPool>, b: u64): u128 {
    let num_conditionals = vector::length(conditionals);
    let mut max_cost = 0u128; // FIX: Use max, not sum (quantum liquidity!)
    let b_u128 = (b as u128);

    let mut i = 0;
    while (i < num_conditionals) {
        let conditional = vector::borrow(conditionals, i);
        let (cond_asset, cond_stable) = conditional_amm::get_reserves(conditional);
        let cond_fee_bps = conditional_amm::get_fee_bps(conditional);

        // FIX: Validate fee to prevent underflow in alpha calculation
        assert!(cond_fee_bps <= BPS_SCALE, EInvalidFee);
        let alpha = BPS_SCALE - cond_fee_bps;

        // Skip if b >= R_i_asset (can't buy more than pool has)
        if (b >= cond_asset) {
            // This makes arbitrage impossible - need b from ALL pools
            return std::u128::max_value!() // Infinite cost
        };

        // Cost from pool i: c_i(b) = (R_i_stable * b * BPS_SCALE) / ((R_i_asset - b) * Œ±_i)
        let cond_asset_u128 = (cond_asset as u128);
        let cond_stable_u128 = (cond_stable as u128);
        let alpha_u128 = (alpha as u128);

        // Use u256 for accurate overflow-free arithmetic
        // Numerator: R_i_stable * b * BPS_SCALE (in u256 space)
        let stable_b_u256 = (cond_stable_u128 as u256) * (b_u128 as u256);
        let numerator_u256 = stable_b_u256 * (BPS_SCALE as u256);

        // Denominator: (R_i_asset - b) * Œ±_i (in u256 space)
        let asset_minus_b = cond_asset_u128 - b_u128;
        if (asset_minus_b == 0) {
            return std::u128::max_value!() // Division by zero (infinite cost)
        };

        let denominator_u256 = (asset_minus_b as u256) * (alpha_u128 as u256);
        if (denominator_u256 == 0) {
            return std::u128::max_value!() // Impossible but defensive
        };

        // Compute cost_i in u256 space
        let cost_i_u256 = numerator_u256 / denominator_u256;

        // Convert to u128, saturating if needed
        let cost_i = if (cost_i_u256 > (std::u128::max_value!() as u256)) {
            std::u128::max_value!() // Cost too high, saturate
        } else {
            (cost_i_u256 as u128)
        };

        // FIX: Take maximum cost across all pools (quantum liquidity)
        // You split base USDC once and get ALL conditional token types
        // So cost = max(c_i) not sum(c_i)
        if (cost_i > max_cost) {
            max_cost = cost_i;
        };

        i = i + 1;
    };

    max_cost
}

// ============================================================================
// TEST-ONLY WRAPPERS
// ============================================================================
// These wrappers expose internal functions for white-box testing.
// They are compiled out of production builds (#[test_only] attribute).

#[test_only]
public fun test_only_build_tab_constants(
    spot_asset_reserve: u64,
    spot_stable_reserve: u64,
    spot_fee_bps: u64,
    conditionals: &vector<LiquidityPool>,
): (vector<u128>, vector<u128>, vector<u128>) {
    build_tab_constants(spot_asset_reserve, spot_stable_reserve, spot_fee_bps, conditionals)
}

#[test_only]
public fun test_only_profit_at_b(
    ts: &vector<u128>,
    as_vals: &vector<u128>,
    bs: &vector<u128>,
    b: u64,
): u128 {
    profit_at_b(ts, as_vals, bs, b)
}

#[test_only]
public fun test_only_optimal_b_search(
    ts: &vector<u128>,
    as_vals: &vector<u128>,
    bs: &vector<u128>,
): (u64, u128) {
    // For testing: use global upper bound
    let ub = upper_bound_b(ts, bs);
    optimal_b_search_bounded(ts, as_vals, bs, ub)
}

#[test_only]
public fun test_only_upper_bound_b(ts: &vector<u128>, bs: &vector<u128>): u64 {
    upper_bound_b(ts, bs)
}

#[test_only]
public fun test_only_x_required_for_b(
    ts: &vector<u128>,
    as_vals: &vector<u128>,
    bs: &vector<u128>,
    b: u64,
): u64 {
    x_required_for_b(ts, as_vals, bs, b)
}

#[test_only]
public fun test_only_calculate_spot_revenue(
    spot_asset: u64,
    spot_stable: u64,
    beta: u64,
    b: u64,
): u128 {
    calculate_spot_revenue(spot_asset, spot_stable, beta, b)
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

module futarchy_markets_core::proposal;

use futarchy_markets_primitives::conditional_amm::{Self, LiquidityPool};
use futarchy_markets_primitives::coin_escrow::{Self, TokenEscrow};
use futarchy_markets_core::liquidity_initialize;
use futarchy_markets_primitives::market_state;
// Removed: use futarchy_one_shot_utils::coin_validation - module was deleted, validation inlined
use std::ascii::String as AsciiString;
use std::string::{Self, String};
use std::type_name;
use std::option;
use std::type_name::TypeName;
use std::vector;
use sui::balance::{Self as balance, Balance};
use sui::clock::Clock;
use sui::coin::{Self, Coin, TreasuryCap, CoinMetadata};
use sui::event;
use sui::bag::{Self, Bag};
use account_actions::init_action_specs::{Self as action_specs, InitActionSpecs};
use futarchy_types::signed::{Self as signed, SignedU128};
use futarchy_core::dao_config::{Self, ConditionalCoinConfig};

// === Introduction ===
// This defines the core proposal logic and details

// === Errors ===

const EInvalidAmount: u64 = 1;
const EInvalidState: u64 = 2;
const EAssetLiquidityTooLow: u64 = 4;
const EStableLiquidityTooLow: u64 = 5;
const EPoolNotFound: u64 = 6;
const EOutcomeOutOfBounds: u64 = 7;
const ESpotTwapNotReady: u64 = 9;
const ETooManyOutcomes: u64 = 10;
const EInvalidOutcome: u64 = 11;
const ENotFinalized: u64 = 12;
const ETwapNotSet: u64 = 13;
const ETooManyActions: u64 = 14;
const EInvalidConditionalCoinCount: u64 = 15;
const EConditionalCoinAlreadySet: u64 = 16;
const ENotLiquidityProvider: u64 = 17;
const EAlreadySponsored: u64 = 18;
const ESupplyNotZero: u64 = 19;
const EInsufficientBalance: u64 = 20;

// === Constants ===

const STATE_PREMARKET: u8 = 0; // Proposal exists, outcomes can be added/mutated. No market yet.
const STATE_REVIEW: u8 = 1;    // Market is initialized and locked for review. Not yet trading.
const STATE_TRADING: u8 = 2;   // Market is live and trading.
const STATE_FINALIZED: u8 = 3; // Market has resolved.

// Outcome constants for TWAP calculation
const OUTCOME_ACCEPTED: u64 = 0;
const OUTCOME_REJECTED: u64 = 1;

// === Structs ===

/// Key for storing conditional coin caps in Bag
/// Each outcome has 2 coins: asset-conditional and stable-conditional
public struct ConditionalCoinKey has store, copy, drop {
    outcome_index: u64,
    is_asset: bool,  // true for asset, false for stable
}

/// Configuration for proposal timing and periods
public struct ProposalTiming has store {
    created_at: u64,
    market_initialized_at: Option<u64>,
    review_period_ms: u64,
    trading_period_ms: u64,
    last_twap_update: u64,
    twap_start_delay: u64,
}

/// Configuration for liquidity requirements
public struct LiquidityConfig has store {
    min_asset_liquidity: u64,
    min_stable_liquidity: u64,
    asset_amounts: vector<u64>,
    stable_amounts: vector<u64>,
}

/// TWAP (Time-Weighted Average Price) configuration
public struct TwapConfig has store {
    twap_prices: vector<u128>,
    twap_initial_observation: u128,
    twap_step_max: u64,
    twap_threshold: SignedU128,
}

/// Outcome-related data
public struct OutcomeData has store {
    outcome_count: u64,
    outcome_messages: vector<String>,
    outcome_creators: vector<address>,
    outcome_creator_fees: vector<u64>,  // Track fees paid by each outcome creator (for refunds)
    intent_specs: vector<Option<InitActionSpecs>>,  // Changed from intent_keys to intent_specs
    actions_per_outcome: vector<u64>,
    winning_outcome: Option<u64>,
}

/// Core proposal object that owns AMM pools
public struct Proposal<phantom AssetType, phantom StableType> has key, store {
    id: UID,
    queued_proposal_id: ID,
    state: u8,
    dao_id: ID,
    proposer: address, // The original proposer.
    liquidity_provider: Option<address>,
    withdraw_only_mode: bool, // When true, return liquidity to provider instead of auto-reinvesting
    /// Track if proposal used admin quota/budget (excludes from creator rewards)
    used_quota: bool,
    /// Track who sponsored this proposal (if any)
    sponsored_by: Option<address>,
    /// Track the threshold reduction applied by sponsorship
    sponsor_threshold_reduction: SignedU128,

    // Market-related fields (pools now live in MarketState)
    escrow_id: Option<ID>,
    market_state_id: Option<ID>,

    // Conditional coin capabilities (stored dynamically per outcome)
    conditional_treasury_caps: Bag,  // Stores TreasuryCap<ConditionalCoinType> per outcome
    conditional_metadata: Bag,        // Stores CoinMetadata<ConditionalCoinType> per outcome

    // Proposal content
    title: String,
    introduction_details: String,
    details: vector<String>,
    metadata: String,

    // Grouped configurations
    timing: ProposalTiming,
    liquidity_config: LiquidityConfig,
    twap_config: TwapConfig,
    outcome_data: OutcomeData,
    
    // Fee-related fields
    amm_total_fee_bps: u64,
    conditional_liquidity_ratio_percent: u64,  // Percentage of spot liquidity to move to conditional markets (1-99%, base 100)
    fee_escrow: Balance<StableType>, // DAO-level fees held for refund to losing outcome creators
    treasury_address: address,
}

/// A scoped witness proving that a particular (proposal, outcome) had an IntentSpec.
/// Only mintable by the module that has &mut Proposal and consumes the slot.
/// This prevents cross-proposal cancellation attacks.
///
/// After IntentSpec refactor: This witness proves ownership of a proposal outcome slot,
/// used for cleanup and lifecycle management.
public struct CancelWitness has drop {
    proposal: address,
    outcome_index: u64,
}

// Getter functions for CancelWitness
public fun cancel_witness_proposal(witness: &CancelWitness): address {
    witness.proposal
}

public fun cancel_witness_outcome_index(witness: &CancelWitness): u64 {
    witness.outcome_index
}

// === Events ===

public struct ProposalCreated has copy, drop {
    proposal_id: ID,
    dao_id: ID,
    proposer: address,
    outcome_count: u64,
    outcome_messages: vector<String>,
    created_at: u64,
    asset_type: AsciiString,
    stable_type: AsciiString,
    review_period_ms: u64,
    trading_period_ms: u64,
    title: String,
    metadata: String,
}

public struct ProposalMarketInitialized has copy, drop {
    proposal_id: ID,
    dao_id: ID,
    market_state_id: ID,
    escrow_id: ID,
    timestamp: u64,
}

public struct ProposalOutcomeMutated has copy, drop {
    proposal_id: ID,
    dao_id: ID,
    outcome_idx: u64,
    old_creator: address,
    new_creator: address,
    timestamp: u64,
}

public struct ProposalOutcomeAdded has copy, drop {
    proposal_id: ID,
    dao_id: ID,
    new_outcome_idx: u64,
    creator: address,
    timestamp: u64,
}

// Early resolution events moved to early_resolve.move

// === Public Functions ===

/// Create a PREMARKET proposal without market/escrow/liquidity.
/// This reserves the proposal "as next" without consuming DAO/proposer liquidity.
#[allow(lint(share_owned))]
public fun new_premarket<AssetType, StableType>(
    // Proposal ID originating from queue
    proposal_id_from_queue: ID,
    dao_id: ID,
    review_period_ms: u64,
    trading_period_ms: u64,
    min_asset_liquidity: u64,
    min_stable_liquidity: u64,
    twap_start_delay: u64,
    twap_initial_observation: u128,
    twap_step_max: u64,
    twap_threshold: SignedU128,
    amm_total_fee_bps: u64,
    conditional_liquidity_ratio_percent: u64,  // Percentage of spot liquidity to move (1-99%, base 100)
    max_outcomes: u64, // DAO's configured max outcomes
    treasury_address: address,
    title: String,
    introduction_details: String,
    metadata: String,
    outcome_messages: vector<String>,
    outcome_details: vector<String>,
    proposer: address,
    used_quota: bool, // Track if proposal used admin budget
    intent_spec_for_yes: Option<InitActionSpecs>,
    clock: &Clock,
    ctx: &mut TxContext,
): ID {
    let id = object::new(ctx);
    let actual_proposal_id = object::uid_to_inner(&id);
    let outcome_count = outcome_messages.length();
    
    // Validate outcome count
    assert!(outcome_count <= max_outcomes, ETooManyOutcomes);
    
    let proposal = Proposal<AssetType, StableType> {
        id,
        queued_proposal_id: proposal_id_from_queue,
        state: STATE_PREMARKET,
        dao_id,
        proposer,
        liquidity_provider: option::none(),
        withdraw_only_mode: false,
        used_quota,
        sponsored_by: option::none(), // No sponsorship by default
        sponsor_threshold_reduction: signed::from_u64(0), // No reduction by default
        escrow_id: option::none(),
        market_state_id: option::none(),
        conditional_treasury_caps: bag::new(ctx),
        conditional_metadata: bag::new(ctx),
        title,
        introduction_details,
        details: outcome_details,
        metadata,
        timing: ProposalTiming {
            created_at: clock.timestamp_ms(),
            market_initialized_at: option::none(),
            review_period_ms,
            trading_period_ms,
            last_twap_update: 0,
            twap_start_delay,
        },
        liquidity_config: LiquidityConfig {
            min_asset_liquidity,
            min_stable_liquidity,
            asset_amounts: vector::empty(),
            stable_amounts: vector::empty(),
        },
        twap_config: TwapConfig {
            twap_prices: vector::empty(),
            twap_initial_observation,
            twap_step_max,
            twap_threshold,
        },
        outcome_data: OutcomeData {
            outcome_count,
            outcome_messages,
            outcome_creators: vector::tabulate!(outcome_count, |_| proposer),
            outcome_creator_fees: vector::tabulate!(outcome_count, |_| 0u64),  // Initialize with 0 fees
            intent_specs: vector::tabulate!(outcome_count, |_| option::none<InitActionSpecs>()),
            actions_per_outcome: vector::tabulate!(outcome_count, |_| 0),
            winning_outcome: option::none(),
        },
        amm_total_fee_bps,
        conditional_liquidity_ratio_percent,
        fee_escrow: balance::zero(), // No DAO fees for premarket proposals yet
        treasury_address,
    };

    transfer::public_share_object(proposal);
    actual_proposal_id
}

/// Initialize market/escrow/AMMs for a PREMARKET proposal.
/// Consumes provided coins, sets state to REVIEW, and readies the market for the review timer.
#[allow(lint(share_owned, self_transfer))]
/// Step 1: Create escrow with market state (called first in PTB)
/// Returns unshared escrow for cap registration
public fun create_escrow_for_market<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
): TokenEscrow<AssetType, StableType> {
    assert!(proposal.state == STATE_PREMARKET, EInvalidState);

    // Create market state
    let ms = market_state::new(
        object::id(proposal),
        proposal.dao_id,
        proposal.outcome_data.outcome_count,
        proposal.outcome_data.outcome_messages,
        clock,
        ctx
    );

    // Create and return escrow (not yet shared)
    coin_escrow::new<AssetType, StableType>(ms, ctx)
}

/// Step 2: Extract conditional coin caps from proposal and register with escrow
/// Must be called once per outcome (PTB calls this N times with different type parameters)
public fun register_outcome_caps_with_escrow<AssetType, StableType, AssetConditionalCoin, StableConditionalCoin>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_index: u64,
) {
    assert!(proposal.state == STATE_PREMARKET, EInvalidState);

    // Extract TreasuryCaps from proposal bags
    let asset_key = ConditionalCoinKey { outcome_index, is_asset: true };
    let stable_key = ConditionalCoinKey { outcome_index, is_asset: false };

    let asset_cap: TreasuryCap<AssetConditionalCoin> =
        bag::remove(&mut proposal.conditional_treasury_caps, asset_key);
    let stable_cap: TreasuryCap<StableConditionalCoin> =
        bag::remove(&mut proposal.conditional_treasury_caps, stable_key);

    // Register with escrow
    coin_escrow::register_conditional_caps(escrow, outcome_index, asset_cap, stable_cap);
}

/// Step 2.5: Create conditional AMM pools and store them in MarketState
/// Called after all outcome caps are registered (PTB calls this once after N cap registrations)
/// CRITICAL: This must be called BEFORE advancing to REVIEW state, otherwise quantum split will fail
///
/// BOOTSTRAP LIQUIDITY MODEL:
/// - Creates pools with minimal reserves (1000/1000 per pool) for AMM constraints
/// - These minimal reserves are "bootstrap liquidity" that stays locked in pools permanently
/// - NO escrow backing needed for bootstrap reserves
/// - Quantum split will add the REAL liquidity with proper escrow backing
/// - Recombination only withdraws quantum-split amounts, NOT bootstrap reserves
public fun create_conditional_amm_pools<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(proposal.state == STATE_PREMARKET, EInvalidState);

    // Get market state from escrow
    let market_state = coin_escrow::get_market_state_mut(escrow);
    let outcome_count = market_state::outcome_count(market_state);

    // CRITICAL: Pools need minimal reserves to satisfy AMM constraints (MINIMUM_LIQUIDITY = 1000)
    // These minimal reserves must have matching escrow backing for recombination to work
    // Quantum split will ADD bulk liquidity on top of these minimal reserves

    // Use absolute minimum per pool (sqrt(1000*1000) = 1000 satisfies k >= MINIMUM_LIQUIDITY)
    let min_reserve_per_pool = 1000u64;

    // Create vectors for pool initialization
    let mut asset_amounts = vector::empty<u64>();
    let mut stable_amounts = vector::empty<u64>();
    let mut i = 0;
    while (i < outcome_count) {
        asset_amounts.push_back(min_reserve_per_pool);
        stable_amounts.push_back(min_reserve_per_pool);
        i = i + 1;
    };

    // Create conditional AMM pools with minimal bootstrap reserves
    // Bootstrap reserves (1000/1000 per pool) stay locked in pools permanently
    // Quantum split will add the real liquidity with escrow backing on top
    let amm_pools = liquidity_initialize::create_outcome_markets<AssetType, StableType>(
        escrow,
        outcome_count,
        asset_amounts,
        stable_amounts,
        proposal.timing.twap_start_delay,
        proposal.twap_config.twap_initial_observation,
        proposal.twap_config.twap_step_max,
        proposal.amm_total_fee_bps,
        balance::zero<AssetType>(), // No backing for bootstrap reserves
        balance::zero<StableType>(), // They stay locked forever
        clock,
        ctx,
    );

    // Store the pools in MarketState (CRITICAL - this is the missing piece!)
    let market_state = coin_escrow::get_market_state_mut(escrow);
    market_state::set_amm_pools(market_state, amm_pools);
}

/// Step 3: Initialize market with pre-configured escrow
/// Called after create_escrow_for_market() and N calls to register_outcome_caps_with_escrow()
#[allow(lint(share_owned, self_transfer))]
/// Internal function: Adds a new outcome during the premarket phase.
/// max_outcomes: The DAO's configured maximum number of outcomes allowed
/// fee_paid: The fee paid by the outcome creator (for potential refund if their outcome wins)
///
/// SECURITY: This is an internal function. Fee payment must be validated before calling.
/// External callers MUST use entry functions that collect actual Coin<SUI> payments.
public fun add_outcome<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    message: String,
    detail: String,
    asset_amount: u64,
    stable_amount: u64,
    creator: address,
    fee_paid: u64,
    max_outcomes: u64,
    clock: &Clock,
) {
    // SECURITY: Only allow adding outcomes in PREMARKET state
    assert!(proposal.state == STATE_PREMARKET, EInvalidState);

    // Check that we're not exceeding the maximum number of outcomes
    assert!(proposal.outcome_data.outcome_count < max_outcomes, ETooManyOutcomes);

    proposal.outcome_data.outcome_messages.push_back(message);
    proposal.details.push_back(detail);
    proposal.liquidity_config.asset_amounts.push_back(asset_amount);
    proposal.liquidity_config.stable_amounts.push_back(stable_amount);
    proposal.outcome_data.outcome_creators.push_back(creator);
    proposal.outcome_data.outcome_creator_fees.push_back(fee_paid);  // Track the fee paid

    // Initialize action count for new outcome
    proposal.outcome_data.actions_per_outcome.push_back(0);

    // Initialize IntentSpec slot as empty
    proposal.outcome_data.intent_specs.push_back(option::none());

    let new_idx = proposal.outcome_data.outcome_count;
    proposal.outcome_data.outcome_count = new_idx + 1;

    event::emit(ProposalOutcomeAdded {
        proposal_id: get_id(proposal),
        dao_id: get_dao_id(proposal),
        new_outcome_idx: new_idx,
        creator,
        timestamp: clock.timestamp_ms(),
    });
}

/// Add an outcome to a PREMARKET proposal with DAO-level fee payment
/// The fee is deposited into the proposal's escrow for potential refund if the outcome loses
public entry fun add_outcome_with_fee<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    fee_payment: Coin<StableType>,
    message: String,
    detail: String,
    asset_amount: u64,
    stable_amount: u64,
    max_outcomes: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Get the actual fee paid
    let fee_paid = fee_payment.value();

    // Deposit DAO-level fee into proposal's escrow
    proposal.fee_escrow.join(fee_payment.into_balance());

    // Add the outcome with tracked fee
    add_outcome(
        proposal,
        message,
        detail,
        asset_amount,
        stable_amount,
        ctx.sender(),
        fee_paid,
        max_outcomes,
        clock,
    );
}

/// Initializes the market-related fields of the proposal.
/// Pools are now stored in MarketState, not Proposal
public fun initialize_market_fields<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    market_state_id: ID,
    escrow_id: ID,
    initialized_at: u64,
    liquidity_provider: address,
) {
    assert!(proposal.state == STATE_PREMARKET, EInvalidState);

    // Use option::fill to replace None with Some value
    option::fill(&mut proposal.market_state_id, market_state_id);
    option::fill(&mut proposal.escrow_id, escrow_id);
    option::fill(&mut proposal.timing.market_initialized_at, initialized_at);
    option::fill(&mut proposal.liquidity_provider, liquidity_provider);
    proposal.state = STATE_REVIEW; // Advance state to REVIEW
}

/// Emits the ProposalMarketInitialized event
public fun emit_market_initialized(
    proposal_id: ID,
    dao_id: ID,
    market_state_id: ID,
    escrow_id: ID,
    timestamp: u64,
) {
    event::emit(ProposalMarketInitialized {
        proposal_id,
        dao_id,
        market_state_id,
        escrow_id,
        timestamp,
    });
}

/// Takes the escrowed DAO-level fee balance out of the proposal
/// Used for refunding fees to losing outcome creators
public fun take_fee_escrow<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
): Balance<StableType> {
    let fee_balance = &mut proposal.fee_escrow;
    let amount = fee_balance.value();
    sui::balance::split(fee_balance, amount)
}

/// Get TWAPs from all pools via MarketState
/// Returns a reference to that oracle; aborts if not found.
public fun get_twaps_for_proposal<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    clock: &Clock,
): vector<u128> {
    let market_state = coin_escrow::get_market_state_mut(escrow);
    let pools = market_state::borrow_amm_pools_mut(market_state);
    let mut twaps = vector[];
    let mut i = 0;
    while (i < pools.length()) {
        let pool = &mut pools[i];
        let twap = pool.get_twap(clock);
        twaps.push_back(twap);
        i = i + 1;
    };
    twaps
}

/// Calculate current winner by INSTANT PRICE (fast flip detection)
/// Returns (winner_index, winner_price, spread)
/// Used for flip detection - faster than TWAP
public fun calculate_current_winner_by_price<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
): (u64, u128, u128) {
    let market_state = coin_escrow::get_market_state_mut(escrow);
    let pools = market_state::borrow_amm_pools_mut(market_state);
    let outcome_count = pools.length();

    assert!(outcome_count >= 2, EInvalidOutcome);

    // Get instant prices from all pools
    let mut winner_idx = 0u64;
    let mut winner_price = conditional_amm::get_current_price(&pools[0]);
    let mut second_price = 0u128;

    let mut i = 1u64;
    while (i < outcome_count) {
        let current_price = conditional_amm::get_current_price(&pools[i]);

        if (current_price > winner_price) {
            // New winner
            second_price = winner_price;
            winner_price = current_price;
            winner_idx = i;
        } else if (current_price > second_price) {
            // New second place
            second_price = current_price;
        };

        i = i + 1;
    };

    // Calculate spread (winner - second)
    let spread = if (winner_price > second_price) {
        winner_price - second_price
    } else {
        0u128
    };

    (winner_idx, winner_price, spread)
}

/// Calculate current winner by TWAP (for final resolution - manipulation resistant)
/// Returns (winner_index, winner_twap, spread)
/// Used for final resolution - slower but more secure
public fun calculate_current_winner<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    clock: &Clock,
): (u64, u128, u128) {
    // Get TWAPs from all markets
    let twaps = get_twaps_for_proposal(proposal, escrow, clock);
    let outcome_count = twaps.length();

    assert!(outcome_count >= 2, EInvalidOutcome);  // Need at least 2 outcomes

    // Find highest and second-highest TWAPs
    let mut winner_idx = 0u64;
    let mut winner_twap = *twaps.borrow(0);
    let mut second_twap = 0u128;

    let mut i = 1u64;
    while (i < outcome_count) {
        let current_twap = *twaps.borrow(i);

        if (current_twap > winner_twap) {
            // New winner found
            second_twap = winner_twap;
            winner_twap = current_twap;
            winner_idx = i;
        } else if (current_twap > second_twap) {
            // New second place
            second_twap = current_twap;
        };

        i = i + 1;
    };

    // Calculate spread (winner - second)
    let spread = if (winner_twap > second_twap) {
        winner_twap - second_twap
    } else {
        0u128
    };

    (winner_idx, winner_twap, spread)
}

// === Private Functions ===

fun get_pool_mut(pools: &mut vector<LiquidityPool>, outcome_idx: u8): &mut LiquidityPool {
    let mut i = 0;
    let len = pools.length();
    while (i < len) {
        let pool = &mut pools[i];
        if (pool.get_outcome_idx() == outcome_idx) {
            return pool
        };
        i = i + 1;
    };
    abort EPoolNotFound
}

// === View Functions ===

public fun is_finalized<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): bool {
    proposal.state == STATE_FINALIZED
}

public fun get_twap_prices<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): &vector<u128> {
    &proposal.twap_config.twap_prices
}

public fun get_last_twap_update<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): u64 {
    proposal.timing.last_twap_update
}

/// Get TWAP for a specific outcome by index
public fun get_twap_by_outcome<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    outcome_index: u64,
): u128 {
    // Add defensive checks
    assert!(proposal.state == STATE_FINALIZED, ENotFinalized);
    let twap_prices = &proposal.twap_config.twap_prices;
    assert!(!twap_prices.is_empty(), ETwapNotSet);
    assert!(outcome_index < twap_prices.length(), EOutcomeOutOfBounds);
    *twap_prices.borrow(outcome_index)
}

/// Get the TWAP of the winning outcome
public fun get_winning_twap<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): u128 {
    // Add defensive checks
    assert!(proposal.state == STATE_FINALIZED, ENotFinalized);
    assert!(proposal.outcome_data.winning_outcome.is_some(), EInvalidState);
    assert!(!proposal.twap_config.twap_prices.is_empty(), ETwapNotSet);
    let winning_outcome = *proposal.outcome_data.winning_outcome.borrow();
    get_twap_by_outcome(proposal, winning_outcome)
}

public fun state<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u8 {
    proposal.state
}

/// Check if proposal is currently live (trading active)
public fun is_live<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>
): bool {
    proposal.state == STATE_TRADING
}

public fun get_winning_outcome<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): u64 {
    assert!(proposal.outcome_data.winning_outcome.is_some(), EInvalidState);
    *proposal.outcome_data.winning_outcome.borrow()
}

/// Checks if winning outcome has been set
public fun is_winning_outcome_set<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): bool {
    proposal.outcome_data.winning_outcome.is_some()
}

/// Returns the treasury address where fees for failed proposals are sent.
public fun treasury_address<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): address {
    proposal.treasury_address
}

public fun get_id<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): ID {
    proposal.id.to_inner()
}

public fun escrow_id<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): ID {
    assert!(proposal.escrow_id.is_some(), EInvalidState);
    *proposal.escrow_id.borrow()
}

public fun market_state_id<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): ID {
    assert!(proposal.market_state_id.is_some(), EInvalidState);
    *proposal.market_state_id.borrow()
}

public fun get_market_initialized_at<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u64 {
    assert!(proposal.timing.market_initialized_at.is_some(), EInvalidState);
    *proposal.timing.market_initialized_at.borrow()
}

public fun outcome_count<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u64 {
    proposal.outcome_data.outcome_count
}

/// Alias for outcome_count for better readability
public fun get_num_outcomes<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u64 {
    proposal.outcome_data.outcome_count
}

public fun proposer<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): address {
    proposal.proposer
}

public fun created_at<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u64 {
    proposal.timing.created_at
}

public fun get_metadata<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): &String {
    &proposal.metadata
}

public fun get_introduction_details<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): &String {
    &proposal.introduction_details
}

public fun get_amm_pool_ids<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
): vector<ID> {
    let mut ids = vector[];
    let mut i = 0;
    let market_state = coin_escrow::get_market_state(escrow);
    let pools = market_state::borrow_amm_pools(market_state);
    let len = pools.length();
    while (i < len) {
        let pool = &pools[i];
        ids.push_back(pool.get_id());
        i = i + 1;
    };
    ids
}

public fun get_pool_mut_by_outcome<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u8,
): &mut LiquidityPool {
    assert!((outcome_idx as u64) < proposal.outcome_data.outcome_count, EOutcomeOutOfBounds);
    let market_state = coin_escrow::get_market_state_mut(escrow);
    let pools_mut = market_state::borrow_amm_pools_mut(market_state);
    get_pool_mut(pools_mut, outcome_idx)
}

public fun get_pool_by_outcome<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
    outcome_idx: u8,
): &LiquidityPool {
    assert!((outcome_idx as u64) < proposal.outcome_data.outcome_count, EOutcomeOutOfBounds);
    let market_state = coin_escrow::get_market_state(escrow);
    let pools = market_state::borrow_amm_pools(market_state);
    let mut i = 0;
    let len = pools.length();
    while (i < len) {
        let pool = &pools[i];
        if (pool.get_outcome_idx() == outcome_idx) {
            return pool
        };
        i = i + 1;
    };
    abort EPoolNotFound
}

// LP caps no longer needed - using conditional tokens for LP

// Pool and LP cap getter no longer needed - using conditional tokens for LP

public fun get_state<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u8 {
    proposal.state
}

public fun get_dao_id<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): ID {
    proposal.dao_id
}


public fun proposal_id<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): ID {
    proposal.id.to_inner()
}

public fun get_amm_pools<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
): &vector<LiquidityPool> {
    let market_state = coin_escrow::get_market_state(escrow);
    market_state::borrow_amm_pools(market_state)
}

public fun get_amm_pools_mut<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
): &mut vector<LiquidityPool> {
    let market_state = coin_escrow::get_market_state_mut(escrow);
    market_state::borrow_amm_pools_mut(market_state)
}

public fun get_created_at<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u64 {
    proposal.timing.created_at
}

public fun get_review_period_ms<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): u64 {
    proposal.timing.review_period_ms
}

public fun get_trading_period_ms<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): u64 {
    proposal.timing.trading_period_ms
}

public fun get_twap_threshold<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): SignedU128 {
    proposal.twap_config.twap_threshold
}

public fun get_twap_start_delay<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u64 {
    proposal.timing.twap_start_delay
}

public fun get_twap_initial_observation<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u128 {
    proposal.twap_config.twap_initial_observation
}

public fun get_twap_step_max<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u64 {
    proposal.twap_config.twap_step_max
}

public fun get_amm_total_fee_bps<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): u64 {
    proposal.amm_total_fee_bps
}


/// Returns the parameters needed to initialize the market after the premarket phase.
public fun get_market_init_params<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): (u64, &vector<String>, &vector<u64>, &vector<u64>) {
    (
        proposal.outcome_data.outcome_count,
        &proposal.outcome_data.outcome_messages,
        &proposal.liquidity_config.asset_amounts,
        &proposal.liquidity_config.stable_amounts,
    )
}

// === Package Functions ===

/// Advances the proposal state based on elapsed time
/// Transitions from REVIEW to TRADING when review period ends
/// Returns true if state was changed
public fun advance_state<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
): bool {
    let current_time = clock.timestamp_ms();
    // Use market_initialized_at for timing calculations instead of created_at
    // This ensures premarket proposals get proper review/trading periods after initialization
    let base_timestamp = if (proposal.timing.market_initialized_at.is_some()) {
        *proposal.timing.market_initialized_at.borrow()
    } else {
        // Fallback to created_at if market not initialized (shouldn't happen in normal flow)
        proposal.timing.created_at
    };
    
    // Check if we should transition from REVIEW to TRADING
    if (proposal.state == STATE_REVIEW) {
        let review_end = base_timestamp + proposal.timing.review_period_ms;
        if (current_time >= review_end) {
            proposal.state = STATE_TRADING;

            // Start trading in the market state
            let market = coin_escrow::get_market_state_mut(escrow);
            market_state::start_trading(market, proposal.timing.trading_period_ms, clock);

            // Extract market_id and trading_start_time before borrowing pools
            let market_id = market_state::market_id(market);
            let trading_start_time = market_state::get_trading_start(market);

            // Set oracle start time for all pools when trading begins
            let pools = market_state::borrow_amm_pools_mut(market);
            let mut i = 0;
            while (i < pools.length()) {
                let pool = &mut pools[i];
                conditional_amm::set_oracle_start_time(pool, market_id, trading_start_time);
                i = i + 1;
            };

            // NOTE: Quantum split and registration happens in proposal_lifecycle

            return true
        };
    };
    
    // Check if we should transition from TRADING to ended
    if (proposal.state == STATE_TRADING) {
        let trading_end = base_timestamp + proposal.timing.review_period_ms + proposal.timing.trading_period_ms;
        if (current_time >= trading_end) {
            // End trading in the market state
            let market = coin_escrow::get_market_state_mut(escrow);
            if (market_state::is_trading_active(market)) {
                market_state::end_trading(market, clock);
            };
            // Note: Full finalization requires calculating winner and is done separately
            // NOTE: spot pool registration is cleared in proposal_lifecycle
            return true
        };
    };
    
    false
}

public fun set_state<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    new_state: u8,
) {
    proposal.state = new_state;
}

public fun set_twap_prices<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    twap_prices: vector<u128>,
) {
    proposal.twap_config.twap_prices = twap_prices;
}

public fun set_last_twap_update<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    timestamp: u64,
) {
    proposal.timing.last_twap_update = timestamp;
}

public fun set_winning_outcome<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    outcome: u64,
) {
    proposal.outcome_data.winning_outcome = option::some(outcome);
}

/// Finalize the proposal with the winning outcome computed on-chain
/// This combines computing the winner from TWAP, setting the winning outcome and updating state atomically
#[test_only]
public fun finalize_proposal<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    clock: &Clock,
) {
    // Ensure we're in a state that can be finalized
    assert!(proposal.state == STATE_TRADING || proposal.state == STATE_REVIEW, EInvalidState);
    
    // If still in trading, end trading first
    if (proposal.state == STATE_TRADING) {
        let market = coin_escrow::get_market_state_mut(escrow);
        if (market_state::is_trading_active(market)) {
            market_state::end_trading(market, clock);
        };
    };
    
    // Critical fix: Compute the winning outcome on-chain from TWAP prices
    // Get TWAP prices from all pools
    let twap_prices = get_twaps_for_proposal(proposal, escrow, clock);

    // For a simple YES/NO proposal, compare the YES TWAP to the threshold
    let winning_outcome = if (twap_prices.length() >= 2) {
        let yes_twap = *twap_prices.borrow(OUTCOME_ACCEPTED);
        let threshold = get_effective_twap_threshold(proposal);
        let yes_signed = signed::from_u128(yes_twap);

        // If YES TWAP exceeds threshold, YES wins
        if (signed::compare(&yes_signed, &threshold) == signed::ordering_greater()) {
            OUTCOME_ACCEPTED
        } else {
            OUTCOME_REJECTED
        }
    } else {
        // For single-outcome or other configs, default to first outcome
        // This should be revisited based on your specific requirements
        0
    };
    
    // Set the winning outcome
    proposal.outcome_data.winning_outcome = option::some(winning_outcome);
    
    // Update state to finalized
    proposal.state = STATE_FINALIZED;
    
    // Finalize the market state
    let market = coin_escrow::get_market_state_mut(escrow);
    market_state::finalize(market, winning_outcome, clock);
}

public fun get_outcome_creators<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): &vector<address> {
    &proposal.outcome_data.outcome_creators
}

/// Get the address of the creator for a specific outcome
public fun get_outcome_creator<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    outcome_index: u64
): address {
    assert!(outcome_index < proposal.outcome_data.outcome_count, EOutcomeOutOfBounds);
    *vector::borrow(&proposal.outcome_data.outcome_creators, outcome_index)
}

/// Get the fee paid by the creator for a specific outcome
public fun get_outcome_creator_fee<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    outcome_index: u64
): u64 {
    assert!(outcome_index < proposal.outcome_data.outcome_count, EOutcomeOutOfBounds);
    *vector::borrow(&proposal.outcome_data.outcome_creator_fees, outcome_index)
}

/// Get all outcome creator fees
public fun get_outcome_creator_fees<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>
): &vector<u64> {
    &proposal.outcome_data.outcome_creator_fees
}

/// Get proposal start time for early resolve calculations
/// Returns market_initialized_at if available, otherwise created_at
public(package) fun get_start_time_for_early_resolve<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>
): u64 {
    if (proposal.timing.market_initialized_at.is_some()) {
        *proposal.timing.market_initialized_at.borrow()
    } else {
        proposal.timing.created_at
    }
}

public fun get_liquidity_provider<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): Option<address> {
    proposal.liquidity_provider
}

public fun get_proposer<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): address {
    proposal.proposer
}

/// Check if this proposal used admin quota/budget (excludes from creator rewards)
public fun get_used_quota<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): bool {
    proposal.used_quota
}

/// Check if this proposal's liquidity is in withdraw-only mode
public fun is_withdraw_only<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): bool {
    proposal.withdraw_only_mode
}

/// Set withdraw-only mode - prevents auto-reinvestment in next proposal
/// Only callable by the liquidity provider
public entry fun set_withdraw_only_mode<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    withdraw_only: bool,
    ctx: &TxContext,
) {
    assert!(proposal.liquidity_provider.is_some(), ENotLiquidityProvider);
    let provider = *proposal.liquidity_provider.borrow();
    assert!(tx_context::sender(ctx) == provider, ENotLiquidityProvider);
    proposal.withdraw_only_mode = withdraw_only;
}

public fun get_outcome_messages<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): &vector<String> {
    &proposal.outcome_data.outcome_messages
}

/// Get the intent spec for a specific outcome
public fun get_intent_spec_for_outcome<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    outcome_index: u64
): &Option<InitActionSpecs> {
    vector::borrow(&proposal.outcome_data.intent_specs, outcome_index)
}


/// Take (move out) the intent spec for a specific outcome and clear the slot.
public fun take_intent_spec_for_outcome<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    outcome_index: u64
): Option<InitActionSpecs> {
    assert!(outcome_index < proposal.outcome_data.outcome_count, EOutcomeOutOfBounds);
    let slot = vector::borrow_mut(&mut proposal.outcome_data.intent_specs, outcome_index);
    let old_value = *slot;
    *slot = option::none();
    old_value
}

/// Mint a scoped cancel witness by taking (moving) the spec out of the slot.
/// Returns None if no spec was set for that outcome.
/// This witness can only be created once per (proposal, outcome) pair.
public fun make_cancel_witness<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    outcome_index: u64
): option::Option<CancelWitness> {
    assert!(outcome_index < proposal.outcome_data.outcome_count, EOutcomeOutOfBounds);
    let addr = object::uid_to_address(&proposal.id);
    let mut spec_opt = take_intent_spec_for_outcome(proposal, outcome_index);
    if (option::is_some(&spec_opt)) {
        let action_count_slot =
            vector::borrow_mut(&mut proposal.outcome_data.actions_per_outcome, outcome_index);
        *action_count_slot = 0;
        option::destroy_some(spec_opt);
        option::some(CancelWitness {
            proposal: addr,
            outcome_index,
        })
    } else {
        option::none<CancelWitness>()
    }
}

/// Set the intent spec for a specific outcome and track action count
/// This function:
/// 1. Validates the IntentSpec action count
/// 2. Stores the IntentSpec in the outcome slot
public fun set_intent_spec_for_outcome<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    outcome_index: u64,
    intent_spec: InitActionSpecs,
    max_actions_per_outcome: u64,
) {
    assert!(outcome_index < proposal.outcome_data.outcome_count, EOutcomeOutOfBounds);

    let spec_slot = vector::borrow_mut(&mut proposal.outcome_data.intent_specs, outcome_index);
    let action_count = vector::borrow_mut(&mut proposal.outcome_data.actions_per_outcome, outcome_index);

    // Get action count from the spec
    let num_actions = action_specs::action_count(&intent_spec);

    // Check outcome limit only
    assert!(num_actions <= max_actions_per_outcome, ETooManyActions);

    // Set the intent spec and update count
    *spec_slot = option::some(intent_spec);
    *action_count = num_actions;
}


/// Check if an outcome has an intent spec
public fun has_intent_spec<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    outcome_index: u64
): bool {
    assert!(outcome_index < proposal.outcome_data.outcome_count, EOutcomeOutOfBounds);
    option::is_some(vector::borrow(&proposal.outcome_data.intent_specs, outcome_index))
}

/// Get the number of actions for a specific outcome
public fun get_actions_for_outcome<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    outcome_index: u64
): u64 {
    assert!(outcome_index < proposal.outcome_data.outcome_count, EOutcomeOutOfBounds);
    *vector::borrow(&proposal.outcome_data.actions_per_outcome, outcome_index)
}

/// Clear the intent spec for an outcome and reset action count
public fun clear_intent_spec_for_outcome<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    outcome_index: u64,
) {
    assert!(outcome_index < proposal.outcome_data.outcome_count, EOutcomeOutOfBounds);

    let spec_slot = vector::borrow_mut(&mut proposal.outcome_data.intent_specs, outcome_index);
    let action_count = vector::borrow_mut(&mut proposal.outcome_data.actions_per_outcome, outcome_index);

    if (option::is_some(spec_slot)) {
        // Clear the intent spec
        *spec_slot = option::none();

        // Reset this outcome's action count
        *action_count = 0;
    };
}


/// Emits the ProposalOutcomeMutated event
public fun emit_outcome_mutated(
    proposal_id: ID,
    dao_id: ID,
    outcome_idx: u64,
    old_creator: address,
    new_creator: address,
    timestamp: u64,
) {
    event::emit(ProposalOutcomeMutated {
        proposal_id,
        dao_id,
        outcome_idx,
        old_creator,
        new_creator,
        timestamp,
    });
}

public fun set_outcome_creator<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    outcome_idx: u64,
    creator: address,
) {
    assert!(outcome_idx < proposal.outcome_data.outcome_count, EOutcomeOutOfBounds);
    let creator_ref = vector::borrow_mut(&mut proposal.outcome_data.outcome_creators, outcome_idx);
    *creator_ref = creator;
}

// === Test Functions ===

#[test_only]
/// Create a minimal proposal for testing
public fun new_for_testing<AssetType, StableType>(
    dao_id: address,
    proposer: address,
    liquidity_provider: Option<address>,
    title: String,
    introduction_details: String,
    metadata: String,
    outcome_messages: vector<String>,
    initial_outcome_details: vector<String>,
    outcome_creators: vector<address>,
    outcome_count: u8,
    review_period_ms: u64,
    trading_period_ms: u64,
    min_asset_liquidity: u64,
    min_stable_liquidity: u64,
    twap_start_delay: u64,
    twap_initial_observation: u128,
    twap_step_max: u64,
    twap_threshold: SignedU128,
    amm_total_fee_bps: u64,
    winning_outcome: Option<u64>,
    treasury_address: address,
    intent_specs: vector<Option<InitActionSpecs>>,
    ctx: &mut TxContext
): Proposal<AssetType, StableType> {
    Proposal {
        id: object::new(ctx),
        dao_id: object::id_from_address(dao_id),
        queued_proposal_id: object::id_from_address(@0x0),
        state: STATE_PREMARKET,
        proposer,
        liquidity_provider,
        withdraw_only_mode: false,
        used_quota: false, // Default to false for testing
        sponsored_by: option::none(), // No sponsorship by default
        sponsor_threshold_reduction: signed::from_u64(0), // No reduction by default
        escrow_id: option::none(),
        market_state_id: option::none(),
        conditional_treasury_caps: bag::new(ctx),
        conditional_metadata: bag::new(ctx),
        title,
        introduction_details,
        details: initial_outcome_details,
        metadata,
        timing: ProposalTiming {
            created_at: 0,
            market_initialized_at: option::none(),
            review_period_ms,
            trading_period_ms,
            last_twap_update: 0,
            twap_start_delay,
        },
        liquidity_config: LiquidityConfig {
            min_asset_liquidity,
            min_stable_liquidity,
            asset_amounts: vector::empty(),
            stable_amounts: vector::empty(),
        },
        twap_config: TwapConfig {
            twap_prices: vector::empty(),
            twap_initial_observation,
            twap_step_max,
            twap_threshold,
        },
        outcome_data: OutcomeData {
            outcome_count: outcome_count as u64,
            outcome_messages,
            outcome_creators,
            outcome_creator_fees: vector::tabulate!(outcome_count as u64, |_| 0u64),  // Initialize with 0 fees
            intent_specs,
            actions_per_outcome: vector::tabulate!(outcome_count as u64, |_| 0),
            winning_outcome,
        },
        amm_total_fee_bps,
        conditional_liquidity_ratio_percent: 50,  // 50% (base 100, not bps!)
        fee_escrow: balance::zero(), // No fees for test proposals
        treasury_address,
    }
}

#[test_only]
/// Gets a mutable reference to the token escrow of the proposal
public fun test_get_coin_escrow<AssetType, StableType>(
    escrow: &mut coin_escrow::TokenEscrow<AssetType, StableType>,
): &mut coin_escrow::TokenEscrow<AssetType, StableType> {
    escrow
}

#[test_only]
/// Gets the market state through the token escrow
public fun test_get_market_state<AssetType, StableType>(
    escrow: &coin_escrow::TokenEscrow<AssetType, StableType>,
): &market_state::MarketState {
    escrow.get_market_state()
}


// === Additional View Functions ===

/// Get proposal ID
public fun id<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): ID {
    object::id(proposal)
}

/// Get proposal address (for testing)
public fun id_address<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): address {
    object::uid_to_address(&proposal.id)
}

// === Conditional Coin Management ===

/// Add a conditional coin treasury cap and metadata to proposal
/// Must be called once per outcome per side (asset/stable)
/// The coin will be validated and its metadata updated according to DAO config
public fun add_conditional_coin<AssetType, StableType, ConditionalCoinType>(
    proposal: &mut Proposal<AssetType, StableType>,
    outcome_index: u64,
    is_asset: bool,  // true for asset-conditional, false for stable-conditional
    mut treasury_cap: TreasuryCap<ConditionalCoinType>,
    mut metadata: CoinMetadata<ConditionalCoinType>,
    coin_config: &ConditionalCoinConfig,
    asset_type_name: &String,  // Name of AssetType (e.g., "SUI")
    stable_type_name: &String, // Name of StableType (e.g., "USDC")
) {
    assert!(proposal.state == STATE_PREMARKET, EInvalidState);
    assert!(outcome_index < proposal.outcome_data.outcome_count, EOutcomeOutOfBounds);

    // Create key for this conditional coin
    let key = ConditionalCoinKey { outcome_index, is_asset };

    // Check not already set
    assert!(!bag::contains(&proposal.conditional_treasury_caps, key), EConditionalCoinAlreadySet);

    // Validate coin meets requirements: supply must be zero
    assert!(coin::total_supply(&treasury_cap) == 0, ESupplyNotZero);

    // Update metadata with DAO naming pattern: c_<outcome>_<ASSET|STABLE>
    update_conditional_coin_metadata(
        &mut metadata,
        coin_config,
        outcome_index,
        if (is_asset) { asset_type_name } else { stable_type_name },
    );

    // Store in bags
    bag::add(&mut proposal.conditional_treasury_caps, key, treasury_cap);
    bag::add(&mut proposal.conditional_metadata, key, metadata);
}

/// Update conditional coin metadata with DAO naming pattern
/// Pattern: c_<outcome_index>_<ASSET_NAME>
fun update_conditional_coin_metadata<ConditionalCoinType>(
    metadata: &mut CoinMetadata<ConditionalCoinType>,
    coin_config: &ConditionalCoinConfig,
    outcome_index: u64,
    base_coin_name: &String,
) {
    use std::ascii;
    use sui::url;

    // Build name: prefix + outcome_index + _ + base_coin_name
    let mut name_bytes = vector::empty<u8>();

    // Add prefix (e.g., "c_") if configured
    let prefix_opt = dao_config::coin_name_prefix(coin_config);
    if (prefix_opt.is_some()) {
        let prefix = prefix_opt.destroy_some();
        let prefix_bytes = ascii::as_bytes(&prefix);
        let mut i = 0;
        while (i < prefix_bytes.length()) {
            name_bytes.push_back(*prefix_bytes.borrow(i));
            i = i + 1;
        };
    } else {
        prefix_opt.destroy_none();
    };

    // Add outcome index if configured
    if (dao_config::use_outcome_index(coin_config)) {
        // Convert outcome_index to string
        let index_str = u64_to_ascii(outcome_index);
        let index_bytes = ascii::as_bytes(&index_str);
        let mut i = 0;
        while (i < index_bytes.length()) {
            name_bytes.push_back(*index_bytes.borrow(i));
            i = i + 1;
        };
        name_bytes.push_back(95u8); // '_' character
    };

    // Add base coin name
    {
        let base_bytes = string::as_bytes(base_coin_name);
        let mut i = 0;
        while (i < base_bytes.length()) {
            name_bytes.push_back(*base_bytes.borrow(i));
            i = i + 1;
        };
    };

    // Update metadata (need to use coin::update_* functions if available)
    // For now, just validate - actual metadata update requires special capabilities
    // This will be handled when we integrate with coin framework properly
}

/// Helper: Convert u64 to ASCII string
fun u64_to_ascii(mut num: u64): AsciiString {
    use std::ascii;

    if (num == 0) {
        return ascii::string(b"0")
    };

    let mut digits = vector::empty<u8>();
    while (num > 0) {
        let digit = ((num % 10) as u8) + 48; // ASCII '0' = 48
        vector::push_back(&mut digits, digit);
        num = num / 10;
    };

    // Reverse digits
    vector::reverse(&mut digits);
    ascii::string(digits)
}

// === LP Preferences Dynamic Field Management ===

/// Get mutable reference to proposal's UID for dynamic field operations
/// Public to allow other packages (e.g., futarchy_governance) to use dynamic fields
public fun borrow_uid_mut<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>
): &mut UID {
    &mut proposal.id
}

/// Get immutable reference to proposal's UID for dynamic field reads
/// Public to allow other packages (e.g., futarchy_governance) to use dynamic fields
public fun borrow_uid<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>
): &UID {
    &proposal.id
}

// === Sponsorship Functions ===

/// Get the sponsor address (if any)
public fun get_sponsored_by<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>
): Option<address> {
    proposal.sponsored_by
}

/// Get the threshold reduction applied by sponsorship
public fun get_sponsor_threshold_reduction<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>
): SignedU128 {
    proposal.sponsor_threshold_reduction
}

/// Check if proposal is sponsored
public fun is_sponsored<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>
): bool {
    proposal.sponsored_by.is_some()
}

/// Set sponsorship information on a proposal
/// Can be called at any time before proposal is finalized
/// SECURITY: Only callable before proposal is finalized
public fun set_sponsorship<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    sponsor: address,
    threshold_reduction: SignedU128,
) {
    // Only restriction: cannot sponsor finalized proposals
    assert!(proposal.state != STATE_FINALIZED, EInvalidState);

    // Prevent double-sponsorship
    assert!(proposal.sponsored_by.is_none(), EAlreadySponsored);

    proposal.sponsored_by = option::some(sponsor);
    proposal.sponsor_threshold_reduction = threshold_reduction;
}

/// Clear sponsorship information (for refunds on eviction/cancellation)
/// SECURITY: Can be called to reset sponsorship
public fun clear_sponsorship<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
) {
    proposal.sponsored_by = option::none();
    proposal.sponsor_threshold_reduction = signed::from_u64(0);
}

/// Get the effective TWAP threshold for this proposal (base threshold - sponsor reduction)
/// Note: Thresholds CAN be negative in futarchy (allowing proposals to pass if TWAP goes below threshold)
/// The reduction is applied as: effective = base - reduction
/// If the reduction would make the threshold excessively negative, cap at a reasonable minimum
public fun get_effective_twap_threshold<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>
): SignedU128 {
    let base_threshold = proposal.twap_config.twap_threshold;

    // If not sponsored, return base threshold
    if (!proposal.sponsored_by.is_some()) {
        return base_threshold
    };

    // Apply sponsorship reduction
    let reduction = &proposal.sponsor_threshold_reduction;

    // Handle the subtraction: base - reduction
    // Case 1: Both same sign
    let base_neg = signed::is_negative(&base_threshold);
    let red_neg = signed::is_negative(reduction);
    let base_mag = signed::magnitude(&base_threshold);
    let red_mag = signed::magnitude(reduction);

    if (base_neg == red_neg) {
        // Same sign: base - reduction = base + (-reduction)
        // Positive - Positive: subtract magnitudes
        // Negative - Negative: add magnitudes (more negative)
        if (!base_neg) {
            // Both positive: base - reduction
            if (base_mag >= red_mag) {
                signed::from_parts(base_mag - red_mag, false)
            } else {
                // Result would be negative
                signed::from_parts(red_mag - base_mag, true)
            }
        } else {
            // Both negative: -(|base| + |reduction|)
            signed::from_parts(base_mag + red_mag, true)
        }
    } else {
        // Different signs: base - reduction = base + (-reduction)
        // Positive - Negative: add magnitudes (more positive)
        // Negative - Positive: subtract magnitudes (more negative)
        if (!base_neg) {
            // Positive base, negative reduction: base - (-red) = base + red
            signed::from_parts(base_mag + red_mag, false)
        } else {
            // Negative base, positive reduction: -|base| - red = -(|base| + red)
            signed::from_parts(base_mag + red_mag, true)
        }
    }
}

#[test_only]
/// Simplified test helper: creates a REAL proposal with sensible defaults
/// Can configure state (FINALIZED), outcome_count, and winning_outcome for testing
public fun create_test_proposal<AssetType, StableType>(
    outcome_count: u8,
    winning_outcome: u64,
    is_finalized: bool,
    ctx: &mut TxContext,
): Proposal<AssetType, StableType> {
    use std::string;

    let outcome_messages = vector::tabulate!(outcome_count as u64, |i| {
        string::utf8(b"Outcome")
    });

    let outcome_creators = vector::tabulate!(outcome_count as u64, |_| @0xAAA);

    let intent_specs = vector::tabulate!(outcome_count as u64, |_| option::none<InitActionSpecs>());

    let mut proposal = new_for_testing<AssetType, StableType>(
        @0x1,                       // dao_id
        @0x2,                       // proposer
        option::some(@0x3),         // liquidity_provider
        string::utf8(b"Test"),      // title
        string::utf8(b"Introduction Details"),  // introduction_details
        string::utf8(b"Metadata"),  // metadata
        outcome_messages,
        outcome_messages,           // initial_outcome_details (reuse outcome_messages)
        outcome_creators,
        outcome_count,
        60000,                      // review_period_ms (1 min)
        120000,                     // trading_period_ms (2 min)
        1000,                       // min_asset_liquidity
        1000,                       // min_stable_liquidity
        30000,                      // twap_start_delay
        1000000000000000000u128,    // twap_initial_observation
        10000,                      // twap_step_max
        signed::from_u128(500000000000000000u128),      // twap_threshold
        30,                         // amm_total_fee_bps (0.3%)
        option::some(winning_outcome),
        @0x4,                       // treasury_address
        intent_specs,
        ctx
    );

    if (is_finalized) {
        set_state(&mut proposal, STATE_FINALIZED);
    };

    proposal
}

#[test_only]
/// Destroy a proposal for testing - handles cleanup of all internal structures
public fun destroy_for_testing<AssetType, StableType>(proposal: Proposal<AssetType, StableType>) {
    let Proposal {
        id,
        queued_proposal_id: _,
        state: _,
        dao_id: _,
        proposer: _,
        liquidity_provider: _,
        withdraw_only_mode: _,
        used_quota: _,
        sponsored_by: _,
        sponsor_threshold_reduction: _,
        escrow_id: _,
        market_state_id: _,
        conditional_treasury_caps,
        conditional_metadata,
        title: _,
        introduction_details: _,
        details: _,
        metadata: _,
        timing: ProposalTiming {
            created_at: _,
            market_initialized_at: _,
            review_period_ms: _,
            trading_period_ms: _,
            last_twap_update: _,
            twap_start_delay: _,
        },
        liquidity_config: LiquidityConfig {
            min_asset_liquidity: _,
            min_stable_liquidity: _,
            asset_amounts: _,
            stable_amounts: _,
        },
        twap_config: TwapConfig {
            twap_prices: _,
            twap_initial_observation: _,
            twap_step_max: _,
            twap_threshold: _,
        },
        outcome_data: OutcomeData {
            outcome_count: _,
            outcome_messages: _,
            outcome_creators: _,
            outcome_creator_fees: _,
            intent_specs: _,
            actions_per_outcome: _,
            winning_outcome: _,
        },
        amm_total_fee_bps: _,
        conditional_liquidity_ratio_percent: _,
        fee_escrow,
        treasury_address: _,
    } = proposal;

    // Destroy bags (must be empty for testing)
    bag::destroy_empty(conditional_treasury_caps);
    bag::destroy_empty(conditional_metadata);
    fee_escrow.destroy_zero();

    object::delete(id);
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

module futarchy_markets_core::fee;

use std::ascii::String as AsciiString;
use std::type_name::{Self, TypeName};
use std::u64;
use sui::balance::{Self, Balance};
use sui::bcs;
use sui::clock::Clock;
use sui::coin::{Self, Coin};
use sui::dynamic_field;
use sui::event;
use sui::sui::SUI;
use sui::table::{Self, Table};
use sui::transfer::{public_share_object, public_transfer};

// === Introduction ===
// Manages all fees earnt by the protocol. It is also the interface for admin fee withdrawal

// === Errors ===
const EInvalidPayment: u64 = 0;
const EStableTypeNotFound: u64 = 1;
const EBadWitness: u64 = 2;
const ERecurringFeeNotDue: u64 = 3;
const EWrongStableTypeForFee: u64 = 4;
const EInsufficientTreasuryBalance: u64 = 5;
const EArithmeticOverflow: u64 = 6;
const EInvalidAdminCap: u64 = 7;
const EInvalidRecoveryFee: u64 = 9;
const EFeeExceedsHardCap: u64 = 10;
const EWrongStableCoinType: u64 = 11;
const EFeeExceedsTenXCap: u64 = 12;

// === Constants ===
const DEFAULT_DAO_CREATION_FEE: u64 = 10_000;
const DEFAULT_PROPOSAL_CREATION_FEE_PER_OUTCOME: u64 = 1000;
const DEFAULT_VERIFICATION_FEE: u64 = 10_000; // Default fee for level 1
const DEFAULT_LAUNCHPAD_CREATION_FEE: u64 = 100; // 100 MIST for testing
const MONTHLY_FEE_PERIOD_MS: u64 = 2_592_000_000; // 30 days
const FEE_UPDATE_DELAY_MS: u64 = 15_552_000_000; // 6 months (180 days)
const MAX_FEE_COLLECTION_PERIOD_MS: u64 = 7_776_000_000; // 90 days (3 months) - max retroactive collection
const MAX_FEE_MULTIPLIER: u64 = 10; // Maximum 10x increase from baseline
const FEE_BASELINE_RESET_PERIOD_MS: u64 = 15_552_000_000; // 6 months - baseline resets after this
// Remove ABSOLUTE_MAX_MONTHLY_FEE in V3 this is jsut here to build up trust
// Dont want to limit fee as platform gets more mature
const ABSOLUTE_MAX_MONTHLY_FEE: u64 = 10_000_000_000; // 10,000 USDC (6 decimals)

// === Structs ===

public struct FEE has drop {}

public struct FeeManager has key, store {
    id: UID,
    admin_cap_id: ID,
    dao_creation_fee: u64,
    proposal_creation_fee_per_outcome: u64,
    verification_fees: Table<u8, u64>, // Dynamic table mapping level -> fee
    sui_balance: Balance<SUI>,
    launchpad_creation_fee: u64, // Fee for creating a launchpad
}

public struct FeeAdminCap has key, store {
    id: UID,
}

/// Stores fee amounts for a specific coin type
public struct CoinFeeConfig has store {
    coin_type: TypeName,
    decimals: u8,
    dao_creation_fee: u64,
    proposal_creation_fee_per_outcome: u64,
    verification_fees: Table<u8, u64>,
    // Pending updates with 6-month delay
    pending_creation_fee: Option<u64>,
    pending_proposal_fee: Option<u64>,
    pending_fees_effective_timestamp: Option<u64>,
    // 10x cap tracking - baseline fees that reset every 6 months
    creation_fee_baseline: u64,
    proposal_fee_baseline: u64,
    baseline_reset_timestamp: u64,
}

// === Events ===
public struct FeesWithdrawn has copy, drop {
    amount: u64,
    recipient: address,
    timestamp: u64,
}

public struct DAOCreationFeeUpdated has copy, drop {
    old_fee: u64,
    new_fee: u64,
    admin: address,
    timestamp: u64,
}

public struct ProposalCreationFeeUpdated has copy, drop {
    old_fee: u64,
    new_fee_per_outcome: u64,
    admin: address,
    timestamp: u64,
}

public struct VerificationFeeUpdated has copy, drop {
    level: u8,
    old_fee: u64,
    new_fee: u64,
    admin: address,
    timestamp: u64,
}

public struct VerificationLevelAdded has copy, drop {
    level: u8,
    fee: u64,
    admin: address,
    timestamp: u64,
}

public struct VerificationLevelRemoved has copy, drop {
    level: u8,
    admin: address,
    timestamp: u64,
}

public struct DAOCreationFeeCollected has copy, drop {
    amount: u64,
    payer: address,
    timestamp: u64,
}

public struct ProposalCreationFeeCollected has copy, drop {
    amount: u64,
    payer: address,
    timestamp: u64,
}

public struct LaunchpadCreationFeeCollected has copy, drop {
    amount: u64,
    payer: address,
    timestamp: u64,
}

public struct VerificationFeeCollected has copy, drop {
    level: u8,
    amount: u64,
    payer: address,
    timestamp: u64,
}

public struct StableFeesCollected has copy, drop {
    amount: u64,
    stable_type: AsciiString,
    proposal_id: ID,
    timestamp: u64,
}

public struct StableFeesWithdrawn has copy, drop {
    amount: u64,
    stable_type: AsciiString,
    recipient: address,
    timestamp: u64,
}

// === Public Functions ===
fun init(witness: FEE, ctx: &mut TxContext) {
    // Verify that the witness is valid and one-time only.
    assert!(sui::types::is_one_time_witness(&witness), EBadWitness);

    let fee_admin_cap = FeeAdminCap {
        id: object::new(ctx),
    };

    let mut verification_fees = table::new<u8, u64>(ctx);
    // Start with just level 1 by default
    table::add(&mut verification_fees, 1, DEFAULT_VERIFICATION_FEE);

    let fee_manager = FeeManager {
        id: object::new(ctx),
        admin_cap_id: object::id(&fee_admin_cap),
        dao_creation_fee: DEFAULT_DAO_CREATION_FEE,
        proposal_creation_fee_per_outcome: DEFAULT_PROPOSAL_CREATION_FEE_PER_OUTCOME,
        verification_fees,
        sui_balance: balance::zero<SUI>(),
        launchpad_creation_fee: DEFAULT_LAUNCHPAD_CREATION_FEE,
    };

    public_share_object(fee_manager);
    public_transfer(fee_admin_cap, ctx.sender());

    // Consuming the witness ensures one-time initialization.
    let _ = witness;
}

// === Package Functions ===
// Generic internal fee collection function
fun deposit_payment(fee_manager: &mut FeeManager, fee_amount: u64, payment: Coin<SUI>): u64 {
    // Verify payment
    let payment_amount = payment.value();
    assert!(payment_amount == fee_amount, EInvalidPayment);

    // Process payment
    let paid_balance = payment.into_balance();
    fee_manager.sui_balance.join(paid_balance);
    return payment_amount
    // Event emission will be handled by specific wrappers
}

// Function to collect DAO creation fee
public fun deposit_dao_creation_payment(
    fee_manager: &mut FeeManager,
    payment: Coin<SUI>,
    clock: &Clock,
    ctx: &TxContext,
) {
    let fee_amount = fee_manager.dao_creation_fee;

    let payment_amount = deposit_payment(fee_manager, fee_amount, payment);

    // Emit event
    event::emit(DAOCreationFeeCollected {
        amount: payment_amount,
        payer: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// Function to collect launchpad creation fee
public fun deposit_launchpad_creation_payment(
    fee_manager: &mut FeeManager,
    payment: Coin<SUI>,
    clock: &Clock,
    ctx: &TxContext,
) {
    let fee_amount = fee_manager.launchpad_creation_fee;

    let payment_amount = deposit_payment(fee_manager, fee_amount, payment);

    // Emit event
    event::emit(LaunchpadCreationFeeCollected {
        amount: payment_amount,
        payer: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// Function to collect proposal creation fee
public fun deposit_proposal_creation_payment(
    fee_manager: &mut FeeManager,
    payment: Coin<SUI>,
    outcome_count: u64,
    clock: &Clock,
    ctx: &TxContext,
) {
    // Use u128 arithmetic to prevent overflow
    let fee_amount_u128 =
        (fee_manager.proposal_creation_fee_per_outcome as u128) * (outcome_count as u128);

    // Check that result fits in u64
    assert!(fee_amount_u128 <= (u64::max_value!() as u128), EArithmeticOverflow); // u64::max_value()
    let fee_amount = (fee_amount_u128 as u64);

    // deposit_payment asserts the payment amount is exactly the fee_amount
    let payment_amount = deposit_payment(fee_manager, fee_amount, payment);

    // Emit event
    event::emit(ProposalCreationFeeCollected {
        amount: payment_amount,
        payer: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// Function to collect verification fee for a specific level
public fun deposit_verification_payment(
    fee_manager: &mut FeeManager,
    payment: Coin<SUI>,
    verification_level: u8,
    clock: &Clock,
    ctx: &TxContext,
) {
    assert!(table::contains(&fee_manager.verification_fees, verification_level), EInvalidPayment);
    let fee_amount = *table::borrow(&fee_manager.verification_fees, verification_level);
    let payment_amount = deposit_payment(fee_manager, fee_amount, payment);

    // Emit event
    event::emit(VerificationFeeCollected {
        level: verification_level,
        amount: payment_amount,
        payer: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// === Admin Functions ===
// Admin function to withdraw fees
public entry fun withdraw_all_fees(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Verify the admin cap belongs to this fee manager
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    let amount = fee_manager.sui_balance.value();
    let sender = ctx.sender();

    let withdrawal = fee_manager.sui_balance.split(amount).into_coin(ctx);

    event::emit(FeesWithdrawn {
        amount,
        recipient: sender,
        timestamp: clock.timestamp_ms(),
    });

    public_transfer(withdrawal, sender);
}

// Admin function to update DAO creation fee
public entry fun update_dao_creation_fee(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    new_fee: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    let old_fee = fee_manager.dao_creation_fee;
    fee_manager.dao_creation_fee = new_fee;

    event::emit(DAOCreationFeeUpdated {
        old_fee,
        new_fee,
        admin: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// Admin function to update proposal creation fee
public entry fun update_proposal_creation_fee(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    new_fee_per_outcome: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    let old_fee = fee_manager.proposal_creation_fee_per_outcome;
    fee_manager.proposal_creation_fee_per_outcome = new_fee_per_outcome;

    event::emit(ProposalCreationFeeUpdated {
        old_fee,
        new_fee_per_outcome,
        admin: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// Admin function to update launchpad creation fee
public entry fun update_launchpad_creation_fee(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    new_fee: u64,
    _clock: &Clock,
    _ctx: &mut TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    fee_manager.launchpad_creation_fee = new_fee;
}

// Admin function to add a new verification level
public entry fun add_verification_level(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    level: u8,
    fee: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    assert!(!table::contains(&fee_manager.verification_fees, level), EInvalidPayment);

    table::add(&mut fee_manager.verification_fees, level, fee);

    event::emit(VerificationLevelAdded {
        level,
        fee,
        admin: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// Admin function to remove a verification level
public entry fun remove_verification_level(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    level: u8,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    assert!(table::contains(&fee_manager.verification_fees, level), EInvalidPayment);

    table::remove(&mut fee_manager.verification_fees, level);

    event::emit(VerificationLevelRemoved {
        level,
        admin: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// Admin function to update verification fee for a specific level
public entry fun update_verification_fee(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    level: u8,
    new_fee: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    assert!(table::contains(&fee_manager.verification_fees, level), EInvalidPayment);

    let old_fee = *table::borrow(&fee_manager.verification_fees, level);
    *table::borrow_mut(&mut fee_manager.verification_fees, level) = new_fee;

    event::emit(VerificationFeeUpdated {
        level,
        old_fee,
        new_fee,
        admin: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// === AMM Fees ===

// Structure to store stable coin balance information
public struct StableCoinBalance<phantom T> has store {
    balance: Balance<T>,
}

public struct StableFeeRegistry<phantom T> has copy, drop, store {}

// Modified stable fees storage with more structure
public fun deposit_stable_fees<StableType>(
    fee_manager: &mut FeeManager,
    fees: Balance<StableType>,
    proposal_id: ID,
    clock: &Clock,
) {
    let amount = fees.value();

    if (
        dynamic_field::exists_with_type<
            StableFeeRegistry<StableType>,
            StableCoinBalance<StableType>,
        >(&fee_manager.id, StableFeeRegistry<StableType> {})
    ) {
        let fee_balance_wrapper = dynamic_field::borrow_mut<
            StableFeeRegistry<StableType>,
            StableCoinBalance<StableType>,
        >(&mut fee_manager.id, StableFeeRegistry<StableType> {});
        fee_balance_wrapper.balance.join(fees);
    } else {
        let balance_wrapper = StableCoinBalance<StableType> {
            balance: fees,
        };
        dynamic_field::add(&mut fee_manager.id, StableFeeRegistry<StableType> {}, balance_wrapper);
    };

    let type_name = type_name::with_defining_ids<StableType>();
    let type_str = type_name.into_string();
    // Emit collection event
    event::emit(StableFeesCollected {
        amount,
        stable_type: type_str,
        proposal_id,
        timestamp: clock.timestamp_ms(),
    });
}

// Registry type for asset fee balances (similar to StableFeeRegistry)
public struct AssetFeeRegistry<phantom T> has copy, drop, store {}

/// Deposit asset token fees from AMM swaps
public fun deposit_asset_fees<AssetType>(
    fee_manager: &mut FeeManager,
    fees: Balance<AssetType>,
    proposal_id: ID,
    clock: &Clock,
) {
    let amount = fees.value();

    if (
        dynamic_field::exists_with_type<
            AssetFeeRegistry<AssetType>,
            StableCoinBalance<AssetType>,
        >(&fee_manager.id, AssetFeeRegistry<AssetType> {})
    ) {
        let fee_balance_wrapper = dynamic_field::borrow_mut<
            AssetFeeRegistry<AssetType>,
            StableCoinBalance<AssetType>,
        >(&mut fee_manager.id, AssetFeeRegistry<AssetType> {});
        fee_balance_wrapper.balance.join(fees);
    } else {
        let balance_wrapper = StableCoinBalance<AssetType> {
            balance: fees,
        };
        dynamic_field::add(&mut fee_manager.id, AssetFeeRegistry<AssetType> {}, balance_wrapper);
    };

    let type_name = type_name::with_defining_ids<AssetType>();
    let type_str = type_name.into_string();
    // Emit collection event (reuse StableFeesCollected event for asset fees too)
    event::emit(StableFeesCollected {
        amount,
        stable_type: type_str,  // Using same field name for simplicity
        proposal_id,
        timestamp: clock.timestamp_ms(),
    });
}

public entry fun withdraw_stable_fees<StableType>(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Verify the admin cap belongs to this fee manager
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);

    // Check if the stable type exists in the registry
    if (
        !dynamic_field::exists_with_type<
            StableFeeRegistry<StableType>,
            StableCoinBalance<StableType>,
        >(
            &fee_manager.id,
            StableFeeRegistry<StableType> {},
        )
    ) {
        // No fees of this type have been collected, nothing to withdraw
        return
    };

    let fee_balance_wrapper = dynamic_field::borrow_mut<
        StableFeeRegistry<StableType>,
        StableCoinBalance<StableType>,
    >(&mut fee_manager.id, StableFeeRegistry<StableType> {});
    let amount = fee_balance_wrapper.balance.value();

    if (amount > 0) {
        let withdrawn = fee_balance_wrapper.balance.split(amount);
        let coin = withdrawn.into_coin(ctx);

        let type_name = type_name::with_defining_ids<StableType>();
        let type_str = type_name.into_string();
        // Emit withdrawal event
        event::emit(StableFeesWithdrawn {
            amount,
            stable_type: type_str,
            recipient: ctx.sender(),
            timestamp: clock.timestamp_ms(),
        });

        // Transfer to sender
        public_transfer(coin, ctx.sender());
    }
}

/// Withdraw asset fees collected from AMM swaps
public entry fun withdraw_asset_fees<AssetType>(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Verify the admin cap belongs to this fee manager
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);

    // Check if the asset type exists in the registry
    if (
        !dynamic_field::exists_with_type<
            AssetFeeRegistry<AssetType>,
            StableCoinBalance<AssetType>,
        >(
            &fee_manager.id,
            AssetFeeRegistry<AssetType> {},
        )
    ) {
        // No fees of this type have been collected, nothing to withdraw
        return
    };

    let fee_balance_wrapper = dynamic_field::borrow_mut<
        AssetFeeRegistry<AssetType>,
        StableCoinBalance<AssetType>,
    >(&mut fee_manager.id, AssetFeeRegistry<AssetType> {});
    let amount = fee_balance_wrapper.balance.value();

    if (amount > 0) {
        let withdrawn = fee_balance_wrapper.balance.split(amount);
        let coin = withdrawn.into_coin(ctx);

        let type_name = type_name::with_defining_ids<AssetType>();
        let type_str = type_name.into_string();
        // Emit withdrawal event
        event::emit(StableFeesWithdrawn {
            amount,
            stable_type: type_str,  // Using same field name for simplicity
            recipient: ctx.sender(),
            timestamp: clock.timestamp_ms(),
        });

        // Transfer to sender
        public_transfer(coin, ctx.sender());
    }
}

// === View Functions ===
public fun get_dao_creation_fee(fee_manager: &FeeManager): u64 {
    fee_manager.dao_creation_fee
}

public fun get_proposal_creation_fee_per_outcome(fee_manager: &FeeManager): u64 {
    fee_manager.proposal_creation_fee_per_outcome
}

public fun get_launchpad_creation_fee(fee_manager: &FeeManager): u64 {
    fee_manager.launchpad_creation_fee
}

public fun get_verification_fee_for_level(fee_manager: &FeeManager, level: u8): u64 {
    assert!(table::contains(&fee_manager.verification_fees, level), EInvalidPayment);
    *table::borrow(&fee_manager.verification_fees, level)
}

public fun has_verification_level(fee_manager: &FeeManager, level: u8): bool {
    table::contains(&fee_manager.verification_fees, level)
}

public fun get_sui_balance(fee_manager: &FeeManager): u64 {
    fee_manager.sui_balance.value()
}

public fun get_stable_fee_balance<StableType>(fee_manager: &FeeManager): u64 {
    if (
        dynamic_field::exists_with_type<
            StableFeeRegistry<StableType>,
            StableCoinBalance<StableType>,
        >(&fee_manager.id, StableFeeRegistry<StableType> {})
    ) {
        let balance_wrapper = dynamic_field::borrow<
            StableFeeRegistry<StableType>,
            StableCoinBalance<StableType>,
        >(&fee_manager.id, StableFeeRegistry<StableType> {});
        balance_wrapper.balance.value()
    } else {
        0
    }
}

// === Coin-specific Fee Management ===

/// Add a new coin type with its fee configuration
public fun add_coin_fee_config(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    coin_type: TypeName,
    decimals: u8,
    dao_creation_fee: u64,
    proposal_fee_per_outcome: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);

    // Create verification fees table
    let mut verification_fees = table::new<u8, u64>(ctx);
    // Add default verification levels
    table::add(&mut verification_fees, 1, DEFAULT_VERIFICATION_FEE);

    let config = CoinFeeConfig {
        coin_type,
        decimals,
        dao_creation_fee,
        proposal_creation_fee_per_outcome: proposal_fee_per_outcome,
        verification_fees,
        pending_creation_fee: option::none(),
        pending_proposal_fee: option::none(),
        pending_fees_effective_timestamp: option::none(),
        // Initialize baselines to current fees
        creation_fee_baseline: dao_creation_fee,
        proposal_fee_baseline: proposal_fee_per_outcome,
        baseline_reset_timestamp: clock.timestamp_ms(),
    };

    // Store using coin type as key
    dynamic_field::add(&mut fee_manager.id, coin_type, config);
}

/// Entry wrapper for add_coin_fee_config that takes coin type as generic parameter
public entry fun add_coin_fee_config_entry<CoinType>(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    decimals: u8,
    dao_creation_fee: u64,
    proposal_fee_per_outcome: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let coin_type = type_name::get<CoinType>();
    add_coin_fee_config(
        fee_manager,
        admin_cap,
        coin_type,
        decimals,
        dao_creation_fee,
        proposal_fee_per_outcome,
        clock,
        ctx,
    );
}

/// Update creation fee for a specific coin type (with 6-month delay and 10x cap)
public fun update_coin_creation_fee(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    coin_type: TypeName,
    new_fee: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    assert!(dynamic_field::exists_(&fee_manager.id, coin_type), EStableTypeNotFound);

    let config: &mut CoinFeeConfig = dynamic_field::borrow_mut(&mut fee_manager.id, coin_type);
    let current_time = clock.timestamp_ms();

    // Check if 6 months have passed since baseline was set - if so, reset baseline
    if (current_time >= config.baseline_reset_timestamp + FEE_BASELINE_RESET_PERIOD_MS) {
        config.creation_fee_baseline = config.dao_creation_fee;
        config.baseline_reset_timestamp = current_time;
    };

    // Enforce 10x cap from baseline
    assert!(new_fee <= config.creation_fee_baseline * MAX_FEE_MULTIPLIER, EFeeExceedsTenXCap);

    // Allow immediate decrease, delayed increase
    if (new_fee <= config.dao_creation_fee) {
        // Fee decrease - apply immediately
        config.dao_creation_fee = new_fee;
    } else {
        // Fee increase - apply after delay
        let effective_timestamp = current_time + FEE_UPDATE_DELAY_MS;
        config.pending_creation_fee = option::some(new_fee);
        config.pending_fees_effective_timestamp = option::some(effective_timestamp);
    };
}

/// Update proposal fee for a specific coin type (with 6-month delay and 10x cap)
public fun update_coin_proposal_fee(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    coin_type: TypeName,
    new_fee_per_outcome: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    assert!(dynamic_field::exists_(&fee_manager.id, coin_type), EStableTypeNotFound);

    let config: &mut CoinFeeConfig = dynamic_field::borrow_mut(&mut fee_manager.id, coin_type);
    let current_time = clock.timestamp_ms();

    // Check if 6 months have passed since baseline was set - if so, reset baseline
    if (current_time >= config.baseline_reset_timestamp + FEE_BASELINE_RESET_PERIOD_MS) {
        config.proposal_fee_baseline = config.proposal_creation_fee_per_outcome;
        config.baseline_reset_timestamp = current_time;
    };

    // Enforce 10x cap from baseline
    assert!(
        new_fee_per_outcome <= config.proposal_fee_baseline * MAX_FEE_MULTIPLIER,
        EFeeExceedsTenXCap,
    );

    // Allow immediate decrease, delayed increase
    if (new_fee_per_outcome <= config.proposal_creation_fee_per_outcome) {
        // Fee decrease - apply immediately
        config.proposal_creation_fee_per_outcome = new_fee_per_outcome;
    } else {
        // Fee increase - apply after delay
        let effective_timestamp = current_time + FEE_UPDATE_DELAY_MS;
        config.pending_proposal_fee = option::some(new_fee_per_outcome);
        config.pending_fees_effective_timestamp = option::some(effective_timestamp);
    };
}

/// Apply pending fee updates if the delay has passed
public fun apply_pending_coin_fees(
    fee_manager: &mut FeeManager,
    coin_type: TypeName,
    clock: &Clock,
) {
    if (!dynamic_field::exists_(&fee_manager.id, coin_type)) {
        return
    };

    let config: &mut CoinFeeConfig = dynamic_field::borrow_mut(&mut fee_manager.id, coin_type);

    if (config.pending_fees_effective_timestamp.is_some()) {
        let effective_time = *config.pending_fees_effective_timestamp.borrow();

        if (clock.timestamp_ms() >= effective_time) {
            // Apply all pending fees
            if (config.pending_creation_fee.is_some()) {
                config.dao_creation_fee = *config.pending_creation_fee.borrow();
                config.pending_creation_fee = option::none();
            };

            if (config.pending_proposal_fee.is_some()) {
                config.proposal_creation_fee_per_outcome = *config.pending_proposal_fee.borrow();
                config.pending_proposal_fee = option::none();
            };

            config.pending_fees_effective_timestamp = option::none();
        }
    }
}

/// Get fee config for a specific coin type
public fun get_coin_fee_config(fee_manager: &FeeManager, coin_type: TypeName): &CoinFeeConfig {
    assert!(dynamic_field::exists_(&fee_manager.id, coin_type), EStableTypeNotFound);
    dynamic_field::borrow(&fee_manager.id, coin_type)
}

// ======== Test Functions ========
#[test_only]
public fun create_fee_manager_for_testing(ctx: &mut TxContext) {
    let admin_cap = FeeAdminCap {
        id: object::new(ctx),
    };

    let mut verification_fees = table::new<u8, u64>(ctx);
    // Start with just level 1 by default
    table::add(&mut verification_fees, 1, DEFAULT_VERIFICATION_FEE);

    let fee_manager = FeeManager {
        id: object::new(ctx),
        admin_cap_id: object::id(&admin_cap),
        dao_creation_fee: DEFAULT_DAO_CREATION_FEE,
        proposal_creation_fee_per_outcome: DEFAULT_PROPOSAL_CREATION_FEE_PER_OUTCOME,
        verification_fees,
        sui_balance: balance::zero<SUI>(),
        launchpad_creation_fee: DEFAULT_LAUNCHPAD_CREATION_FEE,
    };

    public_share_object(fee_manager);
    public_transfer(admin_cap, ctx.sender());
}

#[test_only]
public fun create_fake_admin_cap_for_testing(ctx: &mut TxContext): FeeAdminCap {
    FeeAdminCap {
        id: object::new(ctx),
    }
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Simplified Quantum LP Management
///
/// Single LP token level with DAO-configured liquidity splitting:
/// - Withdrawals allowed if they don't violate minimum liquidity in conditional AMMs
/// - If withdrawal blocked, LP auto-locked until proposal ends
/// - Quantum split ratio controlled by DAO config (10-90%), with safety cap from conditional capacity
/// - No manual split/redeem - all automatic
module futarchy_markets_core::quantum_lp_manager;

use futarchy_markets_core::unified_spot_pool::{Self, UnifiedSpotPool, LPToken};
use futarchy_markets_primitives::coin_escrow::{Self, TokenEscrow};
use futarchy_markets_primitives::conditional_amm::{Self, LiquidityPool};
use futarchy_markets_primitives::market_state::{Self, MarketState};
use futarchy_one_shot_utils::math;
use std::option;
use sui::clock::Clock;
use sui::coin::{Self as coin, Coin};
use sui::object::{Self, ID};
use sui::transfer;

// === Errors ===
const ELPLocked: u64 = 0;
const EInsufficientLiquidity: u64 = 1;
const EZeroAmount: u64 = 2;
const ENotInWithdrawMode: u64 = 3;
const ENotLockedInProposal: u64 = 4;
const EWrongProposal: u64 = 5;
const EProposalNotFinalized: u64 = 6;
const ENoActiveProposal: u64 = 7;

// === Constants ===
const MINIMUM_LIQUIDITY_BUFFER: u64 = 1000; // Minimum liquidity to maintain in each AMM
/// Bootstrap reserve amount per token type (1000 per pool for AssetType and StableType)
/// These are minimal reserves that stay locked in conditional pools permanently
/// Only quantum-split liquidity (above this amount) is backed by escrow and can be recombined
const BOOTSTRAP_RESERVE_PER_TOKEN: u64 = 1000;

// === Withdrawal Check ===

/// Check if LP withdrawal would violate minimum liquidity in ANY conditional AMM
/// Returns (can_withdraw, min_violating_amm_index)
public fun would_violate_minimum_liquidity<AssetType, StableType>(
    lp_token: &LPToken<AssetType, StableType>,
    spot_pool: &UnifiedSpotPool<AssetType, StableType>,
    market_state: &MarketState,
): (bool, Option<u8>) {
    let lp_amount = unified_spot_pool::lp_token_amount(lp_token);
    let total_lp_supply = unified_spot_pool::lp_supply(spot_pool);

    if (lp_amount == 0 || total_lp_supply == 0) {
        return (true, option::none())
    };

    // Check each conditional AMM
    let pools = market_state::borrow_amm_pools(market_state);
    let mut i = 0;
    while (i < pools.length()) {
        let pool = &pools[i];
        let (asset_reserve, stable_reserve) = conditional_amm::get_reserves(pool);
        let cond_lp_supply = conditional_amm::get_lp_supply(pool);

        if (cond_lp_supply > 0) {
            // Calculate proportional withdrawal from this conditional AMM
            let asset_out = math::mul_div_to_64(lp_amount, asset_reserve, cond_lp_supply);
            let stable_out = math::mul_div_to_64(lp_amount, stable_reserve, cond_lp_supply);

            // Check if remaining would be below minimum
            let remaining_asset = asset_reserve - asset_out;
            let remaining_stable = stable_reserve - stable_out;

            if (
                remaining_asset < MINIMUM_LIQUIDITY_BUFFER ||
                remaining_stable < MINIMUM_LIQUIDITY_BUFFER
            ) {
                return (false, option::some((i as u8)))
            };
        };

        i = i + 1;
    };

    (true, option::none())
}

/// Attempt to withdraw LP with minimum liquidity check
/// If withdrawal would violate minimum, LP is locked in proposal and set to withdraw mode
/// Returns: (can_withdraw_now, proposal_id_if_locked)
public fun check_and_lock_if_needed<AssetType, StableType>(
    lp_token: &mut LPToken<AssetType, StableType>,
    spot_pool: &UnifiedSpotPool<AssetType, StableType>,
    market_state: &MarketState,
    proposal_id: ID,
): (bool, Option<ID>) {
    // Check if already locked
    if (unified_spot_pool::is_locked_in_proposal(lp_token)) {
        let locked_proposal = unified_spot_pool::get_locked_proposal(lp_token);
        return (false, locked_proposal)
    };

    // Check if withdrawal would violate minimum liquidity
    let (can_withdraw, _violating_amm) = would_violate_minimum_liquidity(
        lp_token,
        spot_pool,
        market_state,
    );

    if (can_withdraw) {
        // Withdrawal allowed
        (true, option::none())
    } else {
        // Lock in proposal and set withdraw mode
        unified_spot_pool::lock_in_proposal(lp_token, proposal_id);
        unified_spot_pool::set_withdraw_mode(lp_token, true);
        (false, option::some(proposal_id))
    }
}

// === Auto-Participation Logic ===

/// When proposal starts, automatically quantum-split spot LP to conditional AMMs
/// Amount split is based on DAO-configured ratio with safety cap from conditional capacity
///
/// Quantum-splits BOTH LIVE and TRANSITIONING buckets to conditionals.
/// - LIVE bucket: Will recombine back to spot.LIVE when proposal ends
/// - TRANSITIONING bucket: Will recombine to spot.WITHDRAW_ONLY (frozen for claiming)
/// - WITHDRAW_ONLY bucket: Stays in spot, not quantum-split
///
/// @param conditional_liquidity_ratio_percent: Percentage of LIVE liquidity to move (base 100: 1-99)
public fun auto_quantum_split_on_proposal_start<AssetType, StableType>(
    spot_pool: &mut UnifiedSpotPool<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    conditional_liquidity_ratio_percent: u64, // DAO-configured ratio (base 100: 1-99)
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Get market_state from escrow (fixes borrow conflict)
    let market_state = coin_escrow::get_market_state_mut(escrow);

    // Get BOTH LIVE and TRANSITIONING bucket reserves
    // WITHDRAW_ONLY bucket stays in spot (frozen, ready for claiming)

    let (spot_asset_live, spot_stable_live) = unified_spot_pool::get_active_quantum_lp_reserves(spot_pool);
    let spot_lp_live = unified_spot_pool::get_active_quantum_lp_supply(spot_pool);

    // Get TRANSITIONING bucket reserves
    let (
        spot_asset_trans,
        spot_stable_trans,
        spot_lp_trans,
    ) = unified_spot_pool::get_leaving_on_proposal_end_reserves(spot_pool);

    // Total LP supply across both buckets
    let total_lp = spot_lp_live + spot_lp_trans;

    if (total_lp == 0) {
        return // No liquidity to split
    };

    // Calculate amounts to split for LIVE bucket
    // Apply ratio only to LIVE bucket (TRANSITIONING always gets 100% quantum-split)
    let live_split_ratio = conditional_liquidity_ratio_percent;
    let asset_live_split = math::mul_div_to_64(spot_asset_live, live_split_ratio, 100);
    let stable_live_split = math::mul_div_to_64(spot_stable_live, live_split_ratio, 100);
    let lp_live_split = math::mul_div_to_64(spot_lp_live, live_split_ratio, 100);

    // TRANSITIONING bucket: quantum-split 100% (users marked for withdrawal, still trading)
    let asset_trans_split = spot_asset_trans;
    let stable_trans_split = spot_stable_trans;
    let lp_trans_split = spot_lp_trans;

    // Total amounts to quantum-split
    let total_asset_split = asset_live_split + asset_trans_split;
    let total_stable_split = stable_live_split + stable_trans_split;

    if (total_asset_split == 0 || total_stable_split == 0) {
        return // No liquidity to split
    };

    // Remove liquidity from spot pool (without burning LP tokens)
    let (
        asset_balance,
        stable_balance,
    ) = unified_spot_pool::remove_liquidity_for_quantum_split_with_buckets(
        spot_pool,
        asset_live_split,
        asset_trans_split,
        stable_live_split,
        stable_trans_split,
    );

    // Deposit to escrow as quantum backing
    coin_escrow::deposit_spot_liquidity(
        escrow,
        asset_balance,
        stable_balance,
    );

    // Get market_state again for pool mutations
    let market_state = coin_escrow::get_market_state_mut(escrow);

    // Add to ALL conditional AMMs (quantum split - same amount to each)
    // IMPORTANT: This only happens at proposal START when all pools have identical ratios
    // New LP added DURING proposals stays in spot and participates in the NEXT proposal
    let pools = market_state::borrow_amm_pools_mut(market_state);
    let mut i = 0;
    while (i < pools.length()) {
        let pool = &mut pools[i];

        // Add liquidity to conditional AMM - populates reserves and LP supply
        let _lp_amount = conditional_amm::add_liquidity_proportional(
            pool,
            total_asset_split,
            total_stable_split,
            0, // min_lp_out
            clock,
            ctx,
        );

        i = i + 1;
    };

    // Update price leaderboard after liquidity changes (if initialized)
    // Prices change when liquidity is added, so we need to update the cache
    // TODO: Re-enable when price_leaderboard functions are implemented
    // if (market_state::has_price_leaderboard(market_state)) {
    //     let mut i = 0;
    //     let n = market_state::outcome_count(market_state);
    //     while (i < n) {
    //         let pool = market_state::get_pool_mut_by_outcome(market_state, (i as u8));
    //         let new_price = conditional_amm::get_current_price(pool);
    //         market_state::update_price_in_leaderboard(market_state, i, new_price);
    //         i = i + 1;
    //     };
    // };
}

/// When proposal ends, automatically recombine winning conditional LP back to spot
/// Uses bucket-aware recombination:
/// - conditional.LIVE ‚Üí spot.LIVE (will quantum-split for next proposal)
/// - conditional.TRANSITIONING ‚Üí spot.WITHDRAW_ONLY (frozen for claiming)
///
/// NOTE: Does NOT mint LP tokens. User LP tokens existed throughout quantum split,
/// they're now just backed by spot liquidity again after recombination.
///
/// CRITICAL FIX: Derives bucket amounts from current reserves and original LP token ratios
/// instead of using stale bucket counters (which aren't updated during swaps).
public fun auto_redeem_on_proposal_end<AssetType, StableType>(
    winning_outcome: u64,
    spot_pool: &mut UnifiedSpotPool<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    market_state: &mut MarketState,
    _clock: &Clock,
    ctx: &mut TxContext,
) {
    // Determine LIVE vs TRANSITIONING allocation using LP share ratios
    // Swaps change reserves but leave LP supply constant, so proportions stay accurate
    let pool = market_state::get_pool_by_outcome(market_state, (winning_outcome as u8));
    let (total_asset, total_stable) = conditional_amm::get_reserves(pool);
    let (
        _asset_live_bucket,
        _asset_transition_bucket,
        _stable_live_bucket,
        _stable_transition_bucket,
        lp_live_bucket,
        lp_transition_bucket,
    ) = conditional_amm::get_bucket_amounts(pool);

    let total_lp_bucket = lp_live_bucket + lp_transition_bucket;
    let (asset_live, asset_transitioning, stable_live, stable_transitioning) = if (
        total_lp_bucket == 0
    ) {
        (total_asset, 0, total_stable, 0)
    } else {
        let asset_live_calc = math::mul_div_to_64(total_asset, lp_live_bucket, total_lp_bucket);
        let stable_live_calc = math::mul_div_to_64(total_stable, lp_live_bucket, total_lp_bucket);
        (
            asset_live_calc,
            total_asset - asset_live_calc,
            stable_live_calc,
            total_stable - stable_live_calc,
        )
    };

    // Now remove liquidity from winning conditional AMM
    let pool_mut = market_state::get_pool_mut_by_outcome(market_state, (winning_outcome as u8));
    let (cond_asset_amt, cond_stable_amt) = conditional_amm::empty_all_amm_liquidity(pool_mut, ctx);

    // Withdraw matching spot balances from escrow (1:1 due to quantum liquidity invariant)
    let asset_coin = coin_escrow::withdraw_asset_balance(escrow, cond_asset_amt, ctx);
    let stable_coin = coin_escrow::withdraw_stable_balance(escrow, cond_stable_amt, ctx);

    // Add back to spot pool with DERIVED bucket amounts
    // LIVE ‚Üí spot.LIVE, TRANSITIONING ‚Üí spot.WITHDRAW_ONLY
    unified_spot_pool::add_liquidity_from_quantum_redeem_with_buckets(
        spot_pool,
        coin::into_balance(asset_coin),
        coin::into_balance(stable_coin),
        asset_live, // ‚Üê DERIVED from ratios, not stale counters!
        asset_transitioning,
        stable_live,
        stable_transitioning,
    );

    // Merge PENDING bucket into LIVE now that proposal has ended
    // New LP added during the proposal can now participate in future proposals
    unified_spot_pool::merge_joining_to_active_quantum_lp(spot_pool);

    // Done! User LP tokens are now backed by spot liquidity again.
    // No need to mint new LP tokens - they existed throughout the quantum split.
}

/// Entry-friendly wrapper that extracts market_state from escrow and handles borrows properly
/// This avoids borrow checker issues since it manages escrow/market_state borrow scopes internally
public fun auto_redeem_on_proposal_end_from_escrow<AssetType, StableType>(
    winning_outcome: u64,
    spot_pool: &mut UnifiedSpotPool<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    _clock: &Clock,
    ctx: &mut TxContext,
) {
    // Step 1: Calculate bucket allocations and empty conditional AMM (needs market_state)
    let (cond_asset_amt, cond_stable_amt, asset_live, asset_transitioning, stable_live, stable_transitioning) = {
        let market_state = coin_escrow::get_market_state_mut(escrow);

        // Get reserves and bucket data from winning conditional pool
        let pool = market_state::get_pool_by_outcome(market_state, (winning_outcome as u8));
        let (total_asset, total_stable) = conditional_amm::get_reserves(pool);
        let (
            _asset_live_bucket,
            _asset_transition_bucket,
            _stable_live_bucket,
            _stable_transition_bucket,
            lp_live_bucket,
            lp_transition_bucket,
        ) = conditional_amm::get_bucket_amounts(pool);

        // Calculate bucket allocations
        let total_lp_bucket = lp_live_bucket + lp_transition_bucket;
        let (asset_live, asset_transitioning, stable_live, stable_transitioning) = if (total_lp_bucket == 0) {
            (total_asset, 0, total_stable, 0)
        } else {
            let asset_live_calc = math::mul_div_to_64(total_asset, lp_live_bucket, total_lp_bucket);
            let stable_live_calc = math::mul_div_to_64(total_stable, lp_live_bucket, total_lp_bucket);
            (
                asset_live_calc,
                total_asset - asset_live_calc,
                stable_live_calc,
                total_stable - stable_live_calc,
            )
        };

        // Empty winning conditional AMM (needs mutable pool access)
        let pool_mut = market_state::get_pool_mut_by_outcome(market_state, (winning_outcome as u8));
        let (cond_asset_amt, cond_stable_amt) = conditional_amm::empty_all_amm_liquidity(pool_mut, ctx);

        (cond_asset_amt, cond_stable_amt, asset_live, asset_transitioning, stable_live, stable_transitioning)
    }; // market_state borrow ends here

    // CRITICAL: Subtract bootstrap reserves before withdrawing from escrow!
    // Bootstrap reserves (1000/1000 per pool) are NOT backed by escrow - they stay locked in pools
    // Only the quantum-split liquidity has escrow backing
    let escrow_backed_asset = if (cond_asset_amt > BOOTSTRAP_RESERVE_PER_TOKEN) {
        cond_asset_amt - BOOTSTRAP_RESERVE_PER_TOKEN
    } else {
        0  // Safety: if somehow less than bootstrap, withdraw nothing
    };
    let escrow_backed_stable = if (cond_stable_amt > BOOTSTRAP_RESERVE_PER_TOKEN) {
        cond_stable_amt - BOOTSTRAP_RESERVE_PER_TOKEN
    } else {
        0
    };

    // Step 2: Withdraw only the escrow-backed amounts (quantum-split liquidity)
    let asset_coin = coin_escrow::withdraw_asset_balance(escrow, escrow_backed_asset, ctx);
    let stable_coin = coin_escrow::withdraw_stable_balance(escrow, escrow_backed_stable, ctx);

    // Step 3: Add liquidity back to spot pool with DERIVED bucket amounts
    // Adjust bucket amounts to exclude bootstrap reserves (they're not being returned)
    let adjusted_asset_live = if (asset_live > BOOTSTRAP_RESERVE_PER_TOKEN) {
        asset_live - BOOTSTRAP_RESERVE_PER_TOKEN
    } else {
        0
    };
    let adjusted_stable_live = if (stable_live > BOOTSTRAP_RESERVE_PER_TOKEN) {
        stable_live - BOOTSTRAP_RESERVE_PER_TOKEN
    } else {
        0
    };

    unified_spot_pool::add_liquidity_from_quantum_redeem_with_buckets(
        spot_pool,
        coin::into_balance(asset_coin),
        coin::into_balance(stable_coin),
        adjusted_asset_live,
        asset_transitioning,  // Transitioning buckets don't include bootstrap
        adjusted_stable_live,
        stable_transitioning,
    );

    // Step 4: Merge PENDING bucket into LIVE
    unified_spot_pool::merge_joining_to_active_quantum_lp(spot_pool);
}

// === Entry Functions ===

/// Withdraw LP with automatic lock check
/// If withdrawal would violate minimum liquidity, LP is locked in proposal with withdraw mode
public entry fun withdraw_with_lock_check<AssetType, StableType>(
    mut lp_token: LPToken<AssetType, StableType>,
    spot_pool: &mut UnifiedSpotPool<AssetType, StableType>,
    market_state: &MarketState,
    proposal_id: ID,
    min_asset_out: u64,
    min_stable_out: u64,
    ctx: &mut TxContext,
) {
    use sui::event;

    // Check if already locked
    assert!(!unified_spot_pool::is_locked_in_proposal(&lp_token), ELPLocked);

    // Check if withdrawal would violate minimum liquidity
    let (can_withdraw, _) = would_violate_minimum_liquidity(
        &lp_token,
        spot_pool,
        market_state,
    );

    if (can_withdraw) {
        // Process withdrawal using existing function
        let (asset_coin, stable_coin) = unified_spot_pool::remove_liquidity(
            spot_pool,
            lp_token,
            min_asset_out,
            min_stable_out,
            ctx,
        );

        // Transfer coins to user
        transfer::public_transfer(asset_coin, ctx.sender());
        transfer::public_transfer(stable_coin, ctx.sender());
    } else {
        // Move LP share into withdraw flow and lock until proposal settles
        unified_spot_pool::mark_lp_for_withdrawal(spot_pool, &mut lp_token);

        let lp_amount = unified_spot_pool::lp_token_amount(&lp_token);
        unified_spot_pool::lock_in_proposal(&mut lp_token, proposal_id);
        unified_spot_pool::set_withdraw_mode(&mut lp_token, true);

        // Emit event for frontend tracking
        event::emit(LPLockedForWithdrawal {
            lp_id: object::id(&lp_token),
            owner: ctx.sender(),
            proposal_id,
            amount: lp_amount,
        });

        // Return locked LP token to user
        transfer::public_transfer(lp_token, ctx.sender());
    }
}

/// Unlock an LP token after the associated proposal has finalized
/// Allows users whose withdrawal was delayed to proceed with claiming
public entry fun unlock_after_proposal_finalized<AssetType, StableType>(
    lp_token: &mut LPToken<AssetType, StableType>,
    market_state: &MarketState,
) {
    assert!(unified_spot_pool::is_locked_in_proposal(lp_token), ENotLockedInProposal);

    let mut locked_proposal_opt = unified_spot_pool::get_locked_proposal(lp_token);
    assert!(locked_proposal_opt.is_some(), ENotLockedInProposal);
    let locked_proposal_id = option::extract(&mut locked_proposal_opt);
    option::destroy_none(locked_proposal_opt);

    assert!(market_state::is_finalized(market_state), EProposalNotFinalized);
    let market_id = market_state::market_id(market_state);
    assert!(market_id == locked_proposal_id, EWrongProposal);

    unified_spot_pool::unlock_from_proposal(lp_token);
}

/// Withdraw LP tokens after they've been marked for withdrawal and moved to WITHDRAW_ONLY bucket
/// This is the simple spot-only version - no conditional token complexity
///
/// Flow:
/// 1. User marks LP for withdrawal ‚Üí moves LIVE ‚Üí TRANSITIONING (if proposal active) or LIVE ‚Üí WITHDRAW_ONLY (if no proposal)
/// 2. If proposal was active: quantum split happens, then recombination moves TRANSITIONING ‚Üí WITHDRAW_ONLY
/// 3. User calls this function ‚Üí withdraws from WITHDRAW_ONLY bucket as coins
///
/// NOTE: LP must be in withdraw mode and NOT locked in a proposal
public entry fun claim_withdrawal<AssetType, StableType>(
    lp_token: LPToken<AssetType, StableType>,
    spot_pool: &mut UnifiedSpotPool<AssetType, StableType>,
    ctx: &mut TxContext,
) {
    use sui::event;

    // Validate LP is in withdraw mode
    assert!(unified_spot_pool::is_withdraw_mode(&lp_token), ENotInWithdrawMode);

    // Validate LP is NOT locked (if locked, must wait for proposal to end and crank to run)
    let locked_proposal_opt = unified_spot_pool::get_locked_proposal(&lp_token);
    assert!(locked_proposal_opt.is_none(), ENoActiveProposal);

    let lp_amount = unified_spot_pool::lp_token_amount(&lp_token);
    let lp_id = object::id(&lp_token);

    // Withdraw from WITHDRAW_ONLY bucket (handles all the bucket accounting)
    let (asset_coin, stable_coin) = unified_spot_pool::withdraw_lp(
        spot_pool,
        lp_token, // This burns the LP token
        ctx,
    );

    let asset_amount = coin::value(&asset_coin);
    let stable_amount = coin::value(&stable_coin);

    // Emit event for tracking
    event::emit(WithdrawalClaimed {
        lp_id,
        owner: ctx.sender(),
        proposal_id: object::id_from_address(@0x0), // No proposal (already finalized and recombined)
        lp_amount,
        asset_amount,
        stable_amount,
    });

    // Transfer coins to user
    transfer::public_transfer(asset_coin, ctx.sender());
    transfer::public_transfer(stable_coin, ctx.sender());
}

// === Events ===

public struct LPLockedForWithdrawal has copy, drop {
    lp_id: ID,
    owner: address,
    proposal_id: ID,
    amount: u64,
}

public struct WithdrawalClaimed has copy, drop {
    lp_id: ID,
    owner: address,
    proposal_id: ID,
    lp_amount: u64,
    asset_amount: u64,
    stable_amount: u64,
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Unified arbitrage module that works for ANY outcome count
///
/// This module eliminates type explosion by using balance-based operations.
/// ONE arbitrage function works for 2, 3, 4, 5, or 200 outcomes.
///
/// Key innovation: Loops over outcomes using balance indices instead of
/// requiring N type parameters.

module futarchy_markets_core::arbitrage;

use futarchy_markets_core::swap_core::{Self, SwapSession};
use futarchy_markets_core::unified_spot_pool::{Self, UnifiedSpotPool};
use futarchy_markets_primitives::coin_escrow::{Self, TokenEscrow};
use futarchy_markets_primitives::conditional_balance::{Self, ConditionalMarketBalance};
use futarchy_markets_primitives::market_state;
use std::option;
use sui::clock::Clock;
use sui::coin::{Self, Coin};
use sui::event;
use sui::object::{Self, ID};

// === Errors ===
const EZeroAmount: u64 = 0;
const EInsufficientProfit: u64 = 1;
const EInvalidDirection: u64 = 2;

// === Events ===

/// Emitted when spot arbitrage completes
public struct SpotArbitrageExecuted has copy, drop {
    proposal_id: ID,
    outcome_count: u64,
    input_asset: u64,
    input_stable: u64,
    output_asset: u64,
    output_stable: u64,
    profit_asset: u64,
    profit_stable: u64,
}

/// Emitted when conditional arbitrage completes
public struct ConditionalArbitrageExecuted has copy, drop {
    proposal_id: ID,
    outcome_idx: u8,
    amount_in: u64,
    amount_out: u64,
}

// === Main Arbitrage Functions ===

/// Execute spot arbitrage with auto-merge - works for ANY outcome count!
///
/// Takes spot coins, performs quantum mint + swaps across all outcomes,
/// finds complete set minimum, burns complete set, returns profit + dust.
///
/// **NEW: Auto-Merge Support!** Pass your existing dust balance and it will
/// accumulate into it. DCA bots doing 100 swaps = 1 NFT instead of 100!
///
/// # Arbitrage Flow
/// 1. Deposit spot coins to escrow (quantum liquidity)
/// 2. Add amounts to balance for ALL outcomes simultaneously
/// 3. Swap asset‚Üístable (or stable‚Üíasset) in EACH outcome market
/// 4. Find minimum balance across outcomes (complete set limit)
/// 5. Burn complete set and withdraw spot coins as profit
/// 6. Merge dust into existing balance OR create new balance
///
/// # Arguments
/// * `stable_for_arb` - Spot stable coins to use (can be zero)
/// * `asset_for_arb` - Spot asset coins to use (can be zero)
/// * `min_profit` - Minimum profit required (0 = no minimum)
/// * `recipient` - Address to receive profits
/// * `existing_balance_opt` - Optional existing balance to merge into (auto-merge!)
///   - None = Create new balance object
///   - Some(balance) = Merge dust into existing balance (DCA optimization!)
///
/// # Returns
/// * Tuple: (stable_profit, asset_profit, dust_balance)
/// * ALWAYS returns a balance (merged or new)
/// * Caller should transfer balance to recipient
///
/// # Example - DCA Bot Pattern
/// ```move
/// // First swap - no existing balance
/// let mut balance = option::none();
///
/// // Loop 100 swaps - accumulate into one NFT!
/// let mut i = 0;
/// while (i < 100) {
///     let (stable_profit, asset_profit, dust) = execute_optimal_spot_arbitrage(
///         spot_pool, escrow, &session,
///         stable_coin, asset_coin, 0, recipient,
///         balance,  // ‚Üê Pass previous balance back!
///         clock, ctx
///     );
///     balance = option::some(dust);  // Accumulate
///     i = i + 1;
/// };
///
/// // After 100 swaps: 1 NFT instead of 100!
/// transfer::public_transfer(option::extract(&mut balance), recipient);
/// ```
public fun execute_optimal_spot_arbitrage<AssetType, StableType>(
    spot_pool: &mut UnifiedSpotPool<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    session: &SwapSession,
    stable_for_arb: Coin<StableType>,
    asset_for_arb: Coin<AssetType>,
    min_profit: u64,
    recipient: address,
    mut existing_balance_opt: option::Option<ConditionalMarketBalance<AssetType, StableType>>,
    clock: &Clock,
    ctx: &mut TxContext,
): (Coin<StableType>, Coin<AssetType>, ConditionalMarketBalance<AssetType, StableType>) {
    // Validate market is live
    let market_state = coin_escrow::get_market_state(escrow);
    market_state::assert_trading_active(market_state);

    let stable_amt = stable_for_arb.value();
    let asset_amt = asset_for_arb.value();

    // Determine arbitrage direction and execute
    if (stable_amt > 0 && asset_amt == 0) {
        // Stable‚ÜíAsset‚ÜíConditionals‚ÜíStable arbitrage
        // Destroy zero asset coin
        coin::destroy_zero(asset_for_arb);
        execute_spot_arb_stable_to_asset_direction(
            spot_pool,
            escrow,
            session,
            stable_for_arb,
            min_profit,
            recipient,
            existing_balance_opt,
            clock,
            ctx,
        )
    } else if (asset_amt > 0 && stable_amt == 0) {
        // Asset‚ÜíStable‚ÜíConditionals‚ÜíAsset arbitrage
        // Destroy zero stable coin
        coin::destroy_zero(stable_for_arb);
        execute_spot_arb_asset_to_stable_direction(
            spot_pool,
            escrow,
            session,
            asset_for_arb,
            min_profit,
            recipient,
            existing_balance_opt,
            clock,
            ctx,
        )
    } else {
        // No coins or both coins provided - just return them and empty/existing balance
        if (stable_amt > 0) {
            transfer::public_transfer(stable_for_arb, recipient);
        } else {
            coin::destroy_zero(stable_for_arb);
        };
        if (asset_amt > 0) {
            transfer::public_transfer(asset_for_arb, recipient);
        } else {
            coin::destroy_zero(asset_for_arb);
        };

        // Return existing balance or create empty one
        let balance = if (option::is_some(&existing_balance_opt)) {
            option::extract(&mut existing_balance_opt)
        } else {
            let market_id = futarchy_markets_primitives::market_state::market_id(market_state);
            let outcome_count = futarchy_markets_primitives::market_state::outcome_count(market_state);
            conditional_balance::new<AssetType, StableType>(market_id, (outcome_count as u8), ctx)
        };
        option::destroy_none(existing_balance_opt);
        (coin::zero<StableType>(ctx), coin::zero<AssetType>(ctx), balance)
    }
}

// === Direction-Specific Arbitrage ===

/// Execute: Stable ‚Üí Spot Asset ‚Üí Conditional Assets ‚Üí Conditional Stables ‚Üí Spot Stable (profit)
fun execute_spot_arb_stable_to_asset_direction<AssetType, StableType>(
    spot_pool: &mut UnifiedSpotPool<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    session: &SwapSession,
    stable_for_arb: Coin<StableType>,
    min_profit: u64,
    recipient: address,
    mut existing_balance_opt: option::Option<ConditionalMarketBalance<AssetType, StableType>>,
    clock: &Clock,
    ctx: &mut TxContext,
): (Coin<StableType>, Coin<AssetType>, ConditionalMarketBalance<AssetType, StableType>) {
    let stable_amt = stable_for_arb.value();
    assert!(stable_amt > 0, EZeroAmount);

    // Get market info from escrow
    let market_state = coin_escrow::get_market_state(escrow);
    let outcome_count = futarchy_markets_primitives::market_state::outcome_count(market_state);
    let market_id = futarchy_markets_primitives::market_state::market_id(market_state);

    // 1. Swap spot stable ‚Üí spot asset
    let asset_from_spot = unified_spot_pool::swap_stable_for_asset(
        spot_pool,
        stable_for_arb,
        0,
        clock,
        ctx,
    );
    let asset_amt = asset_from_spot.value();

    // 2. Create temporary balance object for arbitrage
    let mut arb_balance = conditional_balance::new<AssetType, StableType>(
        market_id,
        (outcome_count as u8),
        ctx,
    );

    // 3. Deposit asset to escrow for quantum mint
    let (deposited_asset, _) = coin_escrow::deposit_spot_coins(
        escrow,
        asset_from_spot,
        coin::zero<StableType>(ctx),
    );

    // 4. Add to balance (quantum: same amount in ALL outcomes)
    let mut i = 0u8;
    while ((i as u64) < outcome_count) {
        conditional_balance::add_to_balance(&mut arb_balance, i, true, deposited_asset);
        i = i + 1;
    };

    // 5. Swap asset ‚Üí stable in EACH conditional market (LOOP!)
    i = 0u8;
    while ((i as u64) < outcome_count) {
        swap_core::swap_balance_asset_to_stable<AssetType, StableType>(
            session,
            escrow,
            &mut arb_balance,
            i,
            asset_amt,
            0,
            clock,
            ctx,
        );
        i = i + 1;
    };

    // 6. Find minimum stable amount (complete set limit)
    let min_stable = conditional_balance::find_min_balance(&arb_balance, false);

    // 7. Burn complete set ‚Üí withdraw spot stable
    let profit_stable = burn_complete_set_and_withdraw_stable(
        &mut arb_balance,
        escrow,
        min_stable,
        ctx,
    );

    // Validate profit meets minimum
    assert!(profit_stable.value() >= min_profit, EInsufficientProfit);

    // Calculate net profit (handle losses where output < input)
    let net_profit_stable = if (profit_stable.value() >= stable_amt) {
        profit_stable.value() - stable_amt
    } else {
        0 // Loss case - report as 0 profit
    };

    // Emit event
    event::emit(SpotArbitrageExecuted {
        proposal_id: market_id,
        outcome_count,
        input_asset: 0,
        input_stable: stable_amt,
        output_asset: 0,
        output_stable: profit_stable.value(),
        profit_asset: 0,
        profit_stable: net_profit_stable,
    });

    // 8. Merge dust into existing balance OR return new balance
    let final_balance = if (option::is_some(&existing_balance_opt)) {
        let mut existing = option::extract(&mut existing_balance_opt);
        conditional_balance::merge(&mut existing, arb_balance); // Merge new dust into existing
        existing
    } else {
        arb_balance // Return new balance
    };
    option::destroy_none(existing_balance_opt);

    (profit_stable, coin::zero<AssetType>(ctx), final_balance)
}

/// Execute: Asset ‚Üí Spot Stable ‚Üí Conditional Stables ‚Üí Conditional Assets ‚Üí Spot Asset (profit)
fun execute_spot_arb_asset_to_stable_direction<AssetType, StableType>(
    spot_pool: &mut UnifiedSpotPool<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    session: &SwapSession,
    asset_for_arb: Coin<AssetType>,
    min_profit: u64,
    recipient: address,
    mut existing_balance_opt: option::Option<ConditionalMarketBalance<AssetType, StableType>>,
    clock: &Clock,
    ctx: &mut TxContext,
): (Coin<StableType>, Coin<AssetType>, ConditionalMarketBalance<AssetType, StableType>) {
    let asset_amt = asset_for_arb.value();
    assert!(asset_amt > 0, EZeroAmount);

    // Get market info from escrow
    let market_state = coin_escrow::get_market_state(escrow);
    let outcome_count = futarchy_markets_primitives::market_state::outcome_count(market_state);
    let market_id = futarchy_markets_primitives::market_state::market_id(market_state);

    // 1. Swap spot asset ‚Üí spot stable
    let stable_from_spot = unified_spot_pool::swap_asset_for_stable(
        spot_pool,
        asset_for_arb,
        0,
        clock,
        ctx,
    );
    let stable_amt = stable_from_spot.value();

    // 2. Create temporary balance object
    let mut arb_balance = conditional_balance::new<AssetType, StableType>(
        market_id,
        (outcome_count as u8),
        ctx,
    );

    // 3. Deposit stable to escrow for quantum mint
    let (_, deposited_stable) = coin_escrow::deposit_spot_coins(
        escrow,
        coin::zero<AssetType>(ctx),
        stable_from_spot,
    );

    // 4. Add to balance (quantum: same amount in ALL outcomes)
    let mut i = 0u8;
    while ((i as u64) < outcome_count) {
        conditional_balance::add_to_balance(&mut arb_balance, i, false, deposited_stable);
        i = i + 1;
    };

    // 5. Swap stable ‚Üí asset in EACH conditional market (LOOP!)
    i = 0u8;
    while ((i as u64) < outcome_count) {
        swap_core::swap_balance_stable_to_asset<AssetType, StableType>(
            session,
            escrow,
            &mut arb_balance,
            i,
            stable_amt,
            0,
            clock,
            ctx,
        );
        i = i + 1;
    };

    // 6. Find minimum asset amount (complete set limit)
    let min_asset = conditional_balance::find_min_balance(&arb_balance, true);

    // 7. Burn complete set ‚Üí withdraw spot asset
    let profit_asset = burn_complete_set_and_withdraw_asset(
        &mut arb_balance,
        escrow,
        min_asset,
        ctx,
    );

    // Validate profit meets minimum
    assert!(profit_asset.value() >= min_profit, EInsufficientProfit);

    // Calculate net profit (handle losses where output < input)
    let net_profit_asset = if (profit_asset.value() >= asset_amt) {
        profit_asset.value() - asset_amt
    } else {
        0 // Loss case - report as 0 profit
    };

    // Emit event
    event::emit(SpotArbitrageExecuted {
        proposal_id: market_id,
        outcome_count,
        input_asset: asset_amt,
        input_stable: 0,
        output_asset: profit_asset.value(),
        output_stable: 0,
        profit_asset: net_profit_asset,
        profit_stable: 0,
    });

    // 8. Merge dust into existing balance OR return new balance
    let final_balance = if (option::is_some(&existing_balance_opt)) {
        let mut existing = option::extract(&mut existing_balance_opt);
        conditional_balance::merge(&mut existing, arb_balance); // Merge new dust into existing
        existing
    } else {
        arb_balance // Return new balance
    };
    option::destroy_none(existing_balance_opt);

    (coin::zero<StableType>(ctx), profit_asset, final_balance)
}

// === Helper Functions ===

/// Burn complete set of conditional stables and withdraw spot stable
///
/// Subtracts amount from ALL outcome stable balances, then withdraws from escrow.
/// This maintains the quantum liquidity invariant.
///
/// PUBLIC for use in swap_entry::finalize_conditional_swaps
public fun burn_complete_set_and_withdraw_stable<AssetType, StableType>(
    balance: &mut ConditionalMarketBalance<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    amount: u64,
    ctx: &mut TxContext,
): Coin<StableType> {
    let outcome_count = conditional_balance::outcome_count(balance);

    // Subtract from all outcome stable balances
    let mut i = 0u8;
    while ((i as u64) < (outcome_count as u64)) {
        conditional_balance::sub_from_balance(balance, i, false, amount);
        i = i + 1;
    };

    // Withdraw from escrow
    let (asset, stable) = coin_escrow::withdraw_from_escrow(escrow, 0, amount, ctx);
    coin::destroy_zero(asset); // Destroy zero asset coin
    stable
}

/// Burn complete set of conditional assets and withdraw spot asset
///
/// Subtracts amount from ALL outcome asset balances, then withdraws from escrow.
///
/// PUBLIC for use in swap_entry::finalize_conditional_swaps
public fun burn_complete_set_and_withdraw_asset<AssetType, StableType>(
    balance: &mut ConditionalMarketBalance<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    amount: u64,
    ctx: &mut TxContext,
): Coin<AssetType> {
    let outcome_count = conditional_balance::outcome_count(balance);

    // Subtract from all outcome asset balances
    let mut i = 0u8;
    while ((i as u64) < (outcome_count as u64)) {
        conditional_balance::sub_from_balance(balance, i, true, amount);
        i = i + 1;
    };

    // Withdraw from escrow
    let (asset, stable) = coin_escrow::withdraw_from_escrow(escrow, amount, 0, ctx);
    coin::destroy_zero(stable); // Destroy zero stable coin
    asset
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// ARBITRAGE CORE - Complex logic extracted from arbitrage_executor.move
///
/// All the hard stuff lives here. Per-N wrappers just call these with explicit types.
///
/// AUDITOR: This is where the real arbitrage algorithms are.

module futarchy_markets_core::arbitrage_core;

use futarchy_markets_core::arbitrage_math;
use futarchy_markets_core::proposal::Proposal;
use futarchy_markets_core::unified_spot_pool::{Self, UnifiedSpotPool};
use futarchy_markets_primitives::coin_escrow::{Self, TokenEscrow};
use futarchy_markets_primitives::market_state;
use sui::balance::{Self, Balance};
use sui::clock::Clock;
use sui::coin::{Self, Coin};

// === Errors ===
const EInsufficientProfit: u64 = 1;

// === Core Algorithms (Copied from arbitrage_executor.move) ===

/// Validate arbitrage is profitable before execution
/// (Copied from arbitrage_executor.move lines 84-98)
public fun validate_profitable<AssetType, StableType>(
    spot_pool: &UnifiedSpotPool<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
    arb_amount: u64,
    min_profit_out: u64,
    is_spot_swap_stable_to_asset: bool,
): u128 {
    let market_state = coin_escrow::get_market_state(escrow);
    let conditional_pools = market_state::borrow_amm_pools(market_state);

    let expected_profit = arbitrage_math::calculate_spot_arbitrage_profit(
        spot_pool,
        conditional_pools,
        arb_amount,
        is_spot_swap_stable_to_asset,
    );

    assert!(expected_profit >= (min_profit_out as u128), EInsufficientProfit);
    expected_profit
}

/// Swap stable ‚Üí asset in spot pool
/// (Copied from arbitrage_executor.move lines 108-114)
public fun spot_swap_stable_to_asset<AssetType, StableType>(
    spot_pool: &mut UnifiedSpotPool<AssetType, StableType>,
    stable_for_arb: Coin<StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<AssetType> {
    unified_spot_pool::swap_stable_for_asset(
        spot_pool,
        stable_for_arb,
        0, // No intermediate minimum (atomic execution)
        clock,
        ctx,
    )
}

/// Swap asset ‚Üí stable in spot pool
/// (Copied from arbitrage_executor.move lines 386-392)
public fun spot_swap_asset_to_stable<AssetType, StableType>(
    spot_pool: &mut UnifiedSpotPool<AssetType, StableType>,
    asset_for_arb: Coin<AssetType>,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<StableType> {
    unified_spot_pool::swap_asset_for_stable(
        spot_pool,
        asset_for_arb,
        0,
        clock,
        ctx,
    )
}

/// Deposit asset ONCE for quantum minting N conditional assets
/// (Copied from arbitrage_executor.move lines 121-122)
public fun deposit_asset_for_quantum_mint<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    asset: Coin<AssetType>,
) {
    let asset_balance = coin::into_balance(asset);
    coin_escrow::deposit_spot_liquidity(escrow, asset_balance, balance::zero<StableType>());
}

/// Deposit stable ONCE for quantum minting N conditional stables
/// (Copied from arbitrage_executor.move lines 398-399)
public fun deposit_stable_for_quantum_mint<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    stable: Coin<StableType>,
) {
    let stable_balance = coin::into_balance(stable);
    coin_escrow::deposit_spot_liquidity(escrow, balance::zero<AssetType>(), stable_balance);
}

/// Find minimum value across coins
/// (Copied from arbitrage_executor.move lines 178-187)
public fun find_min_value<T>(coins: &vector<Coin<T>>): u64 {
    let mut min_amount = std::u64::max_value!();
    let mut i = 0;
    while (i < vector::length(coins)) {
        let amount = vector::borrow(coins, i).value();
        if (amount < min_amount) {
            min_amount = amount;
        };
        i = i + 1;
    };
    min_amount
}

/// Withdraw spot stable after burning complete sets
public fun withdraw_stable<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    amount: u64,
    ctx: &mut TxContext,
): Coin<StableType> {
    coin_escrow::withdraw_stable_balance(escrow, amount, ctx)
}

/// Withdraw spot asset after burning complete sets
public fun withdraw_asset<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    amount: u64,
    ctx: &mut TxContext,
): Coin<AssetType> {
    coin_escrow::withdraw_asset_balance(escrow, amount, ctx)
}

/// Burn conditional asset and withdraw spot asset
/// Used in conditional arbitrage to convert conditional ‚Üí spot
public fun burn_and_withdraw_conditional_asset<AssetType, StableType, CondAsset>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    conditional: Coin<CondAsset>,
    ctx: &mut TxContext,
): Coin<AssetType> {
    let amount = conditional.value();
    coin_escrow::burn_conditional_asset<AssetType, StableType, CondAsset>(
        escrow,
        outcome_idx,
        conditional,
    );
    coin_escrow::withdraw_asset_balance(escrow, amount, ctx)
}

/// Burn conditional stable and withdraw spot stable
/// Used in conditional arbitrage to convert conditional ‚Üí spot
public fun burn_and_withdraw_conditional_stable<AssetType, StableType, CondStable>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    conditional: Coin<CondStable>,
    ctx: &mut TxContext,
): Coin<StableType> {
    let amount = conditional.value();
    coin_escrow::burn_conditional_stable<AssetType, StableType, CondStable>(
        escrow,
        outcome_idx,
        conditional,
    );
    coin_escrow::withdraw_stable_balance(escrow, amount, ctx)
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// ============================================================================
/// UNIFIED SPOT POOL - Single pool type with optional aggregator support
/// ============================================================================
///
/// DESIGN GOALS:
/// - Replace both SpotAMM and AccountSpotPool with single unified type
/// - Optional aggregator features (zero overhead when disabled)
/// - NO circular dependencies (uses IDs, not concrete types)
/// - Backward compatible initialization
///
/// DEPENDENCY SAFETY:
/// This module ONLY imports:
/// - sui framework (clock, balance, coin, etc.)
/// - futarchy_markets basic types (simple_twap, coin_escrow)
/// - Does NOT import: proposal or lifecycle modules
///
/// This ensures: proposal.move ‚Üí unified_spot_pool (one-way dependency)
///
/// ============================================================================

module futarchy_markets_core::unified_spot_pool;

use futarchy_markets_primitives::coin_escrow::{Self, TokenEscrow};
use futarchy_markets_primitives::PCW_TWAP_oracle::{Self, SimpleTWAP};
use futarchy_markets_primitives::fee_scheduler::{Self, FeeSchedule};
use std::option::{Self, Option};
use std::type_name::TypeName;
use std::vector;
use sui::balance::{Self, Balance};
use sui::clock::Clock;
use sui::coin::{Self, Coin};
use sui::object::{Self, UID, ID};
use sui::transfer;

// === Errors ===
const EInsufficientLiquidity: u64 = 1;
const EInsufficientLPSupply: u64 = 3;
const EZeroAmount: u64 = 4;
const ESlippageExceeded: u64 = 5;
const EMinimumLiquidityNotMet: u64 = 6;
const ENoActiveProposal: u64 = 7;
const EAggregatorNotEnabled: u64 = 11;
const EPoolMismatch: u64 = 12;
const ELpStateMismatch: u64 = 13;
const EInvalidSplitAmount: u64 = 14;

// === Constants ===
const MINIMUM_LIQUIDITY: u64 = 1000;
const PRECISION: u128 = 1_000_000_000_000; // 1e12 for price calculations

// === Structs ===

/// Unified spot pool with optional aggregator support
public struct UnifiedSpotPool<phantom AssetType, phantom StableType> has key, store {
    id: UID,
    // Core AMM fields
    asset_reserve: Balance<AssetType>,
    stable_reserve: Balance<StableType>,
    lp_supply: u64,
    fee_bps: u64, // Static fee (used if fee_schedule is None)
    minimum_liquidity: u64,
    // Dynamic fee scheduling (optional, for launchpad anti-snipe)
    fee_schedule: Option<FeeSchedule>,
    fee_schedule_activation_time: u64, // When fee decay starts (usually pool creation)
    // Bucket tracking for LP withdrawal system - HYPER EXPLICIT NAMES
    //
    // spot_active_quantum_lp:
    //   - Normal active LP that quantum-splits when proposals start
    //   - Can be removed anytime (if no proposal active)
    //
    // spot_leave_lp_when_proposal_ends:
    //   - User marked for exit during active proposal
    //   - Gets one final quantum-split to conditionals
    //   - Becomes spot_frozen_claimable_lp when proposal ends
    //
    // spot_frozen_claimable_lp:
    //   - Fully withdrawn, ready for user to claim
    //   - Does NOT quantum-split (stays in spot)
    //   - Final destination before burning LP token
    //
    // spot_join_quantum_lp_when_proposal_ends:
    //   - New LP added during active proposal
    //   - Does NOT quantum-split to current proposal (isolated from outcome)
    //   - Becomes spot_active_quantum_lp when proposal ends
    asset_spot_active_quantum_lp: u64,
    asset_spot_leave_lp_when_proposal_ends: u64,
    asset_spot_frozen_claimable_lp: u64,
    asset_spot_join_quantum_lp_when_proposal_ends: u64,
    stable_spot_active_quantum_lp: u64,
    stable_spot_leave_lp_when_proposal_ends: u64,
    stable_spot_frozen_claimable_lp: u64,
    stable_spot_join_quantum_lp_when_proposal_ends: u64,
    lp_spot_active_quantum_lp: u64,
    lp_spot_leave_lp_when_proposal_ends: u64,
    lp_spot_frozen_claimable_lp: u64,
    lp_spot_join_quantum_lp_when_proposal_ends: u64,
    // Optional aggregator configuration
    aggregator_config: Option<AggregatorConfig<AssetType, StableType>>,
}

/// Aggregator-specific configuration (only present when enabled)
public struct AggregatorConfig<phantom AssetType, phantom StableType> has store {
    // Active escrow ID for proposal trading
    // Stored when proposal starts, cleared when proposal ends
    // NOTE: We store ID (not TokenEscrow) because shared objects can't be stored in owned objects
    active_escrow: Option<ID>,
    // TWAP oracle for price feeds
    simple_twap: SimpleTWAP,
    // Liquidity tracking for oracle switching
    last_proposal_usage: Option<u64>,
    conditional_liquidity_ratio_percent: u64, // 1-99 (base 100, enforced by DAO config)
    oracle_conditional_threshold_bps: u64, // When to use conditional vs spot oracle
    spot_cumulative_at_lock: Option<u256>,
    // Protocol fees (separate from LP fees) - collected in both asset and stable tokens
    protocol_fees_asset: Balance<AssetType>,
    protocol_fees_stable: Balance<StableType>,
}

/// LP Token - represents ownership of pool liquidity
public struct LPToken<phantom AssetType, phantom StableType> has key, store {
    id: UID,
    /// Amount of LP tokens
    amount: u64,
    /// Parent pool that minted this LP
    pool_id: ID,
    /// Proposal lock - if Some(id), LP is locked in proposal {id}
    /// Liquidity is quantum-split to conditional markets during proposal
    /// None = LP is in spot pool and can be withdrawn freely
    locked_in_proposal: Option<ID>,
    /// Withdraw mode - if true, extract as coins when proposal ends
    /// If false (default), auto-recombine to spot LP when proposal ends
    /// Set to true when user tries to withdraw but would violate minimum liquidity
    withdraw_mode: bool,
}

// === LP Token Functions ===

/// Get LP token amount
public fun lp_token_amount<AssetType, StableType>(lp_token: &LPToken<AssetType, StableType>): u64 {
    lp_token.amount
}

/// Get the pool ID this LP belongs to
public fun lp_token_pool_id<AssetType, StableType>(lp_token: &LPToken<AssetType, StableType>): ID {
    lp_token.pool_id
}

/// Check if LP is locked in a proposal
/// Returns true if locked and proposal is not finalized
public fun is_locked_in_proposal<AssetType, StableType>(
    lp_token: &LPToken<AssetType, StableType>,
): bool {
    lp_token.locked_in_proposal.is_some()
}

/// Get the proposal ID this LP is locked in
public fun get_locked_proposal<AssetType, StableType>(
    lp_token: &LPToken<AssetType, StableType>,
): Option<ID> {
    lp_token.locked_in_proposal
}

/// Check if LP is in withdraw mode
public fun is_withdraw_mode<AssetType, StableType>(
    lp_token: &LPToken<AssetType, StableType>,
): bool {
    lp_token.withdraw_mode
}

/// Lock LP in a proposal (package-visible for quantum_lp_manager)
public(package) fun lock_in_proposal<AssetType, StableType>(
    lp_token: &mut LPToken<AssetType, StableType>,
    proposal_id: ID,
) {
    lp_token.locked_in_proposal = option::some(proposal_id);
}

/// Unlock LP from proposal (package-visible for quantum_lp_manager)
public(package) fun unlock_from_proposal<AssetType, StableType>(
    lp_token: &mut LPToken<AssetType, StableType>,
) {
    lp_token.locked_in_proposal = option::none();
}

/// Set withdraw mode (package-visible for quantum_lp_manager)
public(package) fun set_withdraw_mode<AssetType, StableType>(
    lp_token: &mut LPToken<AssetType, StableType>,
    mode: bool,
) {
    lp_token.withdraw_mode = mode;
}

/// Destroy LP token (package-visible for quantum_lp_manager claim flow)
/// Returns the LP amount for calculation purposes
public(package) fun destroy_lp_token<AssetType, StableType>(
    lp_token: LPToken<AssetType, StableType>,
): u64 {
    let LPToken { id, amount, pool_id: _, locked_in_proposal: _, withdraw_mode: _ } = lp_token;
    object::delete(id);
    amount
}

// === Creation Functions ===

/// Create a futarchy spot pool with FULL features
/// All futarchy pools have: TWAP oracle, escrow tracking, bucket management
/// There is NO "simple" mode - all pools need these features for governance
public fun new<AssetType, StableType>(
    fee_bps: u64,
    fee_schedule: Option<FeeSchedule>, // Optional dynamic fee schedule (for launchpad)
    oracle_conditional_threshold_bps: u64, // When to use conditional vs spot oracle (typically 5000 = 50%)
    conditional_liquidity_ratio_percent: u64, // DAO's configured ratio for quantum split (1-99)
    clock: &Clock,
    ctx: &mut TxContext,
): UnifiedSpotPool<AssetType, StableType> {
    // Initialize TWAP oracle (starts at 0, updated on first swap)
    let simple_twap = PCW_TWAP_oracle::new_default(0, clock);

    let aggregator_config = AggregatorConfig {
        active_escrow: option::none(),
        simple_twap,
        last_proposal_usage: option::none(),
        conditional_liquidity_ratio_percent, // Set from DAO config at creation!
        oracle_conditional_threshold_bps,
        spot_cumulative_at_lock: option::none(),
        protocol_fees_asset: balance::zero(),
        protocol_fees_stable: balance::zero(),
    };

    UnifiedSpotPool {
        id: object::new(ctx),
        asset_reserve: balance::zero(),
        stable_reserve: balance::zero(),
        lp_supply: 0,
        fee_bps,
        minimum_liquidity: MINIMUM_LIQUIDITY,
        fee_schedule,
        fee_schedule_activation_time: clock.timestamp_ms(),
        // Initialize all bucket system to zero
        asset_spot_active_quantum_lp: 0,
        asset_spot_leave_lp_when_proposal_ends: 0,
        asset_spot_frozen_claimable_lp: 0,
        asset_spot_join_quantum_lp_when_proposal_ends: 0,
        stable_spot_active_quantum_lp: 0,
        stable_spot_leave_lp_when_proposal_ends: 0,
        stable_spot_frozen_claimable_lp: 0,
        stable_spot_join_quantum_lp_when_proposal_ends: 0,
        lp_spot_active_quantum_lp: 0,
        lp_spot_leave_lp_when_proposal_ends: 0,
        lp_spot_frozen_claimable_lp: 0,
        lp_spot_join_quantum_lp_when_proposal_ends: 0,
        aggregator_config: option::some(aggregator_config), // ALWAYS enabled
    }
}

/// DEPRECATED: Use new() instead - all pools now have full features
/// This function is kept for backwards compatibility but just calls new()
public fun new_with_aggregator<AssetType, StableType>(
    fee_bps: u64,
    fee_schedule: Option<FeeSchedule>, // Optional dynamic fee schedule (for launchpad)
    oracle_conditional_threshold_bps: u64,
    conditional_liquidity_ratio_percent: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): UnifiedSpotPool<AssetType, StableType> {
    // Just forward to new() - they're now identical
    new(fee_bps, fee_schedule, oracle_conditional_threshold_bps, conditional_liquidity_ratio_percent, clock, ctx)
}

/// Upgrade existing pool to add aggregator support
/// Can be called via governance to enable aggregator features
public fun enable_aggregator<AssetType, StableType>(
    pool: &mut UnifiedSpotPool<AssetType, StableType>,
    oracle_conditional_threshold_bps: u64,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    // No-op: all pools already have full features enabled at creation
}

// === Escrow Management Functions (Aggregator Only) ===

/// Store active escrow ID when proposal starts trading
/// NOTE: Takes ID (not TokenEscrow object) because shared objects can't be stored
public fun store_active_escrow<AssetType, StableType>(
    pool: &mut UnifiedSpotPool<AssetType, StableType>,
    escrow_id: ID,
) {
    assert!(pool.aggregator_config.is_some(), EAggregatorNotEnabled);
    let config = pool.aggregator_config.borrow_mut();
    assert!(config.active_escrow.is_none(), ENoActiveProposal); // Must not already have escrow
    option::fill(&mut config.active_escrow, escrow_id);
}

/// Extract active escrow ID when proposal ends
/// Returns the escrow ID to caller (to look up the shared object)
public fun extract_active_escrow<AssetType, StableType>(
    pool: &mut UnifiedSpotPool<AssetType, StableType>,
): ID {
    assert!(pool.aggregator_config.is_some(), EAggregatorNotEnabled);
    let config = pool.aggregator_config.borrow_mut();
    assert!(config.active_escrow.is_some(), ENoActiveProposal); // Must have escrow
    option::extract(&mut config.active_escrow)
}

/// Get active escrow ID (read-only)
/// Returns None if no active escrow
public fun get_active_escrow_id<AssetType, StableType>(
    pool: &UnifiedSpotPool<AssetType, StableType>,
): Option<ID> {
    if (pool.aggregator_config.is_none()) {
        return option::none()
    };
    let config = pool.aggregator_config.borrow();
    config.active_escrow
}

// === Core AMM Functions ===

/// Add liquidity to the pool and return LP token with excess coins
///
/// IMPORTANT: LP can be added anytime, including during active proposals.
/// - If no proposal active: LP goes to LIVE bucket (participates immediately)
/// - If proposal active: LP goes to PENDING bucket (joins spot pool when proposal ends)
///
/// This prevents new LP from unfairly benefiting from conditional market outcomes.
/// Returns: (LPToken, excess_asset_coin, excess_stable_coin)
public fun add_liquidity<AssetType, StableType>(
    pool: &mut UnifiedSpotPool<AssetType, StableType>,
    asset_coin: Coin<AssetType>,
    stable_coin: Coin<StableType>,
    min_lp_out: u64,
    ctx: &mut TxContext,
): (LPToken<AssetType, StableType>, Coin<AssetType>, Coin<StableType>) {
    add_liquidity_and_return(pool, asset_coin, stable_coin, min_lp_out, ctx)
}

/// Add liquidity and return LP token with excess coins (explicit name for clarity)
/// Returns: (LPToken, excess_asset_coin, excess_stable_coin)
///
/// CRITICAL: This function calculates the optimal amounts needed to match pool ratio
/// and returns any excess coins instead of depositing them (which would donate to existing LPs)
public fun add_liquidity_and_return<AssetType, StableType>(
    pool: &mut UnifiedSpotPool<AssetType, StableType>,
    asset_coin: Coin<AssetType>,
    stable_coin: Coin<StableType>,
    min_lp_out: u64,
    ctx: &mut TxContext,
): (LPToken<AssetType, StableType>, Coin<AssetType>, Coin<StableType>) {
    let asset_amount = coin::value(&asset_coin);
    let stable_amount = coin::value(&stable_coin);

    assert!(asset_amount > 0 && stable_amount > 0, EZeroAmount);

    // Calculate LP tokens to mint and optimal amounts to deposit
    let (lp_amount, optimal_asset_amount, optimal_stable_amount) = if (pool.lp_supply == 0) {
        // Initial liquidity - use all coins provided (no pool ratio to match)
        let product = (asset_amount as u128) * (stable_amount as u128);
        let initial_lp = (product.sqrt() as u64);
        assert!(initial_lp >= pool.minimum_liquidity, EMinimumLiquidityNotMet);

        // Lock minimum liquidity permanently
        pool.lp_supply = pool.minimum_liquidity;
        (initial_lp - pool.minimum_liquidity, asset_amount, stable_amount)
    } else {
        // Proportional liquidity based on current reserves
        // NOTE: This function is now blocked during active proposals,
        // so we always use actual spot reserves (no quantum-split complexity)
        let asset_reserve = balance::value(&pool.asset_reserve);
        let stable_reserve = balance::value(&pool.stable_reserve);

        // Calculate LP from each coin type
        let lp_from_asset =
            (asset_amount as u128) * (pool.lp_supply as u128) / (asset_reserve as u128);
        let lp_from_stable =
            (stable_amount as u128) * (pool.lp_supply as u128) / (stable_reserve as u128);

        // Use minimum to maintain ratio - calculate actual amounts needed
        let lp_to_mint = lp_from_asset.min(lp_from_stable);

        // Calculate optimal amounts that maintain exact pool ratio
        let optimal_asset = (lp_to_mint * (asset_reserve as u128) / (pool.lp_supply as u128)) as u64;
        let optimal_stable = (lp_to_mint * (stable_reserve as u128) / (pool.lp_supply as u128)) as u64;

        ((lp_to_mint as u64), optimal_asset, optimal_stable)
    };

    assert!(lp_amount >= min_lp_out, ESlippageExceeded);

    // Split coins into amounts to deposit and amounts to return
    let mut asset_coin_to_deposit = asset_coin;
    let mut stable_coin_to_deposit = stable_coin;

    let excess_asset = if (asset_amount > optimal_asset_amount) {
        coin::split(&mut asset_coin_to_deposit, asset_amount - optimal_asset_amount, ctx)
    } else {
        coin::zero<AssetType>(ctx)
    };

    let excess_stable = if (stable_amount > optimal_stable_amount) {
        coin::split(&mut stable_coin_to_deposit, stable_amount - optimal_stable_amount, ctx)
    } else {
        coin::zero<StableType>(ctx)
    };

    // Add optimal amounts to reserves
    balance::join(&mut pool.asset_reserve, coin::into_balance(asset_coin_to_deposit));
    balance::join(&mut pool.stable_reserve, coin::into_balance(stable_coin_to_deposit));

    pool.lp_supply = pool.lp_supply + lp_amount;

    // Route to appropriate bucket based on proposal status
    if (is_locked_for_proposal(pool)) {
        // Proposal is active - add to PENDING bucket
        // This LP will merge into LIVE when proposal ends
        pool.asset_spot_join_quantum_lp_when_proposal_ends = pool.asset_spot_join_quantum_lp_when_proposal_ends + optimal_asset_amount;
        pool.stable_spot_join_quantum_lp_when_proposal_ends = pool.stable_spot_join_quantum_lp_when_proposal_ends + optimal_stable_amount;
        pool.lp_spot_join_quantum_lp_when_proposal_ends = pool.lp_spot_join_quantum_lp_when_proposal_ends + lp_amount;
    } else {
        // No active proposal - add to LIVE bucket
        pool.asset_spot_active_quantum_lp = pool.asset_spot_active_quantum_lp + optimal_asset_amount;
        pool.stable_spot_active_quantum_lp = pool.stable_spot_active_quantum_lp + optimal_stable_amount;
        pool.lp_spot_active_quantum_lp = pool.lp_spot_active_quantum_lp + lp_amount;
    };

    // Create and return LP token (unlocked, normal mode by default) + excess coins
    let lp_token = LPToken<AssetType, StableType> {
        id: object::new(ctx),
        amount: lp_amount,
        pool_id: object::uid_to_inner(&pool.id),
        locked_in_proposal: option::none(),
        withdraw_mode: false,
    };

    (lp_token, excess_asset, excess_stable)
}

/// Merge PENDING bucket into LIVE bucket
/// Called after proposal ends to activate LP that was added during the proposal
public(package) fun merge_joining_to_active_quantum_lp<AssetType, StableType>(
    pool: &mut UnifiedSpotPool<AssetType, StableType>,
) {
    pool.asset_spot_active_quantum_lp = pool.asset_spot_active_quantum_lp + pool.asset_spot_join_quantum_lp_when_proposal_ends;
    pool.stable_spot_active_quantum_lp = pool.stable_spot_active_quantum_lp + pool.stable_spot_join_quantum_lp_when_proposal_ends;
    pool.lp_spot_active_quantum_lp = pool.lp_spot_active_quantum_lp + pool.lp_spot_join_quantum_lp_when_proposal_ends;

    // Reset pending buckets to zero
    pool.asset_spot_join_quantum_lp_when_proposal_ends = 0;
    pool.stable_spot_join_quantum_lp_when_proposal_ends = 0;
    pool.lp_spot_join_quantum_lp_when_proposal_ends = 0;
}

/// Remove liquidity from the pool
/// NOTE: This function is for removing from LIVE bucket ONLY
/// For withdrawal after marking, use mark_lp_for_withdrawal() + withdraw_lp()
public fun remove_liquidity<AssetType, StableType>(
    pool: &mut UnifiedSpotPool<AssetType, StableType>,
    lp_token: LPToken<AssetType, StableType>,
    min_asset_out: u64,
    min_stable_out: u64,
    ctx: &mut TxContext,
): (Coin<AssetType>, Coin<StableType>) {
    let lp_amount = lp_token.amount;
    assert!(lp_amount > 0, EZeroAmount);
    assert!(pool.lp_supply >= lp_amount, EInsufficientLPSupply);

    // CRITICAL: Check LP token state - can only remove from LIVE bucket
    assert!(!lp_token.withdraw_mode, EInsufficientLiquidity); // Use mark_lp_for_withdrawal() + withdraw_lp() instead
    assert!(lp_token.locked_in_proposal.is_none(), ENoActiveProposal); // Can't remove while locked

    // Calculate proportional amounts from total reserves
    let asset_reserve = balance::value(&pool.asset_reserve);
    let stable_reserve = balance::value(&pool.stable_reserve);

    let asset_out = (asset_reserve as u128) * (lp_amount as u128) / (pool.lp_supply as u128);
    let stable_out = (stable_reserve as u128) * (lp_amount as u128) / (pool.lp_supply as u128);

    assert!((asset_out as u64) >= min_asset_out, ESlippageExceeded);
    assert!((stable_out as u64) >= min_stable_out, ESlippageExceeded);

    // Burn LP token
    let LPToken { id, amount: _, pool_id: _, locked_in_proposal: _, withdraw_mode: _ } = lp_token;
    object::delete(id);

    // Update total supply
    pool.lp_supply = pool.lp_supply - lp_amount;

    // CRITICAL FIX: Update bucket tracking (remove from LIVE bucket)
    // Calculate proportional amounts from LIVE bucket
    let asset_from_live = (lp_amount as u128) * (pool.asset_spot_active_quantum_lp as u128) / (pool.lp_spot_active_quantum_lp as u128);
    let stable_from_live =
        (lp_amount as u128) * (pool.stable_spot_active_quantum_lp as u128) / (pool.lp_spot_active_quantum_lp as u128);

    pool.lp_spot_active_quantum_lp = pool.lp_spot_active_quantum_lp - lp_amount;
    pool.asset_spot_active_quantum_lp = pool.asset_spot_active_quantum_lp - (asset_from_live as u64);
    pool.stable_spot_active_quantum_lp = pool.stable_spot_active_quantum_lp - (stable_from_live as u64);

    // Return assets
    let asset_coin = coin::from_balance(
        balance::split(&mut pool.asset_reserve, (asset_out as u64)),
        ctx,
    );
    let stable_coin = coin::from_balance(
        balance::split(&mut pool.stable_reserve, (stable_out as u64)),
        ctx,
    );

    // CRITICAL: Ensure remaining pool maintains minimum liquidity requirement
    // Three-layer defense:
    // 1. Protocol min (100,000 via DAO config) - prevents misconfiguration
    // 2. Check k >= 1000 - Uniswap V2 invariant (basic protection)
    // 3. Check against active ratio - Future-proof for multi-proposal scenarios
    let remaining_asset = balance::value(&pool.asset_reserve);
    let remaining_stable = balance::value(&pool.stable_reserve);
    let remaining_k = (remaining_asset as u128) * (remaining_stable as u128);

    // Basic check: k >= 1000 (Uniswap V2 minimum)
    assert!(remaining_k >= (MINIMUM_LIQUIDITY as u128), EMinimumLiquidityNotMet);

    // Enhanced check: If proposal is active with stored ratio, validate against that ratio
    // This handles future multi-proposal scenarios where ratio might change during active proposals
    // Current model: one proposal at a time (ratio stored, used, then reset to 0)
    // Future model: multiple proposals could require stacked ratio validation
    if (pool.aggregator_config.is_some()) {
        let config = pool.aggregator_config.borrow();
        let active_ratio = config.conditional_liquidity_ratio_percent;

        // If ratio is active (non-zero), ensure remaining liquidity could support that ratio
        // with k >= 1000 after a quantum split
        if (active_ratio > 0) {
            let spot_ratio = 100 - active_ratio;
            let projected_spot_asset = (remaining_asset as u128) * (spot_ratio as u128) / 100u128;
            let projected_spot_stable = (remaining_stable as u128) * (spot_ratio as u128) / 100u128;
            let projected_k = projected_spot_asset * projected_spot_stable;
            assert!(projected_k >= (MINIMUM_LIQUIDITY as u128), EMinimumLiquidityNotMet);
        };
    };

    (asset_coin, stable_coin)
}

// === LP Withdrawal System ===

/// Mark LP for withdrawal - user triggers this to exit
/// If proposal is active: moves LIVE ‚Üí TRANSITIONING (still trades)
/// If no proposal: moves LIVE ‚Üí WITHDRAW_ONLY (immediate)
public entry fun mark_lp_for_withdrawal<AssetType, StableType>(
    pool: &mut UnifiedSpotPool<AssetType, StableType>,
    lp_token: &mut LPToken<AssetType, StableType>,
) {
    // Can't mark for withdrawal if already locked in a proposal
    assert!(lp_token.locked_in_proposal.is_none(), ENoActiveProposal);

    // Can't mark twice
    assert!(!lp_token.withdraw_mode, EInsufficientLiquidity);

    let lp_amount = lp_token.amount;
    assert!(lp_amount > 0, EZeroAmount);

    // Check if there's an active proposal
    let proposal_active = is_locked_for_proposal(pool);

    if (proposal_active) {
        // Move from LIVE ‚Üí TRANSITIONING
        // Calculate proportional share of LIVE bucket
        assert!(pool.lp_spot_active_quantum_lp >= lp_amount, EInsufficientLPSupply);

        let asset_to_move =
            (lp_amount as u128) * (pool.asset_spot_active_quantum_lp as u128) / (pool.lp_spot_active_quantum_lp as u128);
        let stable_to_move =
            (lp_amount as u128) * (pool.stable_spot_active_quantum_lp as u128) / (pool.lp_spot_active_quantum_lp as u128);

        // Update buckets
        pool.lp_spot_active_quantum_lp = pool.lp_spot_active_quantum_lp - lp_amount;
        pool.lp_spot_leave_lp_when_proposal_ends = pool.lp_spot_leave_lp_when_proposal_ends + lp_amount;

        pool.asset_spot_active_quantum_lp = pool.asset_spot_active_quantum_lp - (asset_to_move as u64);
        pool.asset_spot_leave_lp_when_proposal_ends = pool.asset_spot_leave_lp_when_proposal_ends + (asset_to_move as u64);

        pool.stable_spot_active_quantum_lp = pool.stable_spot_active_quantum_lp - (stable_to_move as u64);
        pool.stable_spot_leave_lp_when_proposal_ends = pool.stable_spot_leave_lp_when_proposal_ends + (stable_to_move as u64);
    } else {
        // Move from LIVE ‚Üí WITHDRAW_ONLY (immediate)
        assert!(pool.lp_spot_active_quantum_lp >= lp_amount, EInsufficientLPSupply);

        let asset_to_move =
            (lp_amount as u128) * (pool.asset_spot_active_quantum_lp as u128) / (pool.lp_spot_active_quantum_lp as u128);
        let stable_to_move =
            (lp_amount as u128) * (pool.stable_spot_active_quantum_lp as u128) / (pool.lp_spot_active_quantum_lp as u128);

        // Update buckets
        pool.lp_spot_active_quantum_lp = pool.lp_spot_active_quantum_lp - lp_amount;
        pool.lp_spot_frozen_claimable_lp = pool.lp_spot_frozen_claimable_lp + lp_amount;

        pool.asset_spot_active_quantum_lp = pool.asset_spot_active_quantum_lp - (asset_to_move as u64);
        pool.asset_spot_frozen_claimable_lp = pool.asset_spot_frozen_claimable_lp + (asset_to_move as u64);

        pool.stable_spot_active_quantum_lp = pool.stable_spot_active_quantum_lp - (stable_to_move as u64);
        pool.stable_spot_frozen_claimable_lp = pool.stable_spot_frozen_claimable_lp + (stable_to_move as u64);
    };

    // Mark token as in withdraw mode
    lp_token.withdraw_mode = true;
}

/// Withdraw LP after it's been marked and crank has run
/// Burns the LP token and returns coins from WITHDRAW_ONLY bucket
public fun withdraw_lp<AssetType, StableType>(
    pool: &mut UnifiedSpotPool<AssetType, StableType>,
    lp_token: LPToken<AssetType, StableType>,
    ctx: &mut TxContext,
): (Coin<AssetType>, Coin<StableType>) {
    // Must be marked for withdrawal
    assert!(lp_token.withdraw_mode, EInsufficientLiquidity);

    // Must not be locked in a proposal
    assert!(lp_token.locked_in_proposal.is_none(), ENoActiveProposal);

    let lp_amount = lp_token.amount;
    assert!(lp_amount > 0, EZeroAmount);
    assert!(pool.lp_spot_frozen_claimable_lp >= lp_amount, EInsufficientLPSupply);

    // Calculate proportional share of WITHDRAW_ONLY bucket
    let asset_out =
        (lp_amount as u128) * (pool.asset_spot_frozen_claimable_lp as u128) / (pool.lp_spot_frozen_claimable_lp as u128);
    let stable_out =
        (lp_amount as u128) * (pool.stable_spot_frozen_claimable_lp as u128) / (pool.lp_spot_frozen_claimable_lp as u128);

    // Update buckets
    pool.lp_spot_frozen_claimable_lp = pool.lp_spot_frozen_claimable_lp - lp_amount;
    pool.asset_spot_frozen_claimable_lp = pool.asset_spot_frozen_claimable_lp - (asset_out as u64);
    pool.stable_spot_frozen_claimable_lp = pool.stable_spot_frozen_claimable_lp - (stable_out as u64);

    // Update total supply
    pool.lp_supply = pool.lp_supply - lp_amount;

    // Burn LP token
    let LPToken { id, amount: _, pool_id: _, locked_in_proposal: _, withdraw_mode: _ } = lp_token;
    object::delete(id);

    // Extract coins from reserves
    let asset_coin = coin::from_balance(
        balance::split(&mut pool.asset_reserve, (asset_out as u64)),
        ctx,
    );
    let stable_coin = coin::from_balance(
        balance::split(&mut pool.stable_reserve, (stable_out as u64)),
        ctx,
    );

    (asset_coin, stable_coin)
}

/// Transition all TRANSITIONING bucket amounts to WITHDRAW_ONLY
/// Called by crank when proposal finalizes
/// This is an atomic batch operation that makes all marked LPs claimable
public(package) fun transition_leaving_to_claimable<AssetType, StableType>(
    pool: &mut UnifiedSpotPool<AssetType, StableType>,
) {
    // Move all TRANSITIONING amounts to WITHDRAW_ONLY
    pool.asset_spot_frozen_claimable_lp = pool.asset_spot_frozen_claimable_lp + pool.asset_spot_leave_lp_when_proposal_ends;
    pool.stable_spot_frozen_claimable_lp = pool.stable_spot_frozen_claimable_lp + pool.stable_spot_leave_lp_when_proposal_ends;
    pool.lp_spot_frozen_claimable_lp = pool.lp_spot_frozen_claimable_lp + pool.lp_spot_leave_lp_when_proposal_ends;

    // Reset TRANSITIONING buckets to zero
    pool.asset_spot_leave_lp_when_proposal_ends = 0;
    pool.stable_spot_leave_lp_when_proposal_ends = 0;
    pool.lp_spot_leave_lp_when_proposal_ends = 0;
}

/// Alias for transition_leaving_to_claimable (for backward compatibility)
/// Public visibility for cross-package calls
public fun transition_leaving_to_frozen_claimable<AssetType, StableType>(
    pool: &mut UnifiedSpotPool<AssetType, StableType>,
) {
    transition_leaving_to_claimable(pool)
}

// === Fee Calculation ===

/// Get current fee for this pool based on fee schedule or static fee
fun get_current_fee_bps<AssetType, StableType>(
    pool: &UnifiedSpotPool<AssetType, StableType>,
    clock: &Clock
): u64 {
    if (pool.fee_schedule.is_some()) {
        // Use dynamic fee schedule with pool's base fee as final target
        fee_scheduler::get_current_fee(
            pool.fee_schedule.borrow(),
            pool.fee_bps,  // Final fee = pool's base spot fee
            pool.fee_schedule_activation_time,
            clock.timestamp_ms()
        )
    } else {
        // Use static fee
        pool.fee_bps
    }
}

/// Update the pool's cached fee_bps from fee schedule (if active)
/// Call this BEFORE swaps/arbitrage to ensure fee_bps is current
/// After fee schedule ends, fee_bps will equal the final static fee
public(package) fun update_cached_fee_if_needed<AssetType, StableType>(
    pool: &mut UnifiedSpotPool<AssetType, StableType>,
    clock: &Clock
) {
    if (pool.fee_schedule.is_some()) {
        let current_fee = get_current_fee_bps(pool, clock);
        pool.fee_bps = current_fee;  // Cache current fee for pure functions
    }
    // If no schedule, fee_bps already has the static fee
}

/// Check if proposals are allowed for this pool
/// Returns false if fee schedule is still active (decaying)
/// CRITICAL: Prevents proposals from starting while fees are high (would break arbitrage)
public fun can_create_proposals<AssetType, StableType>(
    pool: &UnifiedSpotPool<AssetType, StableType>,
    clock: &Clock
): bool {
    if (pool.fee_schedule.is_some()) {
        // If fee schedule exists, check if decay period has ended
        let schedule = pool.fee_schedule.borrow();
        let current_time = clock.timestamp_ms();
        let activation_time = pool.fee_schedule_activation_time;

        // Fee schedule is active if we're still within the decay period
        let is_active = if (current_time <= activation_time) {
            true // Not started yet
        } else {
            let elapsed = current_time - activation_time;
            elapsed < fee_scheduler::duration_ms(schedule)
        };

        // Proposals allowed when fee schedule is NOT active (has ended)
        !is_active
    } else {
        // No fee schedule, proposals always allowed
        true
    }
}

/// INTERNAL: Swap stable for asset (used by arbitrage only)
/// Public swaps must go through swap_entry to trigger auto-arbitrage
public fun swap_stable_for_asset<AssetType, StableType>(
    pool: &mut UnifiedSpotPool<AssetType, StableType>,
    mut stable_in: Coin<StableType>,
    min_asset_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<AssetType> {
    let stable_amount = coin::value(&stable_in);
    assert!(stable_amount > 0, EZeroAmount);

    // Calculate output with fee
    let asset_reserve = balance::value(&pool.asset_reserve);
    let stable_reserve = balance::value(&pool.stable_reserve);

    // Get dynamic fee if fee scheduler is configured
    let current_fee_bps = get_current_fee_bps(pool, clock);
    let total_fee = stable_amount * current_fee_bps / 10000;

    // Split fee: 90% for LPs, 10% for protocol (if aggregator enabled)
    let (lp_share, protocol_share) = if (pool.aggregator_config.is_some()) {
        use futarchy_one_shot_utils::constants;
        use futarchy_one_shot_utils::math;
        let lp_fee = math::mul_div_to_64(total_fee, constants::spot_lp_fee_share_bps(), constants::total_fee_bps());
        let protocol_fee = total_fee - lp_fee;
        (lp_fee, protocol_fee)
    } else {
        (total_fee, 0) // No aggregator = all fees to LPs
    };

    let stable_after_fee = stable_amount - total_fee;
    let asset_out =
        (asset_reserve as u128) * (stable_after_fee as u128) /
                    ((stable_reserve as u128) + (stable_after_fee as u128));

    assert!((asset_out as u64) >= min_asset_out, ESlippageExceeded);
    assert!((asset_out as u64) < asset_reserve, EInsufficientLiquidity);

    // Update spot TWAP and collect protocol fees (if aggregator enabled)
    if (pool.aggregator_config.is_some()) {
        let price_before = get_spot_price(pool);
        let config = pool.aggregator_config.borrow_mut();
        PCW_TWAP_oracle::update(&mut config.simple_twap, price_before, clock);

        // Collect protocol fee in stable token
        if (protocol_share > 0) {
            let protocol_fee_balance = balance::split(coin::balance_mut(&mut stable_in), protocol_share);
            balance::join(&mut config.protocol_fees_stable, protocol_fee_balance);
        };
    };

    // Update reserves (LP share + swap amount goes to reserves)
    balance::join(&mut pool.stable_reserve, coin::into_balance(stable_in));
    let asset_coin = coin::from_balance(
        balance::split(&mut pool.asset_reserve, (asset_out as u64)),
        ctx,
    );

    asset_coin
}

/// INTERNAL: Swap asset for stable (used by arbitrage only)
/// Public swaps must go through swap_entry to trigger auto-arbitrage
public fun swap_asset_for_stable<AssetType, StableType>(
    pool: &mut UnifiedSpotPool<AssetType, StableType>,
    mut asset_in: Coin<AssetType>,
    min_stable_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<StableType> {
    let asset_amount = coin::value(&asset_in);
    assert!(asset_amount > 0, EZeroAmount);

    // Calculate output with fee
    let asset_reserve = balance::value(&pool.asset_reserve);
    let stable_reserve = balance::value(&pool.stable_reserve);

    // Get dynamic fee if fee scheduler is configured
    let current_fee_bps = get_current_fee_bps(pool, clock);
    let total_fee = asset_amount * current_fee_bps / 10000;

    // Split fee: 90% for LPs, 10% for protocol (if aggregator enabled)
    let (lp_share, protocol_share) = if (pool.aggregator_config.is_some()) {
        use futarchy_one_shot_utils::constants;
        use futarchy_one_shot_utils::math;
        let lp_fee = math::mul_div_to_64(total_fee, constants::spot_lp_fee_share_bps(), constants::total_fee_bps());
        let protocol_fee = total_fee - lp_fee;
        (lp_fee, protocol_fee)
    } else {
        (total_fee, 0) // No aggregator = all fees to LPs
    };

    let asset_after_fee = asset_amount - total_fee;
    let stable_out =
        (stable_reserve as u128) * (asset_after_fee as u128) /
                     ((asset_reserve as u128) + (asset_after_fee as u128));

    assert!((stable_out as u64) >= min_stable_out, ESlippageExceeded);
    assert!((stable_out as u64) < stable_reserve, EInsufficientLiquidity);

    // Update spot TWAP and collect protocol fees (if aggregator enabled)
    if (pool.aggregator_config.is_some()) {
        let price_before = get_spot_price(pool);
        let config = pool.aggregator_config.borrow_mut();
        PCW_TWAP_oracle::update(&mut config.simple_twap, price_before, clock);

        // Collect protocol fee in asset token
        if (protocol_share > 0) {
            let protocol_fee_balance = balance::split(coin::balance_mut(&mut asset_in), protocol_share);
            balance::join(&mut config.protocol_fees_asset, protocol_fee_balance);
        };
    };

    // Update reserves (LP share + swap amount goes to reserves)
    balance::join(&mut pool.asset_reserve, coin::into_balance(asset_in));
    let stable_coin = coin::from_balance(
        balance::split(&mut pool.stable_reserve, (stable_out as u64)),
        ctx,
    );

    stable_coin
}

// === View Functions ===

/// Get current reserves
public fun get_reserves<AssetType, StableType>(
    pool: &UnifiedSpotPool<AssetType, StableType>,
): (u64, u64) {
    (balance::value(&pool.asset_reserve), balance::value(&pool.stable_reserve))
}

/// Get LP supply
public fun lp_supply<AssetType, StableType>(pool: &UnifiedSpotPool<AssetType, StableType>): u64 {
    pool.lp_supply
}

/// Get LIVE bucket reserves (will quantum-split for next proposal)
public fun get_active_quantum_lp_reserves<AssetType, StableType>(
    pool: &UnifiedSpotPool<AssetType, StableType>,
): (u64, u64) {
    (pool.asset_spot_active_quantum_lp, pool.stable_spot_active_quantum_lp)
}

/// Get LIVE bucket LP supply
public fun get_active_quantum_lp_supply<AssetType, StableType>(
    pool: &UnifiedSpotPool<AssetType, StableType>,
): u64 {
    pool.lp_spot_active_quantum_lp
}

/// Get TRANSITIONING bucket reserves (will move to WITHDRAW_ONLY when proposal ends)
public fun get_leaving_on_proposal_end_reserves<AssetType, StableType>(
    pool: &UnifiedSpotPool<AssetType, StableType>,
): (u64, u64, u64) {
    (pool.asset_spot_leave_lp_when_proposal_ends, pool.stable_spot_leave_lp_when_proposal_ends, pool.lp_spot_leave_lp_when_proposal_ends)
}

/// Get WITHDRAW_ONLY bucket reserves (frozen, ready for claiming)
public fun get_frozen_claimable_lp_reserves<AssetType, StableType>(
    pool: &UnifiedSpotPool<AssetType, StableType>,
): (u64, u64, u64) {
    (pool.asset_spot_frozen_claimable_lp, pool.stable_spot_frozen_claimable_lp, pool.lp_spot_frozen_claimable_lp)
}

/// Get spot price (asset per stable)
public fun get_spot_price<AssetType, StableType>(
    pool: &UnifiedSpotPool<AssetType, StableType>,
): u128 {
    let asset_reserve = balance::value(&pool.asset_reserve);
    let stable_reserve = balance::value(&pool.stable_reserve);

    if (asset_reserve == 0 || stable_reserve == 0) {
        return 0
    };

    (stable_reserve as u128) * PRECISION / (asset_reserve as u128)
}

/// Check if aggregator is enabled
public fun is_aggregator_enabled<AssetType, StableType>(
    pool: &UnifiedSpotPool<AssetType, StableType>,
): bool {
    pool.aggregator_config.is_some()
}

/// Check if pool has active escrow (trading proposal active)
public fun has_active_escrow<AssetType, StableType>(
    pool: &UnifiedSpotPool<AssetType, StableType>,
): bool {
    if (pool.aggregator_config.is_none()) {
        return false
    };

    let config = pool.aggregator_config.borrow();
    config.active_escrow.is_some()
}

/// Check if pool is locked for proposal (liquidity moved to conditionals)
/// This is used by oracle interface to determine whether to read from conditional vs spot
public fun is_locked_for_proposal<AssetType, StableType>(
    pool: &UnifiedSpotPool<AssetType, StableType>,
): bool {
    if (pool.aggregator_config.is_none()) {
        return false
    };

    let config = pool.aggregator_config.borrow();
    config.last_proposal_usage.is_some()
}

/// Get conditional liquidity ratio (aggregator only)
public fun get_conditional_liquidity_ratio_percent<AssetType, StableType>(
    pool: &UnifiedSpotPool<AssetType, StableType>,
): u64 {
    if (pool.aggregator_config.is_none()) {
        return 0
    };

    let config = pool.aggregator_config.borrow();
    config.conditional_liquidity_ratio_percent
}

/// Get oracle threshold (aggregator only)
public fun get_oracle_conditional_threshold_bps<AssetType, StableType>(
    pool: &UnifiedSpotPool<AssetType, StableType>,
): u64 {
    if (pool.aggregator_config.is_none()) {
        return 10000 // Default: always use spot
    };

    let config = pool.aggregator_config.borrow();
    config.oracle_conditional_threshold_bps
}


// === Quantum Liquidity Functions ===

/// Remove liquidity for quantum split with bucket tracking (doesn't burn LP tokens)
/// Used when proposal starts - liquidity moves to conditional markets
/// Removes from BOTH LIVE and TRANSITIONING buckets with explicit amounts for each
/// WITHDRAW_ONLY bucket stays in spot (frozen, ready for claiming)
public(package) fun remove_liquidity_for_quantum_split_with_buckets<AssetType, StableType>(
    pool: &mut UnifiedSpotPool<AssetType, StableType>,
    asset_live_amount: u64,
    asset_trans_amount: u64,
    stable_live_amount: u64,
    stable_trans_amount: u64,
): (Balance<AssetType>, Balance<StableType>) {
    let total_asset = asset_live_amount + asset_trans_amount;
    let total_stable = stable_live_amount + stable_trans_amount;

    assert!(total_asset > 0 && total_stable > 0, EZeroAmount);
    assert!(total_asset <= balance::value(&pool.asset_reserve), EInsufficientLiquidity);
    assert!(total_stable <= balance::value(&pool.stable_reserve), EInsufficientLiquidity);

    // Ensure we have enough in each bucket
    assert!(asset_live_amount <= pool.asset_spot_active_quantum_lp, EInsufficientLiquidity);
    assert!(asset_trans_amount <= pool.asset_spot_leave_lp_when_proposal_ends, EInsufficientLiquidity);
    assert!(stable_live_amount <= pool.stable_spot_active_quantum_lp, EInsufficientLiquidity);
    assert!(stable_trans_amount <= pool.stable_spot_leave_lp_when_proposal_ends, EInsufficientLiquidity);

    // Remove from reserves but DON'T burn LP tokens
    // LP tokens still represent value - the liquidity exists quantum-mechanically in conditional markets
    let asset_balance = balance::split(&mut pool.asset_reserve, total_asset);
    let stable_balance = balance::split(&mut pool.stable_reserve, total_stable);

    // Update bucket tracking
    pool.asset_spot_active_quantum_lp = pool.asset_spot_active_quantum_lp - asset_live_amount;
    pool.asset_spot_leave_lp_when_proposal_ends = pool.asset_spot_leave_lp_when_proposal_ends - asset_trans_amount;
    pool.stable_spot_active_quantum_lp = pool.stable_spot_active_quantum_lp - stable_live_amount;
    pool.stable_spot_leave_lp_when_proposal_ends = pool.stable_spot_leave_lp_when_proposal_ends - stable_trans_amount;
    // Note: lp_live and lp_transitioning stay same - LP tokens still exist, just liquidity is in conditionals

    // CRITICAL: Ensure remaining spot pool meets minimum liquidity requirement (k >= 1000)
    let remaining_asset = balance::value(&pool.asset_reserve);
    let remaining_stable = balance::value(&pool.stable_reserve);
    let remaining_k = (remaining_asset as u128) * (remaining_stable as u128);
    assert!(remaining_k >= (MINIMUM_LIQUIDITY as u128), EMinimumLiquidityNotMet);

    (asset_balance, stable_balance)
}

public(package) fun remove_liquidity_for_quantum_split<AssetType, StableType>(
    pool: &mut UnifiedSpotPool<AssetType, StableType>,
    asset_amount: u64,
    stable_amount: u64,
): (Balance<AssetType>, Balance<StableType>) {
    // Default behavior: remove from LIVE bucket only
    remove_liquidity_for_quantum_split_with_buckets(
        pool,
        asset_amount,
        0, // no TRANSITIONING
        stable_amount,
        0, // no TRANSITIONING
    )
}

/// Add liquidity back from quantum redeem with bucket awareness (when proposal ends)
/// Returns liquidity from conditional markets back to spot pool
/// LIVE bucket ‚Üí spot.LIVE (will quantum-split for next proposal)
/// TRANSITIONING bucket ‚Üí spot.WITHDRAW_ONLY (frozen for claiming)
public(package) fun add_liquidity_from_quantum_redeem_with_buckets<AssetType, StableType>(
    pool: &mut UnifiedSpotPool<AssetType, StableType>,
    asset: Balance<AssetType>,
    stable: Balance<StableType>,
    asset_live: u64,
    asset_transitioning: u64,
    stable_live: u64,
    stable_transitioning: u64,
) {
    let asset_amount = balance::value(&asset);
    let stable_amount = balance::value(&stable);

    // Verify bucket amounts sum to total
    assert!(asset_live + asset_transitioning == asset_amount, EInsufficientLiquidity);
    assert!(stable_live + stable_transitioning == stable_amount, EInsufficientLiquidity);

    // Add to reserves
    balance::join(&mut pool.asset_reserve, asset);
    balance::join(&mut pool.stable_reserve, stable);

    // Add LIVE bucket ‚Üí spot.LIVE (will quantum-split for next proposal)
    pool.asset_spot_active_quantum_lp = pool.asset_spot_active_quantum_lp + asset_live;
    pool.stable_spot_active_quantum_lp = pool.stable_spot_active_quantum_lp + stable_live;

    // Add TRANSITIONING bucket ‚Üí spot.WITHDRAW_ONLY (frozen for claiming!)
    // This skips spot.TRANSITIONING and goes directly to WITHDRAW_ONLY
    pool.asset_spot_frozen_claimable_lp = pool.asset_spot_frozen_claimable_lp + asset_transitioning;
    pool.stable_spot_frozen_claimable_lp = pool.stable_spot_frozen_claimable_lp + stable_transitioning;

    // Note: LP buckets (lp_live, lp_withdraw_only) don't change here
    // LP tokens existed throughout the quantum split, only reserves moved
    // The crank's transition_to_withdraw_only() handles moving lp_transitioning ‚Üí lp_withdraw_only
}

public(package) fun add_liquidity_from_quantum_redeem<AssetType, StableType>(
    pool: &mut UnifiedSpotPool<AssetType, StableType>,
    asset: Balance<AssetType>,
    stable: Balance<StableType>,
) {
    let asset_amount = balance::value(&asset);
    let stable_amount = balance::value(&stable);

    // Default behavior: add everything to LIVE bucket (old behavior)
    add_liquidity_from_quantum_redeem_with_buckets(
        pool,
        asset,
        stable,
        asset_amount,
        0, // no transitioning
        stable_amount,
        0, // no transitioning
    )
}

// === Aggregator-Specific Functions ===

const LONG_WINDOW_MS: u64 = 7_776_000_000; // 90 days

/// Mark liquidity as moving to proposal (for aggregator support)
/// Updates tracking for liquidity-weighted oracle logic
public fun mark_liquidity_to_proposal<AssetType, StableType>(
    pool: &mut UnifiedSpotPool<AssetType, StableType>,
    conditional_liquidity_ratio_percent: u64,
    clock: &Clock,
) {
    if (pool.aggregator_config.is_none()) {
        return
    };

    // Calculate spot price first (before borrowing config mutably)
    let current_price = get_spot_price(pool);

    let config = pool.aggregator_config.borrow_mut();

    // Update SimpleTWAP one last time before liquidity moves to proposal
    PCW_TWAP_oracle::update(&mut config.simple_twap, current_price, clock);

    // Record when liquidity moved to proposal (spot oracle freezes here)
    let proposal_start = clock.timestamp_ms();
    config.last_proposal_usage = option::some(proposal_start);

    // Snapshot cumulative at proposal lock for later blending/backfill
    let cumulative_at_lock = PCW_TWAP_oracle::cumulative_total(&config.simple_twap);
    config.spot_cumulative_at_lock = option::some(cumulative_at_lock);

    // Store conditional liquidity ratio for liquidity-weighted oracle logic
    config.conditional_liquidity_ratio_percent = conditional_liquidity_ratio_percent;
}

/// Check if TWAP is ready (has enough history)
public fun is_twap_ready<AssetType, StableType>(
    pool: &UnifiedSpotPool<AssetType, StableType>,
    clock: &Clock,
): bool {
    if (pool.aggregator_config.is_none()) {
        return false
    };

    let config = pool.aggregator_config.borrow();
    PCW_TWAP_oracle::is_ready(&config.simple_twap, clock)
}

/// Get governance TWAP (90-day arithmetic window)
/// Uses SimpleTWAP's long-window checkpoints for 90-day averaging
public fun get_geometric_twap<AssetType, StableType>(
    pool: &UnifiedSpotPool<AssetType, StableType>,
    clock: &Clock,
): u128 {
    assert!(pool.aggregator_config.is_some(), EAggregatorNotEnabled);
    let config = pool.aggregator_config.borrow();
    let base_twap = PCW_TWAP_oracle::get_twap(&config.simple_twap);
    let long_opt = PCW_TWAP_oracle::get_ninety_day_twap(&config.simple_twap, clock);
    unwrap_option_with_default(long_opt, base_twap)
}

/// Get current 90-day TWAP with conditional integration
/// During proposals: uses conditional TWAP when conditional liquidity dominates, otherwise spot
public fun get_twap_with_conditional<AssetType, StableType>(
    pool: &UnifiedSpotPool<AssetType, StableType>,
    winning_conditional_oracle: &SimpleTWAP,
    clock: &Clock,
): u128 {
    assert!(pool.aggregator_config.is_some(), EAggregatorNotEnabled);
    let config = pool.aggregator_config.borrow();

    let spot_base_twap = PCW_TWAP_oracle::get_twap(&config.simple_twap);
    let spot_long_opt = PCW_TWAP_oracle::get_ninety_day_twap(
        &config.simple_twap,
        clock,
    );
    let spot_long_twap = unwrap_option_with_default(spot_long_opt, spot_base_twap);

    // If no proposal is active, return spot TWAP
    if (config.last_proposal_usage.is_none()) {
        return spot_long_twap
    };

    // Only pivot to conditional if configuration says conditional market owns majority liquidity
    let threshold_percent = config.oracle_conditional_threshold_bps / 100;
    if (config.conditional_liquidity_ratio_percent < threshold_percent) {
        return spot_long_twap
    };

    // Conditional market dominates: use its long-window TWAP
    let conditional_base = PCW_TWAP_oracle::get_twap(winning_conditional_oracle);
    let conditional_opt = PCW_TWAP_oracle::get_ninety_day_twap(
        winning_conditional_oracle,
        clock,
    );
    unwrap_option_with_default(conditional_opt, conditional_base)
}

fun unwrap_option_with_default(opt: option::Option<u128>, fallback: u128): u128 {
    if (option::is_some(&opt)) {
        option::destroy_some(opt)
    } else {
        option::destroy_none(opt);
        fallback
    }
}

/// Get SimpleTWAP oracle reference for advanced integration
public fun get_simple_twap<AssetType, StableType>(
    pool: &UnifiedSpotPool<AssetType, StableType>,
): &SimpleTWAP {
    assert!(pool.aggregator_config.is_some(), EAggregatorNotEnabled);
    let config = pool.aggregator_config.borrow();
    &config.simple_twap
}

/// Get fee in basis points
public fun get_fee_bps<AssetType, StableType>(pool: &UnifiedSpotPool<AssetType, StableType>): u64 {
    pool.fee_bps
}

/// Simulate swap asset to stable (view function)
/// Uses cached fee_bps (call update_cached_fee_if_needed first for current fee)
public fun simulate_swap_asset_to_stable<AssetType, StableType>(
    pool: &UnifiedSpotPool<AssetType, StableType>,
    asset_in: u64,
): u64 {
    if (asset_in == 0) {
        return 0
    };

    let asset_reserve = balance::value(&pool.asset_reserve);
    let stable_reserve = balance::value(&pool.stable_reserve);

    if (asset_reserve == 0 || stable_reserve == 0) {
        return 0
    };

    // Use cached fee (updated by update_cached_fee_if_needed before arbitrage)
    let asset_after_fee = asset_in - (asset_in * pool.fee_bps / 10000);
    let stable_out =
        (stable_reserve as u128) * (asset_after_fee as u128) /
                     ((asset_reserve as u128) + (asset_after_fee as u128));

    if ((stable_out as u64) >= stable_reserve) {
        return 0
    };

    (stable_out as u64)
}

/// Simulate swap stable to asset (view function)
/// Uses cached fee_bps (call update_cached_fee_if_needed first for current fee)
public fun simulate_swap_stable_to_asset<AssetType, StableType>(
    pool: &UnifiedSpotPool<AssetType, StableType>,
    stable_in: u64,
): u64 {
    if (stable_in == 0) {
        return 0
    };

    let asset_reserve = balance::value(&pool.asset_reserve);
    let stable_reserve = balance::value(&pool.stable_reserve);

    if (asset_reserve == 0 || stable_reserve == 0) {
        return 0
    };

    // Use cached fee (updated by update_cached_fee_if_needed before arbitrage)
    let stable_after_fee = stable_in - (stable_in * pool.fee_bps / 10000);
    let asset_out =
        (asset_reserve as u128) * (stable_after_fee as u128) /
                    ((stable_reserve as u128) + (stable_after_fee as u128));

    if ((asset_out as u64) >= asset_reserve) {
        return 0
    };

    (asset_out as u64)
}

// === Dissolution Functions ===

/// Remove liquidity for dissolution using actual LP token object
/// bypass_minimum: If true, allows emptying below MINIMUM_LIQUIDITY
/// ‚úÖ Public so dissolution actions can call from different package
///
/// ‚ö†Ô∏è CRITICAL: Use this for dissolution instead of remove_liquidity()
/// - Burns actual LP token object (not numeric amount)
/// - Can bypass MINIMUM_LIQUIDITY check for complete emptying
/// - Disables trading by setting fee to 100% when bypassing minimum
public fun remove_liquidity_for_dissolution<AssetType, StableType>(
    pool: &mut UnifiedSpotPool<AssetType, StableType>,
    lp_token: LPToken<AssetType, StableType>,
    bypass_minimum: bool,
    ctx: &mut TxContext,
): (Coin<AssetType>, Coin<StableType>) {
    let lp_amount = lp_token.amount;
    assert!(lp_amount > 0, EZeroAmount);
    assert!(pool.lp_supply >= lp_amount, EInsufficientLPSupply);

    // CRITICAL: Check LP token state
    assert!(!lp_token.withdraw_mode, EInsufficientLiquidity);
    assert!(lp_token.locked_in_proposal.is_none(), ENoActiveProposal);

    // Calculate proportional amounts from total reserves
    let asset_reserve = balance::value(&pool.asset_reserve);
    let stable_reserve = balance::value(&pool.stable_reserve);

    let asset_out = (asset_reserve as u128) * (lp_amount as u128) / (pool.lp_supply as u128);
    let stable_out = (stable_reserve as u128) * (lp_amount as u128) / (pool.lp_supply as u128);

    // Burn LP token
    let LPToken { id, amount: _, pool_id: _, locked_in_proposal: _, withdraw_mode: _ } = lp_token;
    object::delete(id);

    // Update total supply
    pool.lp_supply = pool.lp_supply - lp_amount;

    // Update bucket tracking (remove from LIVE bucket)
    let asset_from_live = (lp_amount as u128) * (pool.asset_spot_active_quantum_lp as u128) / (pool.lp_spot_active_quantum_lp as u128);
    let stable_from_live =
        (lp_amount as u128) * (pool.stable_spot_active_quantum_lp as u128) / (pool.lp_spot_active_quantum_lp as u128);

    pool.lp_spot_active_quantum_lp = pool.lp_spot_active_quantum_lp - lp_amount;
    pool.asset_spot_active_quantum_lp = pool.asset_spot_active_quantum_lp - (asset_from_live as u64);
    pool.stable_spot_active_quantum_lp = pool.stable_spot_active_quantum_lp - (stable_from_live as u64);

    // Extract coins from reserves
    let asset_coin = coin::from_balance(
        balance::split(&mut pool.asset_reserve, (asset_out as u64)),
        ctx,
    );
    let stable_coin = coin::from_balance(
        balance::split(&mut pool.stable_reserve, (stable_out as u64)),
        ctx,
    );

    // Check minimum ONLY if bypass is false
    if (!bypass_minimum) {
        let remaining_asset = balance::value(&pool.asset_reserve);
        let remaining_stable = balance::value(&pool.stable_reserve);
        let remaining_k = (remaining_asset as u128) * (remaining_stable as u128);
        assert!(remaining_k >= (MINIMUM_LIQUIDITY as u128), EMinimumLiquidityNotMet);
    } else {
        // SHUTDOWN: Disable trading by setting fee to 100%
        pool.fee_bps = 10000;
    };

    (asset_coin, stable_coin)
}

/// Get DAO's proportional LP value without withdrawing
/// Used for calculating treasury value including AMM position
public fun get_dao_lp_value<AssetType, StableType>(
    pool: &UnifiedSpotPool<AssetType, StableType>,
    dao_owned_lp_amount: u64,
): (u64, u64) {
    let total_lp = pool.lp_supply;
    if (total_lp == 0) {
        return (0, 0)
    };

    let asset_reserve = balance::value(&pool.asset_reserve);
    let stable_reserve = balance::value(&pool.stable_reserve);

    let asset_value = (asset_reserve as u128) * (dao_owned_lp_amount as u128) / (total_lp as u128);
    let stable_value =
        (stable_reserve as u128) * (dao_owned_lp_amount as u128) / (total_lp as u128);

    ((asset_value as u64), (stable_value as u64))
}

// === Protocol Fee Management ===

/// Withdraw accumulated protocol fees in asset tokens
/// Returns the balance to be deposited into FeeManager
public(package) fun withdraw_protocol_fees_asset<AssetType, StableType>(
    pool: &mut UnifiedSpotPool<AssetType, StableType>,
): Balance<AssetType> {
    assert!(pool.aggregator_config.is_some(), EAggregatorNotEnabled);
    let config = pool.aggregator_config.borrow_mut();
    let amount = config.protocol_fees_asset.value();
    config.protocol_fees_asset.split(amount)
}

/// Withdraw accumulated protocol fees in stable tokens
/// Returns the balance to be deposited into FeeManager
public(package) fun withdraw_protocol_fees_stable<AssetType, StableType>(
    pool: &mut UnifiedSpotPool<AssetType, StableType>,
): Balance<StableType> {
    assert!(pool.aggregator_config.is_some(), EAggregatorNotEnabled);
    let config = pool.aggregator_config.borrow_mut();
    let amount = config.protocol_fees_stable.value();
    config.protocol_fees_stable.split(amount)
}

/// View function: get accumulated protocol fee amounts
public fun get_protocol_fee_amounts<AssetType, StableType>(
    pool: &UnifiedSpotPool<AssetType, StableType>,
): (u64, u64) {
    if (pool.aggregator_config.is_none()) {
        return (0, 0)
    };
    let config = pool.aggregator_config.borrow();
    (config.protocol_fees_asset.value(), config.protocol_fees_stable.value())
}

// === Sharing Function ===

/// Share the pool object (can only be called by module that defines the type)
public fun share<AssetType, StableType>(pool: UnifiedSpotPool<AssetType, StableType>) {
    transfer::public_share_object(pool);
}

// === Test Functions ===

#[test_only]
public fun new_for_testing<AssetType, StableType>(
    fee_bps: u64,
    enable_aggregator: bool,
    ctx: &mut TxContext,
): UnifiedSpotPool<AssetType, StableType> {
    use sui::clock;

    let clock = clock::create_for_testing(ctx);
    let pool = if (enable_aggregator) {
        new_with_aggregator<AssetType, StableType>(
            fee_bps,
            option::none(), // No fee schedule in tests by default
            8000,
            &clock,
            ctx
        )
    } else {
        new<AssetType, StableType>(
            fee_bps,
            option::none(), // No fee schedule in tests by default
            &clock,
            ctx
        )
    };
    clock::destroy_for_testing(clock);
    pool
}

#[test_only]
/// Create a pool with initial liquidity for testing arbitrage_math
public fun create_pool_for_testing<AssetType, StableType>(
    asset_amount: u64,
    stable_amount: u64,
    fee_bps: u64,
    ctx: &mut TxContext,
): UnifiedSpotPool<AssetType, StableType> {
    use sui::balance;
    use sui::test_utils;

    // Create balances from amounts
    let asset_balance = balance::create_for_testing<AssetType>(asset_amount);
    let stable_balance = balance::create_for_testing<StableType>(stable_amount);

    UnifiedSpotPool {
        id: object::new(ctx),
        asset_reserve: asset_balance,
        stable_reserve: stable_balance,
        lp_supply: 1000, // Default LP supply for testing
        fee_bps,
        minimum_liquidity: 1000, // Standard minimum
        fee_schedule: option::none(), // No fee schedule for testing
        fee_schedule_activation_time: 0,
        // Initialize all liquidity in active quantum LP bucket for testing
        asset_spot_active_quantum_lp: asset_amount,
        asset_spot_leave_lp_when_proposal_ends: 0,
        asset_spot_frozen_claimable_lp: 0,
        asset_spot_join_quantum_lp_when_proposal_ends: 0,
        stable_spot_active_quantum_lp: stable_amount,
        stable_spot_leave_lp_when_proposal_ends: 0,
        stable_spot_frozen_claimable_lp: 0,
        stable_spot_join_quantum_lp_when_proposal_ends: 0,
        lp_spot_active_quantum_lp: 1000,
        lp_spot_leave_lp_when_proposal_ends: 0,
        lp_spot_frozen_claimable_lp: 0,
        lp_spot_join_quantum_lp_when_proposal_ends: 0,
        aggregator_config: option::none(), // No aggregator for simple testing
    }
}

#[test_only]
/// Destroy pool for testing
public fun destroy_for_testing<AssetType, StableType>(
    pool: UnifiedSpotPool<AssetType, StableType>,
) {
    use sui::balance;
    use sui::test_utils;

    let UnifiedSpotPool {
        id,
        asset_reserve,
        stable_reserve,
        lp_supply: _,
        fee_bps: _,
        minimum_liquidity: _,
        fee_schedule: _,
        fee_schedule_activation_time: _,
        asset_spot_active_quantum_lp: _,
        asset_spot_leave_lp_when_proposal_ends: _,
        asset_spot_frozen_claimable_lp: _,
        asset_spot_join_quantum_lp_when_proposal_ends: _,
        stable_spot_active_quantum_lp: _,
        stable_spot_leave_lp_when_proposal_ends: _,
        stable_spot_frozen_claimable_lp: _,
        stable_spot_join_quantum_lp_when_proposal_ends: _,
        lp_spot_active_quantum_lp: _,
        lp_spot_leave_lp_when_proposal_ends: _,
        lp_spot_frozen_claimable_lp: _,
        lp_spot_join_quantum_lp_when_proposal_ends: _,
        aggregator_config,
    } = pool;

    object::delete(id);
    balance::destroy_for_testing(asset_reserve);
    balance::destroy_for_testing(stable_reserve);

    if (aggregator_config.is_some()) {
        let config = option::destroy_some(aggregator_config);
        let AggregatorConfig {
            active_escrow,
            simple_twap,
            last_proposal_usage: _,
            conditional_liquidity_ratio_percent: _,
            oracle_conditional_threshold_bps: _,
            spot_cumulative_at_lock: _,
            protocol_fees_asset,
            protocol_fees_stable,
        } = config;

        // Destroy active escrow ID if present (just an Option<ID>, no object to destroy)
        if (active_escrow.is_some()) {
            option::destroy_some(active_escrow);
        } else {
            option::destroy_none(active_escrow);
        };

        PCW_TWAP_oracle::destroy_for_testing(simple_twap);
        balance::destroy_for_testing(protocol_fees_asset);
        balance::destroy_for_testing(protocol_fees_stable);
    } else {
        option::destroy_none(aggregator_config);
    };
}

#[test_only]
/// Destroy LP token for testing
public fun destroy_lp_token_for_testing<AssetType, StableType>(
    lp_token: LPToken<AssetType, StableType>,
) {
    let LPToken { id, amount: _, pool_id: _, locked_in_proposal: _, withdraw_mode: _ } = lp_token;
    object::delete(id);
}

#[test_only]
/// Create LP token for testing
public fun create_lp_token_for_testing<AssetType, StableType>(
    amount: u64,
    locked_in_proposal: Option<ID>,
    withdraw_mode: bool,
    ctx: &mut TxContext,
): LPToken<AssetType, StableType> {
    LPToken {
        id: object::new(ctx),
        amount,
        pool_id: object::id_from_address(@0x0), // Dummy pool ID for testing
        locked_in_proposal,
        withdraw_mode,
    }
}

#[test_only]
/// Lock LP token in proposal for testing
public fun lock_in_proposal_for_testing<AssetType, StableType>(
    lp_token: &mut LPToken<AssetType, StableType>,
    proposal_id: ID,
) {
    lp_token.locked_in_proposal = option::some(proposal_id);
}

#[test_only]
/// Unlock LP token from proposal for testing
public fun unlock_from_proposal_for_testing<AssetType, StableType>(
    lp_token: &mut LPToken<AssetType, StableType>,
) {
    lp_token.locked_in_proposal = option::none();
}

#[test_only]
/// Test helper to directly mark amounts for withdrawal
/// Moves specified amounts from LIVE to TRANSITIONING bucket
public fun mark_for_withdrawal_for_testing<AssetType, StableType>(
    pool: &mut UnifiedSpotPool<AssetType, StableType>,
    asset_amount: u64,
    stable_amount: u64,
    lp_amount: u64,
) {
    // Ensure we have enough in LIVE bucket
    assert!(pool.asset_spot_active_quantum_lp >= asset_amount, EInsufficientLiquidity);
    assert!(pool.stable_spot_active_quantum_lp >= stable_amount, EInsufficientLiquidity);
    assert!(pool.lp_spot_active_quantum_lp >= lp_amount, EInsufficientLPSupply);

    // Move from LIVE to TRANSITIONING
    pool.asset_spot_active_quantum_lp = pool.asset_spot_active_quantum_lp - asset_amount;
    pool.asset_spot_leave_lp_when_proposal_ends = pool.asset_spot_leave_lp_when_proposal_ends + asset_amount;

    pool.stable_spot_active_quantum_lp = pool.stable_spot_active_quantum_lp - stable_amount;
    pool.stable_spot_leave_lp_when_proposal_ends = pool.stable_spot_leave_lp_when_proposal_ends + stable_amount;

    pool.lp_spot_active_quantum_lp = pool.lp_spot_active_quantum_lp - lp_amount;
    pool.lp_spot_leave_lp_when_proposal_ends = pool.lp_spot_leave_lp_when_proposal_ends + lp_amount;
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// ============================================================================
/// ARBITRAGE ENTRY POINTS - Phase 3 Implementation
/// ============================================================================
///
/// Provides aggregator-friendly interfaces and arbitrage bot entry points
/// for the deterministic arbitrage solver (arbitrage_math.move).
///
/// INTERFACES:
/// 1. get_quote() - Quote for aggregators (Aftermath, Cetus, etc.)
/// 2. simulate_arbitrage() - Profit simulation for arbitrage bots
///
/// NOTE ON SUI'S ATOMIC TRANSACTIONS:
/// - There is no MEV (front-running) on Sui due to atomic transaction execution
/// - "MEV bot" here refers to arbitrage bots that capture pricing inefficiencies
/// - All arbitrage is permissionless and happens within atomic transactions
///
/// NOTE: Actual execution requires TokenEscrow integration for:
/// - Minting/burning conditional tokens
/// - Complete set operations (split/recombine)
///
/// This module provides the MATH layer that other modules can call.
/// Full execution is handled by swap.move + coin_escrow.move.
///
/// ============================================================================

module futarchy_markets_operations::arbitrage_entry;

use futarchy_markets_core::arbitrage_math;
use futarchy_markets_core::unified_spot_pool::{Self, UnifiedSpotPool};
use futarchy_markets_primitives::conditional_amm::LiquidityPool;
use futarchy_one_shot_utils::math;

// === Structs ===

/// Quote result for aggregators
///
/// **IMPORTANT**: This quote shows the direct swap output and available arbitrage
/// opportunity, but does NOT claim the user receives the arbitrage profit.
/// The arbitrage profit is calculated on CURRENT pool state, but if user swaps first,
/// the pool state changes and the actual arbitrage profit will differ.
///
/// Use `direct_output` for accurate user output prediction.
/// Use `expected_arb_profit` to understand available arbitrage (for arbitrage bots, not users).
public struct SwapQuote has copy, drop {
    amount_in: u64,
    direct_output: u64, // Output user receives from direct swap
    optimal_arb_amount: u64, // Optimal amount to arbitrage (on current state)
    expected_arb_profit: u128, // Arbitrage profit available (on current state, not added to user output!)
    is_arb_available: bool, // Whether arbitrage opportunity exists
}

// === Aggregator Interface ===

/// Get swap quote with arbitrage opportunity analysis
/// Aggregators can use this to compare futarchy vs other DEXes
///
/// Returns SwapQuote with:
/// - Direct swap output (what user actually receives)
/// - Available arbitrage profit (for arbitrage bots, NOT added to user output)
///
/// **CRITICAL**: The arbitrage profit is calculated on CURRENT pool state.
/// If user swaps first, pool state changes, and actual arbitrage differs.
/// DO NOT add direct_output + expected_arb_profit - they are not independent!
///
/// **Usage:**
/// ```move
/// let quote = get_quote_asset_to_stable(spot, conditionals, 1000000);
/// // User receives: quote.direct_output (arbitrage profit goes to arbitrageur)
/// if (quote.is_arb_available) {
///     // Arbitrage bot can capture quote.expected_arb_profit (approximately)
/// }
/// ```
public fun get_quote_asset_to_stable<AssetType, StableType>(
    spot: &UnifiedSpotPool<AssetType, StableType>,
    conditionals: &vector<LiquidityPool>,
    amount_in: u64,
): SwapQuote {
    // 1. Calculate direct swap output (what user actually receives)
    let direct_output = unified_spot_pool::simulate_swap_asset_to_stable(spot, amount_in);

    // 2. Calculate optimal arbitrage using NEW EFFICIENT BIDIRECTIONAL SOLVER
    // ‚úÖ Uses b-parameterization (no sqrt)
    // ‚úÖ Active-set pruning (40-60% gas reduction)
    // ‚úÖ Early exit checks
    // ‚úÖ Checks both directions automatically
    let (
        optimal_arb_amount,
        expected_arb_profit,
        _is_spot_to_cond,
    ) = arbitrage_math::compute_optimal_arbitrage_for_n_outcomes(
        spot,
        conditionals,
        direct_output,
        0,
    );

    // 3. Check if arbitrage opportunity exists (for arbitrage bots, not user profit!)
    let is_arb_available = optimal_arb_amount > 0 && expected_arb_profit > 0;

    SwapQuote {
        amount_in,
        direct_output, // User receives this
        optimal_arb_amount, // Arbitrage amount (on current state)
        expected_arb_profit, // Arbitrage profit (for arbitrage bot, NOT user!)
        is_arb_available, // Whether arbitrage exists
    }
}

/// Get swap quote for stable ‚Üí asset direction
public fun get_quote_stable_to_asset<AssetType, StableType>(
    spot: &UnifiedSpotPool<AssetType, StableType>,
    conditionals: &vector<LiquidityPool>,
    amount_in: u64,
): SwapQuote {
    let direct_output = unified_spot_pool::simulate_swap_stable_to_asset(spot, amount_in);

    // Use NEW EFFICIENT BIDIRECTIONAL SOLVER (same as above)
    let (
        optimal_arb_amount,
        expected_arb_profit,
        _is_spot_to_cond,
    ) = arbitrage_math::compute_optimal_arbitrage_for_n_outcomes(
        spot,
        conditionals,
        direct_output,
        0,
    );

    let is_arb_available = optimal_arb_amount > 0 && expected_arb_profit > 0;

    SwapQuote {
        amount_in,
        direct_output, // User receives this
        optimal_arb_amount, // Arbitrage amount (on current state)
        expected_arb_profit, // Arbitrage profit (for arbitrage bot, NOT user!)
        is_arb_available, // Whether arbitrage exists
    }
}

// === Arbitrage Bot Interface ===

/// Simulate pure arbitrage with minimum profit threshold
/// Arbitrage bots can call this to check if arbitrage is profitable
///
/// Returns:
/// - optimal_amount: Optimal amount to arbitrage
/// - expected_profit: Expected profit (after min_profit check)
/// - is_spot_to_cond: Direction (true = Spot‚ÜíCond, false = Cond‚ÜíSpot)
///
/// **NEW FEATURES:**
/// ‚úÖ Bidirectional search (finds best direction automatically)
/// ‚úÖ Min profit threshold (don't execute if profit < threshold)
/// ‚úÖ 40-60% more efficient (pruning + early exits + no sqrt)
/// ‚úÖ Smart bounding (pass user_swap_output hint for 95%+ gas savings)
///
/// **Usage:**
/// ```move
/// let (amount, profit, direction) = simulate_pure_arbitrage_with_min_profit(
///     spot, conditionals, swap_output, 10000  // swap_output hint, min 10k profit
/// );
/// if (profit > 0) {
///     // Execute arbitrage PTB in the profitable direction
///     execute_arbitrage(...);
/// }
/// ```
public fun simulate_pure_arbitrage_with_min_profit<AssetType, StableType>(
    spot: &UnifiedSpotPool<AssetType, StableType>,
    conditionals: &vector<LiquidityPool>,
    user_swap_output: u64,
    min_profit: u64,
): (u64, u128, bool) {
    arbitrage_math::compute_optimal_arbitrage_for_n_outcomes(
        spot,
        conditionals,
        user_swap_output,
        min_profit,
    )
}

/// Legacy interface: Simulate arbitrage in specific direction (asset‚Üístable)
/// NOTE: New code should use simulate_pure_arbitrage_with_min_profit for bidirectional search
public fun simulate_pure_arbitrage_asset_to_stable<AssetType, StableType>(
    spot: &UnifiedSpotPool<AssetType, StableType>,
    conditionals: &vector<LiquidityPool>,
    user_swap_output: u64,
): (u64, u128) {
    let (
        amount,
        profit,
        is_spot_to_cond,
    ) = arbitrage_math::compute_optimal_arbitrage_for_n_outcomes(
        spot,
        conditionals,
        user_swap_output,
        0,
    );

    // Return only if direction matches (asset_to_stable = spot_to_cond)
    if (is_spot_to_cond) {
        (amount, profit)
    } else {
        (0, 0)
    }
}

/// Legacy interface: Simulate arbitrage in specific direction (stable‚Üíasset)
/// NOTE: New code should use simulate_pure_arbitrage_with_min_profit for bidirectional search
public fun simulate_pure_arbitrage_stable_to_asset<AssetType, StableType>(
    spot: &UnifiedSpotPool<AssetType, StableType>,
    conditionals: &vector<LiquidityPool>,
    user_swap_output: u64,
): (u64, u128) {
    let (
        amount,
        profit,
        is_spot_to_cond,
    ) = arbitrage_math::compute_optimal_arbitrage_for_n_outcomes(
        spot,
        conditionals,
        user_swap_output,
        0,
    );

    // Return only if direction matches (stable_to_asset = cond_to_spot)
    if (!is_spot_to_cond) {
        (amount, profit)
    } else {
        (0, 0)
    }
}

// === Quote Getters ===

public fun quote_amount_in(quote: &SwapQuote): u64 {
    quote.amount_in
}

public fun quote_direct_output(quote: &SwapQuote): u64 {
    quote.direct_output
}

public fun quote_optimal_arb_amount(quote: &SwapQuote): u64 {
    quote.optimal_arb_amount
}

public fun quote_expected_arb_profit(quote: &SwapQuote): u128 {
    quote.expected_arb_profit
}

public fun quote_is_arb_available(quote: &SwapQuote): bool {
    quote.is_arb_available
}

/// Get arbitrage profit in basis points relative to direct output
/// Returns 0 if no arbitrage available
/// NOTE: This is the arbitrage bot's potential profit, NOT added to user output!
///
/// BUG FIX: Use mul_div to prevent u128 overflow on (expected_arb_profit * 10000)
public fun quote_arb_profit_bps(quote: &SwapQuote): u64 {
    if (quote.is_arb_available && quote.direct_output > 0) {
        // BPS = (arb_profit / direct_output) * 10000
        // Use mul_div_mixed (accepts u128, u64, u128) to prevent overflow
        let bps = math::mul_div_mixed(
            quote.expected_arb_profit,
            10000,
            quote.direct_output as u128,
        );
        (bps as u64)
    } else {
        0
    }
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// User-facing swap API with auto-arbitrage
///
/// This is where users enter the system. Provides entry functions that:
/// - Execute user swaps
/// - Automatically run arbitrage with the output
/// - Return combined results to maximize value
///
/// Based on Solana futarchy pattern: user swap ‚Üí auto arb with output ‚Üí return combined result
///
/// **Incomplete Set Handling:**
/// All spot swaps transfer incomplete sets (ConditionalMarketBalance) directly to recipient.
/// Balance object has Display metadata so shows as basic NFT in wallets.
/// User owns the balance immediately and can redeem after proposal resolves.
/// No wrapper, no shared registry, no crankers - users control their own positions.
///
/// **Entry Functions:**
///
/// **Spot swaps (aggregators/DCA compatible):**
/// 1. swap_spot_stable_to_asset - Returns profit coins + balance object to recipient
/// 2. swap_spot_asset_to_stable - Returns profit coins + balance object to recipient
///
/// Output coins and balance objects transferred directly to recipient (shows as NFT in wallet).
/// Supports DCA bots calling on behalf of users.

module futarchy_markets_operations::swap_entry;

use futarchy_markets_core::arbitrage;
use futarchy_markets_core::proposal::{Self, Proposal};
use futarchy_markets_core::swap_core;
use futarchy_markets_core::unified_spot_pool::{Self, UnifiedSpotPool};
use futarchy_markets_operations::no_arb_guard;
use futarchy_markets_primitives::coin_escrow::{Self, TokenEscrow};
use futarchy_markets_primitives::conditional_balance::{Self, ConditionalMarketBalance};
use futarchy_markets_primitives::market_state;
use std::option;
use sui::clock::Clock;
use sui::coin::{Self, Coin};
use sui::object;
use sui::transfer;

// === Errors ===
const EZeroAmount: u64 = 0;
const EProposalNotLive: u64 = 1;

// === Constants ===
const STATE_TRADING: u8 = 2; // Must match proposal.move

// === Spot Swaps with Auto-Arb ===

/// Swap stable ‚Üí asset in spot market with automatic arbitrage
///
/// **DCA BOT & AGGREGATOR COMPATIBLE** - Supports auto-merge and flexible return modes
///
/// # Arguments
/// * `existing_balance_opt` - Optional balance to merge into (DCA bots: pass previous balance)
/// * `return_balance` - If true: return balance to caller. If false: transfer to recipient
///
/// # Returns
/// * `Coin<AssetType>` - Profit in asset
/// * `option::Option<ConditionalMarketBalance>` - Dust balance (Some if return_balance=true, None otherwise)
///
/// # Use Cases
///
/// **Regular User (one swap):**
/// ```typescript
/// tx.moveCall({
///   arguments: [..., recipient, null, false, ...] // Transfer balance to recipient
/// });
/// ```
///
/// **DCA Bot (100 swaps ‚Üí 1 NFT):**
/// ```typescript
/// let balance = null;
/// for (let i = 0; i < 100; i++) {
///   const [assetOut, balanceOpt] = tx.moveCall({
///     arguments: [..., botAddress, balance, true, ...] // Return balance to accumulate
///   });
///   balance = balanceOpt;
/// }
/// tx.transferObjects([balance], user); // Final: 1 NFT with all dust!
/// ```
public fun swap_spot_stable_to_asset<AssetType, StableType>(
    spot_pool: &mut UnifiedSpotPool<AssetType, StableType>,
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    stable_in: Coin<StableType>,
    min_asset_out: u64,
    recipient: address,
    mut existing_balance_opt: option::Option<ConditionalMarketBalance<AssetType, StableType>>,
    return_balance: bool,
    clock: &Clock,
    ctx: &mut TxContext,
): (Coin<AssetType>, option::Option<ConditionalMarketBalance<AssetType, StableType>>) {
    let amount_in = stable_in.value();
    assert!(amount_in > 0, EZeroAmount);

    // Step 1: Normal swap in spot (user pays fees)
    let asset_out = unified_spot_pool::swap_stable_for_asset(
        spot_pool,
        stable_in,
        min_asset_out,
        clock,
        ctx,
    );

    // Step 2: Auto-arb if proposal is live (uses swap output as budget)
    let proposal_state = proposal::state(proposal);

    if (proposal_state == STATE_TRADING) {
        // Begin swap session for conditional swaps
        let session = swap_core::begin_swap_session(escrow);

        // Execute optimal arb bidirectionally with auto-merge support
        let (
            stable_profit,
            mut asset_with_profit,
            final_balance,
        ) = arbitrage::execute_optimal_spot_arbitrage<AssetType, StableType>(
            spot_pool,
            escrow,
            &session,
            coin::zero<StableType>(ctx), // Don't have stable
            asset_out, // Have asset from swap
            0, // min_profit_threshold (any profit is good)
            recipient, // Who owns dust and receives complete sets
            existing_balance_opt, // Pass existing balance for auto-merge
            clock,
            ctx,
        );

        // Finalize swap session
        swap_core::finalize_swap_session(session, escrow);

        // Ensure no-arb band is respected after auto-arb
        let market_state = coin_escrow::get_market_state(escrow);
        let pools = market_state::borrow_amm_pools(market_state);
        no_arb_guard::ensure_spot_in_band(spot_pool, pools);

        // If we got stable profit (arb was more profitable in opposite direction),
        // swap it to asset to give user maximum value in their desired token
        if (stable_profit.value() > 0) {
            let extra_asset = unified_spot_pool::swap_stable_for_asset(
                spot_pool,
                stable_profit,
                0, // Accept any amount (already profitable from arb)
                clock,
                ctx,
            );
            coin::join(&mut asset_with_profit, extra_asset);
        } else {
            coin::destroy_zero(stable_profit);
        };

        // Handle balance based on return_balance flag
        if (return_balance) {
            // DCA bot mode: Return balance to caller for accumulation
            (asset_with_profit, option::some(final_balance))
        } else {
            // Regular user mode: Transfer balance to recipient
            transfer::public_transfer(final_balance, recipient);
            transfer::public_transfer(asset_with_profit, recipient);
            (coin::zero<AssetType>(ctx), option::none())
        }
    } else {
        // No arb (proposal not trading) - just handle swap output and existing balance
        if (return_balance) {
            // Return coins and existing balance (if any) to caller
            (asset_out, existing_balance_opt)
        } else {
            // Transfer everything to recipient
            transfer::public_transfer(asset_out, recipient);
            if (option::is_some(&existing_balance_opt)) {
                transfer::public_transfer(option::extract(&mut existing_balance_opt), recipient);
            };
            option::destroy_none(existing_balance_opt);
            (coin::zero<AssetType>(ctx), option::none())
        }
    }
}

/// Swap asset ‚Üí stable in spot market with automatic arbitrage
///
/// **DCA BOT & AGGREGATOR COMPATIBLE** - Supports auto-merge and flexible return modes
///
/// # Arguments
/// * `existing_balance_opt` - Optional balance to merge into (DCA bots: pass previous balance)
/// * `return_balance` - If true: return balance to caller. If false: transfer to recipient
///
/// # Returns
/// * `Coin<StableType>` - Profit in stable
/// * `option::Option<ConditionalMarketBalance>` - Dust balance (Some if return_balance=true, None otherwise)
///
/// # Use Cases
///
/// **Regular User (one swap):**
/// ```typescript
/// tx.moveCall({
///   arguments: [..., recipient, null, false, ...] // Transfer balance to recipient
/// });
/// ```
///
/// **DCA Bot (100 swaps ‚Üí 1 NFT):**
/// ```typescript
/// let balance = null;
/// for (let i = 0; i < 100; i++) {
///   const [stableOut, balanceOpt] = tx.moveCall({
///     arguments: [..., botAddress, balance, true, ...] // Return balance to accumulate
///   });
///   balance = balanceOpt;
/// }
/// tx.transferObjects([balance], user); // Final: 1 NFT with all dust!
/// ```
public fun swap_spot_asset_to_stable<AssetType, StableType>(
    spot_pool: &mut UnifiedSpotPool<AssetType, StableType>,
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    asset_in: Coin<AssetType>,
    min_stable_out: u64,
    recipient: address,
    mut existing_balance_opt: option::Option<ConditionalMarketBalance<AssetType, StableType>>,
    return_balance: bool,
    clock: &Clock,
    ctx: &mut TxContext,
): (Coin<StableType>, option::Option<ConditionalMarketBalance<AssetType, StableType>>) {
    let amount_in = asset_in.value();
    assert!(amount_in > 0, EZeroAmount);

    // Step 1: Normal swap in spot (user pays fees)
    let stable_out = unified_spot_pool::swap_asset_for_stable(
        spot_pool,
        asset_in,
        min_stable_out,
        clock,
        ctx,
    );

    // Step 2: Auto-arb if proposal is live
    let proposal_state = proposal::state(proposal);

    if (proposal_state == STATE_TRADING) {
        let session = swap_core::begin_swap_session(escrow);

        // Execute optimal arb bidirectionally with auto-merge support
        let (
            mut stable_with_profit,
            asset_profit,
            final_balance,
        ) = arbitrage::execute_optimal_spot_arbitrage<AssetType, StableType>(
            spot_pool,
            escrow,
            &session,
            stable_out, // Have stable from swap
            coin::zero<AssetType>(ctx), // Don't have asset
            0, // min_profit_threshold
            recipient, // Who owns dust
            existing_balance_opt, // Pass existing balance for auto-merge
            clock,
            ctx,
        );

        swap_core::finalize_swap_session(session, escrow);

        // Ensure no-arb band is respected after auto-arb
        let market_state = coin_escrow::get_market_state(escrow);
        let pools = market_state::borrow_amm_pools(market_state);
        no_arb_guard::ensure_spot_in_band(spot_pool, pools);

        // If we got asset profit (arb was more profitable in opposite direction),
        // swap it to stable to give user maximum value in their desired token
        if (asset_profit.value() > 0) {
            let extra_stable = unified_spot_pool::swap_asset_for_stable(
                spot_pool,
                asset_profit,
                0, // Accept any amount (already profitable from arb)
                clock,
                ctx,
            );
            coin::join(&mut stable_with_profit, extra_stable);
        } else {
            coin::destroy_zero(asset_profit);
        };

        // Handle balance based on return_balance flag
        if (return_balance) {
            // DCA bot mode: Return balance to caller for accumulation
            (stable_with_profit, option::some(final_balance))
        } else {
            // Regular user mode: Transfer balance to recipient
            transfer::public_transfer(final_balance, recipient);
            transfer::public_transfer(stable_with_profit, recipient);
            (coin::zero<StableType>(ctx), option::none())
        }
    } else {
        // No arb (proposal not trading) - just handle swap output and existing balance
        if (return_balance) {
            // Return coins and existing balance (if any) to caller
            (stable_out, existing_balance_opt)
        } else {
            // Transfer everything to recipient
            transfer::public_transfer(stable_out, recipient);
            if (option::is_some(&existing_balance_opt)) {
                transfer::public_transfer(option::extract(&mut existing_balance_opt), recipient);
            };
            option::destroy_none(existing_balance_opt);
            (coin::zero<StableType>(ctx), option::none())
        }
    }
}

// === CONDITIONAL SWAP BATCHING ===
//
// PTB-based conditional swap batching for advanced traders.
// Allows chaining multiple conditional swaps, then settling at the end.
//
// Hot potato pattern ensures complete set closure.
//
// Flow:
// 1. begin_conditional_swaps() ‚Üí creates ConditionalSwapBatch hot potato
// 2. swap_in_batch() √ó N ‚Üí accumulates swaps in balance (chainable)
// 3. finalize_conditional_swaps() ‚Üí closes complete sets, returns profit + incomplete set balance
//
// ============================================================================

/// Hot potato for batching conditional swaps in PTB
/// NO abilities = MUST be consumed in same transaction
///
/// This forces users to call finalize_conditional_swaps() at end of PTB,
/// which closes complete sets and returns profit. Cannot store between transactions.
public struct ConditionalSwapBatch<phantom AssetType, phantom StableType> {
    balance: ConditionalMarketBalance<AssetType, StableType>,
    market_id: ID,
}

/// Step 1: Begin a conditional swap batch (returns hot potato)
///
/// Creates hot potato with empty balance. Must be consumed by finalize_conditional_swaps().
///
/// # Example PTB Flow
/// ```typescript
/// const batch = tx.moveCall({
///   target: '${PKG}::swap_entry::begin_conditional_swaps',
///   typeArguments: [AssetType, StableType],
///   arguments: [escrow]
/// });
///
/// // Chain swaps...
/// const batch2 = tx.moveCall({
///   target: '${PKG}::swap_entry::swap_in_batch',
///   arguments: [batch, session, escrow, ...] // Returns modified hot potato
/// });
///
/// // Must finalize at end
/// tx.moveCall({
///   target: '${PKG}::swap_entry::finalize_conditional_swaps',
///   arguments: [batch2, ...]
/// });
/// ```
public fun begin_conditional_swaps<AssetType, StableType>(
    escrow: &TokenEscrow<AssetType, StableType>,
    ctx: &mut TxContext,
): ConditionalSwapBatch<AssetType, StableType> {
    // Get market info
    let market_state = coin_escrow::get_market_state(escrow);
    market_state::assert_trading_active(market_state);

    let market_id = market_state::market_id(market_state);
    let outcome_count = market_state::outcome_count(market_state);

    // Create empty balance
    let balance = conditional_balance::new<AssetType, StableType>(
        market_id,
        (outcome_count as u8),
        ctx,
    );

    // Return hot potato (NO abilities = must consume)
    ConditionalSwapBatch {
        balance,
        market_id,
    }
}

/// Step 2: Swap in batch (consumes and returns hot potato)
///
/// Wraps coin ‚Üí swaps in balance ‚Üí unwraps to coin ‚Üí returns modified hot potato
///
/// Can be called N times in a PTB to chain swaps across multiple outcomes.
/// Each call mutates the balance in the hot potato and returns it for next call.
///
/// # Arguments
/// * `batch` - Hot potato from begin_conditional_swaps or previous swap_in_batch
/// * `session` - SwapSession hot potato (from swap_core::begin_swap_session)
/// * `outcome_index` - Which outcome to swap in (0, 1, 2, ...)
/// * `coin_in` - Input coin (conditional asset or stable)
/// * `is_asset_to_stable` - true = swap asset‚Üístable, false = swap stable‚Üíasset
/// * `min_amount_out` - Minimum output amount (slippage protection)
///
/// # Returns
/// Modified hot potato (pass to next swap_in_batch or finalize_conditional_swaps)
///
/// # Type Parameters
/// * `InputCoin` - Type of input conditional coin
/// * `OutputCoin` - Type of output conditional coin
///
/// # Example
/// ```typescript
/// // Swap in outcome 0: stable ‚Üí asset
/// let batch = tx.moveCall({
///   target: '${PKG}::swap_entry::swap_in_batch',
///   typeArguments: [AssetType, StableType, Cond0Stable, Cond0Asset],
///   arguments: [batch, session, escrow, 0, stableCoin, false, minOut, clock]
/// });
///
/// // Swap in outcome 1: asset ‚Üí stable
/// batch = tx.moveCall({
///   target: '${PKG}::swap_entry::swap_in_batch',
///   typeArguments: [AssetType, StableType, Cond1Asset, Cond1Stable],
///   arguments: [batch, session, escrow, 1, assetCoin, true, minOut, clock]
/// });
/// ```
public fun swap_in_batch<AssetType, StableType, InputCoin, OutputCoin>(
    mut batch: ConditionalSwapBatch<AssetType, StableType>,
    session: &swap_core::SwapSession,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_index: u8,
    coin_in: Coin<InputCoin>,
    is_asset_to_stable: bool,
    min_amount_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): (ConditionalSwapBatch<AssetType, StableType>, Coin<OutputCoin>) {
    let amount_in = coin_in.value();
    assert!(amount_in > 0, EZeroAmount);

    // Validate market still active
    let market_state = coin_escrow::get_market_state(escrow);
    market_state::assert_trading_active(market_state);

    // Wrap coin ‚Üí balance
    conditional_balance::wrap_coin<AssetType, StableType, InputCoin>(
        &mut batch.balance,
        escrow,
        coin_in,
        outcome_index,
        !is_asset_to_stable, // is_asset = opposite of swap direction
    );

    // Swap in balance (balance-based swap works for ANY outcome count!)
    let amount_out = if (is_asset_to_stable) {
        swap_core::swap_balance_asset_to_stable<AssetType, StableType>(
            session,
            escrow,
            &mut batch.balance,
            outcome_index,
            amount_in,
            min_amount_out,
            clock,
            ctx,
        )
    } else {
        swap_core::swap_balance_stable_to_asset<AssetType, StableType>(
            session,
            escrow,
            &mut batch.balance,
            outcome_index,
            amount_in,
            min_amount_out,
            clock,
            ctx,
        )
    };

    // Unwrap balance ‚Üí coin
    let coin_out = conditional_balance::unwrap_to_coin<AssetType, StableType, OutputCoin>(
        &mut batch.balance,
        escrow,
        outcome_index,
        is_asset_to_stable, // is_asset = swap direction
        ctx,
    );

    // Return modified hot potato and output coin
    (batch, coin_out)
}

/// Step 3: Finalize conditional swaps (consumes hot potato)
///
/// Closes complete sets from accumulated balance, withdraws spot coins as profit,
/// and transfers to recipient. Returns remaining incomplete set as ConditionalMarketBalance
/// for professional traders to manage their own positions.
///
/// This MUST be called at end of PTB to consume hot potato.
///
/// # Arguments
/// * `batch` - Hot potato from swap_in_batch (final state)
/// * `spot_pool` - Spot pool (for no-arb guard, NOT for swapping)
/// * `proposal` - Proposal object
/// * `escrow` - Token escrow
/// * `session` - SwapSession hot potato (consumed here)
/// * `recipient` - Who receives profit and incomplete set
/// * `clock` - Clock object
///
/// # Flow
/// 1. Find minimum balance across outcomes (complete set limit)
/// 2. Burn complete sets ‚Üí withdraw spot coins
/// 3. Transfer profit to recipient
/// 4. Transfer incomplete set balance to recipient (for pro traders to manage)
/// 5. Finalize session (updates early resolve metrics ONCE)
///
/// # Example PTB
/// ```typescript
/// tx.moveCall({
///   target: '${PKG}::swap_entry::finalize_conditional_swaps',
///   typeArguments: [AssetType, StableType],
///   arguments: [batch, spot_pool, proposal, escrow, session, recipient, clock]
/// });
/// ```
public fun finalize_conditional_swaps<AssetType, StableType>(
    batch: ConditionalSwapBatch<AssetType, StableType>,
    spot_pool: &mut UnifiedSpotPool<AssetType, StableType>,
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    session: swap_core::SwapSession,
    recipient: address,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Destructure hot potato
    let ConditionalSwapBatch { mut balance, market_id: _ } = batch;

    // Find minimum balances (complete set limits)
    let min_asset = conditional_balance::find_min_balance(&balance, true);
    let min_stable = conditional_balance::find_min_balance(&balance, false);

    // Burn complete sets and withdraw spot coins
    let spot_asset = if (min_asset > 0) {
        arbitrage::burn_complete_set_and_withdraw_asset<AssetType, StableType>(
            &mut balance,
            escrow,
            min_asset,
            ctx,
        )
    } else {
        coin::zero<AssetType>(ctx)
    };

    let spot_stable = if (min_stable > 0) {
        arbitrage::burn_complete_set_and_withdraw_stable<AssetType, StableType>(
            &mut balance,
            escrow,
            min_stable,
            ctx,
        )
    } else {
        coin::zero<StableType>(ctx)
    };

    // Finalize session
    swap_core::finalize_swap_session(session, escrow);

    // Ensure no-arb band is respected after batch swaps
    let market_state = coin_escrow::get_market_state(escrow);
    let pools = market_state::borrow_amm_pools(market_state);
    no_arb_guard::ensure_spot_in_band(spot_pool, pools);

    // Transfer spot profit to recipient
    if (spot_asset.value() > 0) {
        transfer::public_transfer(spot_asset, recipient);
    } else {
        coin::destroy_zero(spot_asset);
    };

    if (spot_stable.value() > 0) {
        transfer::public_transfer(spot_stable, recipient);
    } else {
        coin::destroy_zero(spot_stable);
    };

    // Transfer incomplete set balance to recipient (for pro traders to manage)
    // They can choose to:
    // - Hold and wait for proposal resolution
    // - Rebalance positions across outcomes
    // - Sell to market makers
    // - Store in registry themselves if desired
    transfer::public_transfer(balance, recipient);
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

module futarchy_markets_operations::spot_conditional_quoter;

use futarchy_markets_core::proposal::{Self, Proposal};
use futarchy_markets_core::unified_spot_pool::{Self, UnifiedSpotPool};
use futarchy_markets_primitives::coin_escrow::TokenEscrow;
use futarchy_markets_primitives::conditional_amm::{Self, LiquidityPool};
use futarchy_markets_primitives::market_state::MarketState;
use std::option::{Self, Option};
use sui::clock::Clock;

// === Introduction ===
// This module provides quote functionality for spot token swaps through conditional AMMs.
// It simulates the routing process to provide accurate quotes without executing trades.
//
// Key features:
// - Provides accurate quotes for spot-to-spot swaps through conditional AMMs
// - Accounts for complete set minting/redemption costs
// - Simulates the full routing path without state changes
// - Returns both output amounts and price impact information

// === Errors ===
const EInvalidOutcome: u64 = 0;
const EZeroAmount: u64 = 1;
const EMarketNotActive: u64 = 2;
const EInsufficientLiquidity: u64 = 3;

// === Structs ===

/// Quote result for a spot swap
public struct SpotQuote has copy, drop {
    /// The expected output amount
    amount_out: u64,
    /// The effective price (amount_out / amount_in scaled by 1e12)
    effective_price: u64,
    /// The price impact percentage (scaled by 1e4, so 100 = 1%)
    price_impact_bps: u64,
    /// The outcome being traded through
    outcome: u64,
    /// Whether this is asset->stable (true) or stable->asset (false)
    is_asset_to_stable: bool,
}

/// Detailed quote with breakdown
public struct DetailedSpotQuote has copy, drop {
    /// Basic quote information
    quote: SpotQuote,
    /// Amount of conditional tokens created
    conditional_tokens_created: u64,
    /// Amount of conditional tokens that would be returned as excess
    excess_conditional_tokens: u64,
    /// The spot price before the trade
    spot_price_before: u64,
    /// The spot price after the trade
    spot_price_after: u64,
}

// === Public View Functions ===

/// Get a quote for swapping spot asset to spot stable through a specific outcome
public fun quote_spot_asset_to_stable<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    amount_in: u64,
    clock: &Clock,
): SpotQuote {
    // Validate inputs
    assert!(amount_in > 0, EZeroAmount);
    assert!(outcome_idx < proposal.outcome_count(), EInvalidOutcome);

    // Verify market is active
    let market_state = escrow.get_market_state();
    assert!(market_state.is_trading_active(), EMarketNotActive);

    // Step 1: Complete set minting creates amount_in of each conditional token
    let conditional_asset_amount = amount_in;

    // Step 2: Get the AMM for this outcome
    let amm = proposal.get_pool_by_outcome(escrow, (outcome_idx as u8));

    // Step 3: Calculate swap output for asset -> stable
    let stable_out = conditional_amm::quote_swap_asset_to_stable(
        amm,
        conditional_asset_amount,
    );

    // Step 4: Complete set redemption would give us stable_out spot tokens
    // (other outcomes would have excess conditional tokens returned)

    // Calculate effective price (scaled by 1e12 for precision)
    let effective_price = if (amount_in > 0) {
        (stable_out as u128) * 1_000_000_000_000 / (amount_in as u128)
    } else {
        0
    };

    // Calculate price impact
    let (asset_reserve, stable_reserve) = conditional_amm::get_reserves(amm);
    let spot_price_before = if (asset_reserve > 0) {
        (stable_reserve as u128) * 1_000_000_000_000 / (asset_reserve as u128)
    } else {
        0
    };

    let price_impact_bps = calculate_price_impact(
        spot_price_before as u64,
        effective_price as u64,
    );

    SpotQuote {
        amount_out: stable_out,
        effective_price: effective_price as u64,
        price_impact_bps,
        outcome: outcome_idx,
        is_asset_to_stable: true,
    }
}

/// Get a quote for swapping spot stable to spot asset through a specific outcome
public fun quote_spot_stable_to_asset<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    amount_in: u64,
    clock: &Clock,
): SpotQuote {
    // Validate inputs
    assert!(amount_in > 0, EZeroAmount);
    assert!(outcome_idx < proposal.outcome_count(), EInvalidOutcome);

    // Verify market is active
    let market_state = escrow.get_market_state();
    assert!(market_state.is_trading_active(), EMarketNotActive);

    // Step 1: Complete set minting creates amount_in of each conditional token
    let conditional_stable_amount = amount_in;

    // Step 2: Get the AMM for this outcome
    let amm = proposal.get_pool_by_outcome(escrow, (outcome_idx as u8));

    // Step 3: Calculate swap output for stable -> asset
    let asset_out = conditional_amm::quote_swap_stable_to_asset(
        amm,
        conditional_stable_amount,
    );

    // Step 4: Complete set redemption would give us asset_out spot tokens

    // Calculate effective price (scaled by 1e12 for precision)
    let effective_price = if (amount_in > 0) {
        (asset_out as u128) * 1_000_000_000_000 / (amount_in as u128)
    } else {
        0
    };

    // Calculate price impact
    let (asset_reserve, stable_reserve) = conditional_amm::get_reserves(amm);
    let spot_price_before = if (stable_reserve > 0) {
        (asset_reserve as u128) * 1_000_000_000_000 / (stable_reserve as u128)
    } else {
        0
    };

    let price_impact_bps = calculate_price_impact(
        spot_price_before as u64,
        effective_price as u64,
    );

    SpotQuote {
        amount_out: asset_out,
        effective_price: effective_price as u64,
        price_impact_bps,
        outcome: outcome_idx,
        is_asset_to_stable: false,
    }
}

/// Get a detailed quote with additional information
public fun quote_spot_asset_to_stable_detailed<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    amount_in: u64,
    clock: &Clock,
): DetailedSpotQuote {
    // Get basic quote
    let quote = quote_spot_asset_to_stable(
        proposal,
        escrow,
        outcome_idx,
        amount_in,
        clock,
    );

    // Get AMM for detailed calculations
    let amm = proposal.get_pool_by_outcome(escrow, (outcome_idx as u8));
    let (asset_reserve_before, stable_reserve_before) = conditional_amm::get_reserves(amm);

    // Calculate reserves after trade
    let asset_reserve_after = asset_reserve_before + amount_in;
    let stable_reserve_after = stable_reserve_before - quote.amount_out;

    // Calculate spot prices
    let spot_price_before = if (asset_reserve_before > 0) {
        (stable_reserve_before as u128) * 1_000_000_000_000 / (asset_reserve_before as u128)
    } else {
        0
    };

    let spot_price_after = if (asset_reserve_after > 0) {
        (stable_reserve_after as u128) * 1_000_000_000_000 / (asset_reserve_after as u128)
    } else {
        0
    };

    // Calculate excess tokens (all non-traded outcomes)
    let outcome_count = proposal.outcome_count();
    let excess_conditional_tokens = (outcome_count - 1) * amount_in;

    DetailedSpotQuote {
        quote,
        conditional_tokens_created: outcome_count * amount_in,
        excess_conditional_tokens,
        spot_price_before: spot_price_before as u64,
        spot_price_after: spot_price_after as u64,
    }
}

/// Get a detailed quote for stable to asset swap
public fun quote_spot_stable_to_asset_detailed<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    amount_in: u64,
    clock: &Clock,
): DetailedSpotQuote {
    // Get basic quote
    let quote = quote_spot_stable_to_asset(
        proposal,
        escrow,
        outcome_idx,
        amount_in,
        clock,
    );

    // Get AMM for detailed calculations
    let amm = proposal.get_pool_by_outcome(escrow, (outcome_idx as u8));
    let (asset_reserve_before, stable_reserve_before) = conditional_amm::get_reserves(amm);

    // Calculate reserves after trade
    let stable_reserve_after = stable_reserve_before + amount_in;
    let asset_reserve_after = asset_reserve_before - quote.amount_out;

    // Calculate spot prices
    let spot_price_before = if (stable_reserve_before > 0) {
        (asset_reserve_before as u128) * 1_000_000_000_000 / (stable_reserve_before as u128)
    } else {
        0
    };

    let spot_price_after = if (stable_reserve_after > 0) {
        (asset_reserve_after as u128) * 1_000_000_000_000 / (stable_reserve_after as u128)
    } else {
        0
    };

    // Calculate excess tokens
    let outcome_count = proposal.outcome_count();
    let excess_conditional_tokens = (outcome_count - 1) * amount_in;

    DetailedSpotQuote {
        quote,
        conditional_tokens_created: outcome_count * amount_in,
        excess_conditional_tokens,
        spot_price_before: spot_price_before as u64,
        spot_price_after: spot_price_after as u64,
    }
}

/// Find the best outcome to route a spot asset to stable swap through
public fun find_best_asset_to_stable_route<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
    amount_in: u64,
    clock: &Clock,
): (u64, SpotQuote) {
    assert!(amount_in > 0, EZeroAmount);

    let outcome_count = proposal.outcome_count();
    assert!(outcome_count > 0, EInvalidOutcome);

    let mut best_outcome = 0;
    let mut best_quote = quote_spot_asset_to_stable(
        proposal,
        escrow,
        0,
        amount_in,
        clock,
    );

    let mut i = 1;
    while (i < outcome_count) {
        let quote = quote_spot_asset_to_stable(
            proposal,
            escrow,
            i,
            amount_in,
            clock,
        );

        if (quote.amount_out > best_quote.amount_out) {
            best_outcome = i;
            best_quote = quote;
        };

        i = i + 1;
    };

    (best_outcome, best_quote)
}

/// Find the best outcome to route a spot stable to asset swap through
public fun find_best_stable_to_asset_route<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
    amount_in: u64,
    clock: &Clock,
): (u64, SpotQuote) {
    assert!(amount_in > 0, EZeroAmount);

    let outcome_count = proposal.outcome_count();
    assert!(outcome_count > 0, EInvalidOutcome);

    let mut best_outcome = 0;
    let mut best_quote = quote_spot_stable_to_asset(
        proposal,
        escrow,
        0,
        amount_in,
        clock,
    );

    let mut i = 1;
    while (i < outcome_count) {
        let quote = quote_spot_stable_to_asset(
            proposal,
            escrow,
            i,
            amount_in,
            clock,
        );

        if (quote.amount_out > best_quote.amount_out) {
            best_outcome = i;
            best_quote = quote;
        };

        i = i + 1;
    };

    (best_outcome, best_quote)
}

// === Helper Functions ===

/// Calculate price impact in basis points
fun calculate_price_impact(price_before: u64, effective_price: u64): u64 {
    if (price_before == 0) {
        return 0
    };

    let diff = if (effective_price > price_before) {
        effective_price - price_before
    } else {
        price_before - effective_price
    };

    // Calculate impact as basis points (1 bp = 0.01%)
    let impact = (diff as u128) * 10000 / (price_before as u128);
    impact as u64
}

// === Accessor Functions ===

public fun get_amount_out(quote: &SpotQuote): u64 {
    quote.amount_out
}

public fun get_effective_price(quote: &SpotQuote): u64 {
    quote.effective_price
}

public fun get_price_impact_bps(quote: &SpotQuote): u64 {
    quote.price_impact_bps
}

public fun get_outcome(quote: &SpotQuote): u64 {
    quote.outcome
}

public fun is_asset_to_stable(quote: &SpotQuote): bool {
    quote.is_asset_to_stable
}

public fun get_conditional_tokens_created(detailed: &DetailedSpotQuote): u64 {
    detailed.conditional_tokens_created
}

public fun get_excess_conditional_tokens(detailed: &DetailedSpotQuote): u64 {
    detailed.excess_conditional_tokens
}

public fun get_spot_price_before(detailed: &DetailedSpotQuote): u64 {
    detailed.spot_price_before
}

public fun get_spot_price_after(detailed: &DetailedSpotQuote): u64 {
    detailed.spot_price_after
}

// === Oracle Price Functions ===

/// Get combined oracle price from spot AMM
/// Returns the spot AMM current price
public fun get_combined_oracle_price<AssetType, StableType>(
    spot_pool: &UnifiedSpotPool<AssetType, StableType>,
    _clock: &Clock,
): u128 {
    // Return the spot AMM current price
    unified_spot_pool::get_spot_price(spot_pool)
}

/// Check if a price meets a threshold condition
public fun check_price_threshold(price: u128, threshold: u128, is_above_threshold: bool): bool {
    if (is_above_threshold) {
        price >= threshold
    } else {
        price <= threshold
    }
}

/// Check if proposals can be created based on TWAP readiness
public fun can_create_proposal<AssetType, StableType>(
    spot_pool: &UnifiedSpotPool<AssetType, StableType>,
    clock: &Clock,
): bool {
    unified_spot_pool::is_twap_ready(spot_pool, clock)
}

/// Get time until proposals are allowed (returns 0 if ready)
public fun time_until_proposals_allowed<AssetType, StableType>(
    spot_pool: &UnifiedSpotPool<AssetType, StableType>,
    clock: &Clock,
): u64 {
    // Check if TWAP is ready
    if (unified_spot_pool::is_twap_ready(spot_pool, clock)) {
        return 0
    };

    // Calculate remaining time (simplified - assumes 3 days needed)
    259_200_000 // Return 3 days in ms as placeholder
}

/// Get initialization price for conditional AMMs
/// Uses current spot price for immediate market initialization
public fun get_initialization_price<AssetType, StableType>(
    spot_pool: &UnifiedSpotPool<AssetType, StableType>,
    _clock: &Clock,
): u128 {
    unified_spot_pool::get_spot_price(spot_pool)
}

// === Test-Only Functions ===

#[test_only]
public fun create_quote_for_testing(
    amount_out: u64,
    effective_price: u64,
    price_impact_bps: u64,
    outcome: u64,
    is_asset_to_stable: bool,
): SpotQuote {
    SpotQuote {
        amount_out,
        effective_price,
        price_impact_bps,
        outcome,
        is_asset_to_stable,
    }
}

#[test_only]
public fun create_detailed_quote_for_testing(
    quote: SpotQuote,
    conditional_tokens_created: u64,
    excess_conditional_tokens: u64,
    spot_price_before: u64,
    spot_price_after: u64,
): DetailedSpotQuote {
    DetailedSpotQuote {
        quote,
        conditional_tokens_created,
        excess_conditional_tokens,
        spot_price_before,
        spot_price_after,
    }
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// No-arbitrage band enforcement for quantum liquidity futarchy markets
///
/// Prevents arbitrage loops by ensuring spot price stays within bounds implied by:
/// 1. Spot ‚Üí Conditionals ‚Üí Spot: buy on spot, mint complete set, sell across outcomes, redeem
/// 2. Conditionals ‚Üí Spot ‚Üí Conditionals: buy complete set, recombine to spot, sell
///
/// Mathematical invariant enforced:
/// floor ‚â§ P_spot ‚â§ ceiling
/// where:
/// - floor = (1 - f_s) * min_i[(1 - f_i) * p_i]
/// - ceiling = (1/(1 - f_s)) * Œ£_i[p_i/(1 - f_i)]
/// - P_s = spot price (stable per asset)
/// - p_i = conditional pool i price (stable/asset ratio)
/// - f_s, f_i = fees in basis points
module futarchy_markets_operations::no_arb_guard;

use futarchy_markets_core::unified_spot_pool::{Self, UnifiedSpotPool};
use futarchy_markets_primitives::conditional_amm::{Self, LiquidityPool};
use futarchy_one_shot_utils::constants;

// === Errors ===
const ENoArbBandViolation: u64 = 0;
const ENoPoolsProvided: u64 = 1;

// === Constants ===
/// Must match spot pool price scale
const PRICE_SCALE: u128 = 1_000_000_000_000; // 1e12

/// Compute instantaneous no-arb floor/ceiling for spot price P_s (stable per asset)
/// given the set of conditional pools and their fees/liquidity.
///
/// Returns: (floor, ceiling) both on PRICE_SCALE (1e12)
///
/// ## Arguments
/// - `spot_pool`: The spot AMM
/// - `pools`: Vector of conditional AMM pools
///
/// ## Returns
/// - `floor`: Minimum spot price that prevents Spot‚ÜíCond‚ÜíSpot arbitrage
/// - `ceiling`: Maximum spot price that prevents Cond‚ÜíSpot‚ÜíCond arbitrage
public fun compute_noarb_band<AssetType, StableType>(
    spot_pool: &UnifiedSpotPool<AssetType, StableType>,
    pools: &vector<LiquidityPool>,
): (u128, u128) {
    let n = pools.length();
    assert!(n > 0, ENoPoolsProvided);

    // Use actual basis points scale (10,000 = 100%) for fee calculations
    let bps = constants::total_fee_bps(); // 10,000 (correct BPS scale)
    let f_s = unified_spot_pool::get_fee_bps(spot_pool); // spot fee in bps
    let one_minus_fs = bps - f_s; // (1 - f_s)*bps

    // floor = (1 - f_s) * min_i [ (1 - f_i) * p_i ]
    // ceiling = (1 / (1 - f_s)) * sum_i [ p_i / (1 - f_i) ]
    let mut min_term: u128 = std::u128::max_value!();
    let mut sum_term: u128 = 0;

    let mut i = 0;
    while (i < n) {
        let pool = &pools[i];
        let (a_i, s_i) = conditional_amm::get_reserves(pool);

        // p_i on PRICE_SCALE: (stable_reserve / asset_reserve) * PRICE_SCALE
        let p_i = if (a_i == 0) {
            0
        } else {
            ((s_i as u128) * PRICE_SCALE) / (a_i as u128)
        };

        let f_i = conditional_amm::get_fee_bps(pool);
        let one_minus_fi = bps - f_i;

        // (1 - f_i) * p_i for floor calculation
        let term_floor = (p_i * (one_minus_fi as u128)) / (bps as u128);
        if (term_floor < min_term) {
            min_term = term_floor;
        };

        // p_i / (1 - f_i) for ceiling calculation
        // Guard divide-by-zero (fee < bps ensured by AMM)
        let term_ceil = if (one_minus_fi > 0) {
            (p_i * (bps as u128)) / (one_minus_fi as u128)
        } else {
            std::u128::max_value!()
        };
        sum_term = sum_term + term_ceil;

        i = i + 1;
    };

    // floor: multiply by (1 - f_s)
    let floor = (min_term * (one_minus_fs as u128)) / (bps as u128);

    // ceiling: divide by (1 - f_s) == multiply by bps / (bps - f_s)
    let ceiling = if (one_minus_fs > 0) {
        (sum_term * (bps as u128)) / (one_minus_fs as u128)
    } else {
        std::u128::max_value!()
    };

    (floor, ceiling)
}

/// Ensures current spot price is within the no-arb band.
/// Call this after running post-swap auto-arb to verify no arbitrage loop exists.
///
/// ## Panics
/// - If spot price is below floor (enables Spot‚ÜíCond‚ÜíSpot arb)
/// - If spot price is above ceiling (enables Cond‚ÜíSpot‚ÜíCond arb)
public fun ensure_spot_in_band<AssetType, StableType>(
    spot_pool: &UnifiedSpotPool<AssetType, StableType>,
    pools: &vector<LiquidityPool>,
) {
    let p_spot = unified_spot_pool::get_spot_price(spot_pool); // Returns u128 on PRICE_SCALE
    let (floor, ceiling) = compute_noarb_band(spot_pool, pools);

    assert!(p_spot >= floor && p_spot <= ceiling, ENoArbBandViolation);
}

/// Check if spot price is within band without reverting
/// Returns: (is_in_band, current_price, floor, ceiling)
public fun check_spot_in_band<AssetType, StableType>(
    spot_pool: &UnifiedSpotPool<AssetType, StableType>,
    pools: &vector<LiquidityPool>,
): (bool, u128, u128, u128) {
    let p_spot = unified_spot_pool::get_spot_price(spot_pool);
    let (floor, ceiling) = compute_noarb_band(spot_pool, pools);
    let is_in_band = p_spot >= floor && p_spot <= ceiling;

    (is_in_band, p_spot, floor, ceiling)
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// LP Token Custody Module
/// Manages LP tokens owned by DAOs from liquidity operations
///
/// This module provides secure custody of LP tokens using Account's managed assets feature.
/// Benefits of using managed assets over direct transfers:
/// 1. Enforces custody under Account's policy engine
/// 2. Prevents accidental outflows or unauthorized transfers
/// 3. Makes the relationship between Account and LP tokens explicit and enforceable
/// 4. Integrates with Account's permission system for access control
/// 5. Provides better tracking and audit capabilities
module futarchy_markets_operations::lp_token_custody;

use account_protocol::account::{Self, Account};
use account_protocol::package_registry::PackageRegistry;
use futarchy_core::futarchy_config::FutarchyConfig;
use futarchy_core::version;
use futarchy_markets_core::unified_spot_pool::{Self, LPToken, UnifiedSpotPool};
use std::option;
use std::string::String;
use sui::event;
use sui::object::{Self, ID};
use sui::table::{Self, Table};

// === Errors ===
const ELPTokenNotFound: u64 = 1;
const EInsufficientBalance: u64 = 2;
const EUnauthorized: u64 = 3;

// === Structs ===

/// Dynamic field key for LP token custody
public struct LPCustodyKey has copy, drop, store {}

/// Managed-asset key for storing LP tokens by ID (safer schema)
public struct LPKey has copy, drop, store {
    token_id: ID,
}

/// Enhanced LP token registry with better tracking capabilities
public struct LPTokenCustody has store {
    // Pool ID -> vector of LP token IDs
    tokens_by_pool: Table<ID, vector<ID>>,
    // Token ID -> amount for quick lookup
    token_amounts: Table<ID, u64>,
    // Token ID -> pool ID mapping for reverse lookup
    token_to_pool: Table<ID, ID>,
    // Pool ID -> total LP amount for that pool
    pool_totals: Table<ID, u64>,
    // Total value locked (sum of all LP tokens)
    total_value_locked: u64,
    // Registry of all pool IDs we have tokens for
    active_pools: vector<ID>,
}

// === Events ===

public struct LPTokenDeposited has copy, drop {
    account_id: ID,
    pool_id: ID,
    token_id: ID,
    amount: u64,
    new_pool_total: u64,
    new_total_value_locked: u64,
}

public struct LPTokenWithdrawn has copy, drop {
    account_id: ID,
    pool_id: ID,
    token_id: ID,
    amount: u64,
    recipient: address,
    new_pool_total: u64,
    new_total_value_locked: u64,
}

// === Public Functions ===

/// Initialize LP token custody for an account
public fun init_custody(account: &mut Account, registry: &PackageRegistry, ctx: &mut TxContext) {
    if (!has_custody(account)) {
        account::add_managed_data(
            account,
            registry,
            LPCustodyKey {},
            LPTokenCustody {
                tokens_by_pool: table::new(ctx),
                token_amounts: table::new(ctx),
                token_to_pool: table::new(ctx),
                pool_totals: table::new(ctx),
                total_value_locked: 0,
                active_pools: vector::empty(),
            },
            version::current(),
        );
    }
}

/// Check if account has LP custody initialized
public fun has_custody(account: &Account): bool {
    account::has_managed_data(account, LPCustodyKey {})
}

/// Deposit an LP token into custody
public fun deposit_lp_token<AssetType, StableType, W: drop>(
    account: &mut Account,
    registry: &PackageRegistry,
    pool_id: ID,
    token: LPToken<AssetType, StableType>,
    witness: W,
    ctx: &mut TxContext,
) {
    // Create Auth from witness for account verification
    let auth = account::new_auth<FutarchyConfig, W>(account, registry, version::current(), witness);
    account::verify(account, auth);

    // Get account ID before mutable borrowing
    let account_id = object::id(account);
    let account_address = object::id_address(account);

    // Initialize custody if needed
    if (!has_custody(account)) {
        init_custody(account, registry, ctx);
    };

    let custody: &mut LPTokenCustody = account::borrow_managed_data_mut(
        account,
        registry,
        LPCustodyKey {},
        version::current(),
    );

    let token_id = object::id(&token);
    let amount = unified_spot_pool::lp_token_amount(&token);

    // Update tokens by pool
    if (!custody.tokens_by_pool.contains(pool_id)) {
        custody.tokens_by_pool.add(pool_id, vector::empty());
        custody.pool_totals.add(pool_id, 0);
        // Add to active pools if not already present
        let (found, _) = custody.active_pools.index_of(&pool_id);
        if (!found) {
            custody.active_pools.push_back(pool_id);
        };
    };
    let pool_tokens = custody.tokens_by_pool.borrow_mut(pool_id);
    pool_tokens.push_back(token_id);

    // Update token tracking tables
    custody.token_amounts.add(token_id, amount);
    custody.token_to_pool.add(token_id, pool_id);

    // Update pool total
    let pool_total = custody.pool_totals.borrow_mut(pool_id);
    *pool_total = *pool_total + amount;

    // Update global total
    custody.total_value_locked = custody.total_value_locked + amount;

    // Get values for event before transfer
    let new_pool_total = *custody.pool_totals.borrow(pool_id);
    let new_total_value_locked = custody.total_value_locked;

    // Store LP token as a managed asset in the Account
    // This ensures proper custody under Account's policy engine and prevents accidental outflows
    // The LPKey with token_id is used as the key for retrieval
    account::add_managed_asset(
        account,
        registry,
        LPKey { token_id },
        token,
        version::current(),
    );

    event::emit(LPTokenDeposited {
        account_id,
        pool_id,
        token_id,
        amount,
        new_pool_total,
        new_total_value_locked,
    });
}

/// Deposit LP token into custody during init - works on unshared Accounts
/// This version bypasses auth checks since it's only callable during DAO initialization
/// Same logic as deposit_lp_token but without witness verification
public fun deposit_lp_token_unshared<AssetType, StableType>(
    account: &mut Account,
    registry: &PackageRegistry,
    pool_id: ID,
    token: LPToken<AssetType, StableType>,
    ctx: &mut TxContext,
) {
    // Get account ID before mutable borrowing
    let account_id = object::id(account);

    // Initialize custody if needed
    if (!has_custody(account)) {
        init_custody(account, registry, ctx);
    };

    let custody: &mut LPTokenCustody = account::borrow_managed_data_mut(
        account,
        registry,
        LPCustodyKey {},
        version::current(),
    );

    let token_id = object::id(&token);
    let amount = unified_spot_pool::lp_token_amount(&token);

    // Update tokens by pool
    if (!custody.tokens_by_pool.contains(pool_id)) {
        custody.tokens_by_pool.add(pool_id, vector::empty());
        custody.pool_totals.add(pool_id, 0);
        // Add to active pools if not already present
        let (found, _) = custody.active_pools.index_of(&pool_id);
        if (!found) {
            custody.active_pools.push_back(pool_id);
        };
    };
    let pool_tokens = custody.tokens_by_pool.borrow_mut(pool_id);
    pool_tokens.push_back(token_id);

    // Update token tracking tables
    custody.token_amounts.add(token_id, amount);
    custody.token_to_pool.add(token_id, pool_id);

    // Update pool total
    let pool_total = custody.pool_totals.borrow_mut(pool_id);
    *pool_total = *pool_total + amount;

    // Update global total
    custody.total_value_locked = custody.total_value_locked + amount;

    // Get values for event before transfer
    let new_pool_total = *custody.pool_totals.borrow(pool_id);
    let new_total_value_locked = custody.total_value_locked;

    // Store LP token as a managed asset in the Account
    // This ensures proper custody under Account's policy engine and prevents accidental outflows
    // The LPKey with token_id is used as the key for retrieval
    account::add_managed_asset(
        account,
        registry,
        LPKey { token_id },
        token,
        version::current(),
    );

    event::emit(LPTokenDeposited {
        account_id,
        pool_id,
        token_id,
        amount,
        new_pool_total,
        new_total_value_locked,
    });
}

/// Withdraw LP token from custody and return it to caller
/// The token_id identifies which LP token to withdraw from managed assets
public fun withdraw_lp_token<AssetType, StableType, W: drop>(
    account: &mut Account,
    registry: &PackageRegistry,
    pool_id: ID,
    token_id: ID,
    witness: W,
    _ctx: &mut TxContext,
): LPToken<AssetType, StableType> {
    // Create Auth from witness for account verification
    let auth = account::new_auth<FutarchyConfig, W>(account, registry, version::current(), witness);
    account::verify(account, auth);

    // Get account ID before mutable borrowing
    let account_id = object::id(account);

    // Retrieve the LP token from managed assets
    let token: LPToken<AssetType, StableType> = account::remove_managed_asset(
        account,
        registry,
        LPKey { token_id },
        version::current(),
    );

    let amount = unified_spot_pool::lp_token_amount(&token);

    let custody: &mut LPTokenCustody = account::borrow_managed_data_mut(
        account,
        registry,
        LPCustodyKey {},
        version::current(),
    );

    // Verify token is in custody and mapped to the supplied pool
    assert!(custody.token_amounts.contains(token_id), ELPTokenNotFound);
    assert!(custody.token_amounts[token_id] == amount, EInsufficientBalance);
    assert!(custody.token_to_pool.contains(token_id), ELPTokenNotFound);
    let recorded_pool_id = custody.token_to_pool[token_id];
    assert!(recorded_pool_id == pool_id, EUnauthorized);

    // Remove from tracking tables
    custody.token_amounts.remove(token_id);
    custody.token_to_pool.remove(token_id);

    // Update pool total
    let pool_total = custody.pool_totals.borrow_mut(pool_id);
    *pool_total = *pool_total - amount;

    // Update global total
    custody.total_value_locked = custody.total_value_locked - amount;

    // Remove from pool tokens list
    if (custody.tokens_by_pool.contains(pool_id)) {
        let pool_tokens = custody.tokens_by_pool.borrow_mut(pool_id);
        let (found, index) = pool_tokens.index_of(&token_id);
        if (found) {
            pool_tokens.remove(index);

            // If no more tokens for this pool, remove from active pools
            if (pool_tokens.is_empty()) {
                let (pool_found, pool_index) = custody.active_pools.index_of(&pool_id);
                if (pool_found) {
                    custody.active_pools.remove(pool_index);
                };
            };
        };
    };

    // Get values for event
    let new_pool_total = *custody.pool_totals.borrow(pool_id);
    let new_total_value_locked = custody.total_value_locked;
    let account_address = object::id_address(account);

    event::emit(LPTokenWithdrawn {
        account_id,
        pool_id,
        token_id,
        amount,
        recipient: account_address,
        new_pool_total,
        new_total_value_locked,
    });

    // Return LP token to caller
    token
}

/// Get total value locked in LP tokens
public fun get_total_value_locked(account: &Account, registry: &PackageRegistry): u64 {
    if (!has_custody(account)) {
        return 0
    };

    let custody: &LPTokenCustody = account::borrow_managed_data(
        account,
        registry,
        LPCustodyKey {},
        version::current(),
    );

    custody.total_value_locked
}

/// Get LP token IDs for a specific pool
public fun get_pool_tokens(account: &Account, registry: &PackageRegistry, pool_id: ID): vector<ID> {
    if (!has_custody(account)) {
        return vector::empty()
    };

    let custody: &LPTokenCustody = account::borrow_managed_data(
        account,
        registry,
        LPCustodyKey {},
        version::current(),
    );

    if (custody.tokens_by_pool.contains(pool_id)) {
        *custody.tokens_by_pool.borrow(pool_id)
    } else {
        vector::empty()
    }
}

/// Get amount for a specific LP token
public fun get_token_amount(account: &Account, registry: &PackageRegistry, token_id: ID): u64 {
    if (!has_custody(account)) {
        return 0
    };

    let custody: &LPTokenCustody = account::borrow_managed_data(
        account,
        registry,
        LPCustodyKey {},
        version::current(),
    );

    if (custody.token_amounts.contains(token_id)) {
        custody.token_amounts[token_id]
    } else {
        0
    }
}

/// Get the pool ID that contains a specific LP token
public fun get_token_pool(account: &Account, registry: &PackageRegistry, token_id: ID): Option<ID> {
    if (!has_custody(account)) {
        return option::none()
    };

    let custody: &LPTokenCustody = account::borrow_managed_data(
        account,
        registry,
        LPCustodyKey {},
        version::current(),
    );

    if (custody.token_to_pool.contains(token_id)) {
        option::some(custody.token_to_pool[token_id])
    } else {
        option::none()
    }
}

/// Get total LP token amount for a specific pool
public fun get_pool_total(account: &Account, registry: &PackageRegistry, pool_id: ID): u64 {
    if (!has_custody(account)) {
        return 0
    };

    let custody: &LPTokenCustody = account::borrow_managed_data(
        account,
        registry,
        LPCustodyKey {},
        version::current(),
    );

    if (custody.pool_totals.contains(pool_id)) {
        custody.pool_totals[pool_id]
    } else {
        0
    }
}

/// Get all active pool IDs (pools that have LP tokens)
public fun get_active_pools(account: &Account, registry: &PackageRegistry): vector<ID> {
    if (!has_custody(account)) {
        return vector::empty()
    };

    let custody: &LPTokenCustody = account::borrow_managed_data(
        account,
        registry,
        LPCustodyKey {},
        version::current(),
    );

    custody.active_pools
}

/// Check if account has any LP tokens for a specific pool
public fun has_tokens_for_pool(account: &Account, registry: &PackageRegistry, pool_id: ID): bool {
    if (!has_custody(account)) {
        return false
    };

    let custody: &LPTokenCustody = account::borrow_managed_data(
        account,
        registry,
        LPCustodyKey {},
        version::current(),
    );

    custody.tokens_by_pool.contains(pool_id) && !custody.tokens_by_pool[pool_id].is_empty()
}

/// Get summary statistics for all LP token holdings
public fun get_custody_summary(account: &Account, registry: &PackageRegistry): (u64, u64, vector<ID>) {
    if (!has_custody(account)) {
        return (0, 0, vector::empty())
    };

    let custody: &LPTokenCustody = account::borrow_managed_data(
        account,
        registry,
        LPCustodyKey {},
        version::current(),
    );

    (custody.total_value_locked, custody.active_pools.length(), custody.active_pools)
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

module futarchy_markets_operations::liquidity_interact;

use futarchy_markets_core::fee::FeeManager;
use futarchy_markets_core::proposal::Proposal;
use futarchy_markets_primitives::coin_escrow::{Self, TokenEscrow};
use futarchy_markets_primitives::conditional_amm;
use sui::balance::Balance;
use sui::clock::Clock;
use sui::coin::{Self, Coin};
use sui::event;

// === Introduction ===
// Methods to interact with AMM liquidity and escrow balances using TreasuryCap-based conditional coins

// === Errors ===
const EInvalidOutcome: u64 = 0;
const EInvalidLiquidityTransfer: u64 = 1;
const EWrongOutcome: u64 = 2;
const EInvalidState: u64 = 3;
const EMarketIdMismatch: u64 = 4;
const EAssetReservesMismatch: u64 = 5;
const EStableReservesMismatch: u64 = 6;
const EInsufficientAmount: u64 = 7;
const EMinAmountNotMet: u64 = 8;

// === Events ===
public struct ProtocolFeesCollected has copy, drop {
    proposal_id: ID,
    winning_outcome: u64,
    fee_amount: u64,
    timestamp_ms: u64,
}

// === Liquidity Removal (After Finalization) ===

/// Empties the winning AMM pool and returns the liquidity.
/// Called internally by `advance_stage` when a DAO-funded proposal finalizes.
/// Returns the asset and stable coins for the DAO to handle (e.g., deposit to vault).
public fun empty_amm_and_return_to_dao<
    AssetType,
    StableType,
    AssetConditionalCoin,
    StableConditionalCoin,
>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    ctx: &mut TxContext,
): (Coin<AssetType>, Coin<StableType>) {
    assert!(proposal.is_finalized(), EInvalidState);
    // All proposals now use DAO liquidity, so this check is always true

    let market_state = escrow.get_market_state();
    market_state.assert_market_finalized();

    let winning_outcome = proposal.get_winning_outcome();
    // Get winning pool from market_state
    let market_state = escrow.get_market_state_mut();
    let pool = futarchy_markets_primitives::market_state::get_pool_mut_by_outcome(
        market_state,
        (winning_outcome as u8),
    );
    let (conditional_asset_amt, conditional_stable_amt) = pool.empty_all_amm_liquidity(ctx);

    // Burn conditional coins and withdraw spot tokens
    let asset_coin = escrow.burn_conditional_asset_and_withdraw<
        AssetType,
        StableType,
        AssetConditionalCoin,
    >(
        winning_outcome,
        conditional_asset_amt,
        ctx,
    );

    let stable_coin = escrow.burn_conditional_stable_and_withdraw<
        AssetType,
        StableType,
        StableConditionalCoin,
    >(
        winning_outcome,
        conditional_stable_amt,
        ctx,
    );

    (asset_coin, stable_coin)
}

// === Complete Set Minting/Redemption ===
// With TreasuryCap-based conditional coins, "complete set" operations work per-outcome

/// Mint a complete set of conditional coins for a specific outcome by depositing spot tokens
/// Deposits spot asset and mints conditional asset coin for the specified outcome
/// Returns the conditional asset coin
public fun mint_conditional_asset_for_outcome<AssetType, StableType, ConditionalCoinType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_index: u64,
    spot_asset: Coin<AssetType>,
    ctx: &mut TxContext,
): Coin<ConditionalCoinType> {
    coin_escrow::deposit_asset_and_mint_conditional<AssetType, StableType, ConditionalCoinType>(
        escrow,
        outcome_index,
        spot_asset,
        ctx,
    )
}

/// Mint conditional stable coin for a specific outcome by depositing spot stable
public fun mint_conditional_stable_for_outcome<AssetType, StableType, ConditionalCoinType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_index: u64,
    spot_stable: Coin<StableType>,
    ctx: &mut TxContext,
): Coin<ConditionalCoinType> {
    coin_escrow::deposit_stable_and_mint_conditional<AssetType, StableType, ConditionalCoinType>(
        escrow,
        outcome_index,
        spot_stable,
        ctx,
    )
}

/// Redeem conditional asset coin back to spot asset
/// Burns the conditional coin and returns spot asset
public fun redeem_conditional_asset<AssetType, StableType, ConditionalCoinType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    conditional_coin: Coin<ConditionalCoinType>,
    outcome_index: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<AssetType> {
    assert!(proposal.is_finalized(), EInvalidState);
    let winning_outcome = proposal.get_winning_outcome();
    assert!(outcome_index == winning_outcome, EWrongOutcome);

    let amount = conditional_coin.value();

    // Burn the conditional coin
    coin_escrow::burn_conditional_asset<AssetType, StableType, ConditionalCoinType>(
        escrow,
        outcome_index,
        conditional_coin,
    );

    // Withdraw spot asset (1:1)
    coin_escrow::withdraw_asset_balance(escrow, amount, ctx)
}

/// Redeem conditional stable coin back to spot stable
public fun redeem_conditional_stable<AssetType, StableType, ConditionalCoinType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    conditional_coin: Coin<ConditionalCoinType>,
    outcome_index: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<StableType> {
    assert!(proposal.is_finalized(), EInvalidState);
    let winning_outcome = proposal.get_winning_outcome();
    assert!(outcome_index == winning_outcome, EWrongOutcome);

    let amount = conditional_coin.value();

    // Burn the conditional coin
    coin_escrow::burn_conditional_stable<AssetType, StableType, ConditionalCoinType>(
        escrow,
        outcome_index,
        conditional_coin,
    );

    // Withdraw spot stable (1:1)
    coin_escrow::withdraw_stable_balance(escrow, amount, ctx)
}

// === AMM Liquidity Management ===

/// Add liquidity to an AMM pool for a specific outcome
/// Takes asset and stable conditional coins and mints LP tokens
/// Uses TreasuryCap-based conditional coins
public entry fun add_liquidity_entry<
    AssetType,
    StableType,
    AssetConditionalCoin,
    StableConditionalCoin,
    LPConditionalCoin,
>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    asset_in: Coin<AssetConditionalCoin>,
    stable_in: Coin<StableConditionalCoin>,
    min_lp_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(!proposal.is_finalized(), EInvalidState);

    let asset_amount = asset_in.value();
    let stable_amount = stable_in.value();

    // Burn the conditional coins using TreasuryCaps
    coin_escrow::burn_conditional_asset<AssetType, StableType, AssetConditionalCoin>(
        escrow,
        outcome_idx,
        asset_in,
    );

    coin_escrow::burn_conditional_stable<AssetType, StableType, StableConditionalCoin>(
        escrow,
        outcome_idx,
        stable_in,
    );

    // Get the pool for this outcome from market_state
    let market_state = escrow.get_market_state_mut();

    // Add liquidity and get new price (within pool borrow scope)
    let (lp_amount, new_price) = {
        let pool = futarchy_markets_primitives::market_state::get_pool_mut_by_outcome(
            market_state,
            (outcome_idx as u8),
        );

        // Add liquidity through the AMM (updates virtual reserves)
        let lp = conditional_amm::add_liquidity_proportional(
            pool,
            asset_amount,
            stable_amount,
            min_lp_out,
            clock,
            ctx,
        );

        // Get new price before pool borrow is released
        let price = conditional_amm::get_current_price(pool);
        (lp, price)
    }; // pool borrow released here

    // Mint LP tokens using TreasuryCap
    let lp_token = coin_escrow::mint_conditional_asset<AssetType, StableType, LPConditionalCoin>(
        escrow,
        outcome_idx,
        lp_amount,
        ctx,
    );

    // Transfer LP token to the sender
    transfer::public_transfer(lp_token, ctx.sender());
}

/// Remove liquidity from an AMM pool proportionally
/// Burns LP tokens and returns asset and stable conditional coins
public entry fun remove_liquidity_entry<
    AssetType,
    StableType,
    AssetConditionalCoin,
    StableConditionalCoin,
    LPConditionalCoin,
>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    lp_token: Coin<LPConditionalCoin>,
    min_asset_out: u64,
    min_stable_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(!proposal.is_finalized(), EInvalidState);

    let lp_amount = lp_token.value();

    // Burn the LP token using TreasuryCap
    coin_escrow::burn_conditional_asset<AssetType, StableType, LPConditionalCoin>(
        escrow,
        outcome_idx,
        lp_token,
    );

    // Get the pool for this outcome from market_state
    let market_state = escrow.get_market_state_mut();

    // Remove liquidity and get new price (within pool borrow scope)
    let (asset_amount, stable_amount, new_price) = {
        let pool = futarchy_markets_primitives::market_state::get_pool_mut_by_outcome(
            market_state,
            (outcome_idx as u8),
        );

        // Remove liquidity through the AMM (updates virtual reserves)
        let (asset, stable) = conditional_amm::remove_liquidity_proportional(
            pool,
            lp_amount,
            clock,
            ctx,
        );

        // Get new price before pool borrow is released
        let price = conditional_amm::get_current_price(pool);
        (asset, stable, price)
    }; // pool borrow released here

    // Verify slippage protection
    assert!(asset_amount >= min_asset_out, EMinAmountNotMet);
    assert!(stable_amount >= min_stable_out, EMinAmountNotMet);

    // Mint the asset and stable conditional tokens using TreasuryCaps
    let asset_token = coin_escrow::mint_conditional_asset<
        AssetType,
        StableType,
        AssetConditionalCoin,
    >(
        escrow,
        outcome_idx,
        asset_amount,
        ctx,
    );

    let stable_token = coin_escrow::mint_conditional_stable<
        AssetType,
        StableType,
        StableConditionalCoin,
    >(
        escrow,
        outcome_idx,
        stable_amount,
        ctx,
    );

    // Transfer tokens to the sender
    transfer::public_transfer(asset_token, ctx.sender());
    transfer::public_transfer(stable_token, ctx.sender());
}

// === Protocol Fee Collection ===

/// Collect protocol fees from the winning pool after finalization
/// Withdraws fees from escrow and deposits them to the fee manager
/// NOW COLLECTS BOTH ASSET AND STABLE TOKEN FEES
public fun collect_protocol_fees<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    fee_manager: &mut FeeManager,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(proposal.is_finalized(), EInvalidState);
    assert!(proposal.is_winning_outcome_set(), EInvalidState);

    let winning_outcome = proposal.get_winning_outcome();
    // Get protocol fees from winning pool
    let (protocol_fee_asset, protocol_fee_stable) = {
        let market_state = escrow.get_market_state_mut();
        let winning_pool = futarchy_markets_primitives::market_state::get_pool_mut_by_outcome(
            market_state,
            (winning_outcome as u8),
        );

        // Get both asset and stable protocol fees
        let fee_asset = winning_pool.get_protocol_fees_asset();
        let fee_stable = winning_pool.get_protocol_fees_stable();
        (fee_asset, fee_stable)
    }; // winning_pool borrow dropped here

    let mut total_fees_collected = 0u64;

    // Collect asset token fees
    if (protocol_fee_asset > 0) {
        let (spot_asset, spot_stable) = coin_escrow::get_spot_balances(escrow);
        assert!(spot_asset >= protocol_fee_asset, EInsufficientAmount);

        let fee_balance_coin = coin_escrow::withdraw_asset_balance(
            escrow,
            protocol_fee_asset,
            ctx,
        );
        let fee_balance = coin::into_balance(fee_balance_coin);

        // Deposit to fee manager
        fee_manager.deposit_asset_fees<AssetType>(
            fee_balance,
            proposal.get_id(),
            clock,
        );

        total_fees_collected = total_fees_collected + protocol_fee_asset;
    };

    // Collect stable token fees
    if (protocol_fee_stable > 0) {
        let (spot_asset, spot_stable) = coin_escrow::get_spot_balances(escrow);
        assert!(spot_stable >= protocol_fee_stable, EInsufficientAmount);

        let fee_balance_coin = coin_escrow::withdraw_stable_balance(
            escrow,
            protocol_fee_stable,
            ctx,
        );
        let fee_balance = coin::into_balance(fee_balance_coin);

        // Deposit to fee manager
        fee_manager.deposit_stable_fees<StableType>(
            fee_balance,
            proposal.get_id(),
            clock,
        );

        total_fees_collected = total_fees_collected + protocol_fee_stable;
    };

    // Reset fees in the pool after collection
    if (protocol_fee_asset > 0 || protocol_fee_stable > 0) {
        let market_state = escrow.get_market_state_mut();
        let winning_pool = futarchy_markets_primitives::market_state::get_pool_mut_by_outcome(
            market_state,
            (winning_outcome as u8),
        );
        winning_pool.reset_protocol_fees();

        // Emit event
        event::emit(ProtocolFeesCollected {
            proposal_id: proposal.get_id(),
            winning_outcome,
            fee_amount: total_fees_collected,
            timestamp_ms: clock.timestamp_ms(),
        });
    }
}

// === LP Withdrawal Crank ===

/// Crank function to transition TRANSITIONING bucket to WITHDRAW_ONLY
/// Called after proposal finalizes and winning liquidity has been recombined to spot
///
/// This is the final step that allows LPs who marked for withdrawal to claim their coins.
/// The recombination process moves conditional.TRANSITIONING ‚Üí spot.WITHDRAW_ONLY directly,
/// but this function handles any remaining TRANSITIONING that didn't go through a proposal.
///
/// Flow:
/// 1. Proposal ends ‚Üí auto_redeem_on_proposal_end() recombines liquidity (TRANSITIONING ‚Üí WITHDRAW_ONLY)
/// 2. This crank moves any remaining leaving ‚Üí frozen (edge case: marked during no-proposal period)
/// 3. Users can now call claim_withdrawal() to get their coins
public entry fun crank_recombine_and_transition<AssetType, StableType>(
    spot_pool: &mut futarchy_markets_core::unified_spot_pool::UnifiedSpotPool<
        AssetType,
        StableType,
    >,
) {
    // Move all leaving bucket amounts to frozen claimable
    // This is an atomic batch operation that processes all pending withdrawals
    futarchy_markets_core::unified_spot_pool::transition_leaving_to_frozen_claimable(spot_pool);
}

// === Test Helpers ===

#[test_only]
public fun get_liquidity_for_proposal<AssetType, StableType>(
    escrow: &futarchy_markets_primitives::coin_escrow::TokenEscrow<AssetType, StableType>,
): vector<u64> {
    let market_state = escrow.get_market_state();
    let pools = futarchy_markets_primitives::market_state::borrow_amm_pools(market_state);
    let mut liquidity = vector[];
    let mut i = 0;
    while (i < pools.length()) {
        let pool = &pools[i];
        let (asset, stable) = pool.get_reserves();
        liquidity.push_back(asset);
        liquidity.push_back(stable);
        i = i + 1;
    };
    liquidity
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// ============================================================================
/// PERCENT-CAPPED WINDOWED TWAP ORACLE
/// ============================================================================
///
/// PURPOSE: Provide manipulation-resistant TWAP for oracle grants
///
/// KEY FEATURES:
/// - Fixed-size windows (1 minute default)
/// - TWAP movement capped as % of current window's TWAP
/// - O(1) gas - just arithmetic, no loops or exponentiation
/// - Cap recalculates between batches (grows with TWAP)
///
/// MANIPULATION RESISTANCE:
/// - Attacker spikes price $100 ‚Üí $200 for 10 minutes
/// - Cap calculated ONCE: 1% of $100 = $1 per window
/// - Take 10 steps of $1 each (ARITHMETIC within batch)
/// - Result: $100 + ($1 √ó 10) = $110
/// - Next batch: Cap recalculates as 1% of $110 = $1.10
///
/// GAS EFFICIENCY:
/// - O(1) constant time - just multiplication and min()
/// - No loops, no binary search, no exponentiation
/// - Example: 10 missed windows = same cost as 1 window
/// - 10x+ faster than geometric approach with binary search
///
/// SECURITY PROPERTY:
/// - Cap grows with TWAP (percentage-based)
/// - Allows legitimate price movements over time
/// - Still prevents instant manipulation
/// - Example: $100 ‚Üí $200 instant = capped to $101
/// - Example: $100 ‚Üí $200 over 100 windows = reaches $200
///
/// USED BY:
/// - Oracle grants: get_twap() ‚Üí capped 1-minute windowed TWAP
/// - External consumers: Choose based on use case
///
/// ============================================================================

module futarchy_markets_primitives::PCW_TWAP_oracle;

use std::option;
use std::vector;
use sui::clock::Clock;
use sui::event;

// ============================================================================
// Constants
// ============================================================================

const ONE_MINUTE_MS: u64 = 60_000;
const PPM_DENOMINATOR: u64 = 1_000_000; // Parts per million (1% = 10,000 PPM)
const DEFAULT_MAX_MOVEMENT_PPM: u64 = 10_000; // 1% default cap
const NINETY_DAYS_MS: u64 = 7_776_000_000; // 90 days
const CHECKPOINT_INTERVAL_MS: u64 = 604_800_000; // 7 days
const MAX_CHECKPOINTS: u64 = 20;

// ============================================================================
// Errors
// ============================================================================

const EOverflow: u64 = 0;
const EInvalidConfig: u64 = 1;
const ETimestampRegression: u64 = 2;
const ENotInitialized: u64 = 3;
const EInvalidProjection: u64 = 4;
const EInvalidBackfill: u64 = 5;

// ============================================================================
// Structs
// ============================================================================

/// Long-horizon checkpoint stored roughly once per week
public struct Checkpoint has copy, drop, store {
    timestamp: u64,
    cumulative: u256,
}

/// Simple TWAP with O(1) arithmetic percentage capping
public struct SimpleTWAP has store {
    /// Last finalized window's TWAP (returned by get_twap())
    last_window_twap: u128,
    /// Cumulative price * time for current (incomplete) window
    cumulative_price: u256,
    /// Start of current window (ms)
    window_start: u64,
    /// Last update timestamp (ms)
    last_update: u64,
    /// Window size (default: 1 minute)
    window_size_ms: u64,
    /// Maximum movement per window in PPM (default: 1% = 10,000 PPM)
    max_movement_ppm: u64,
    /// Whether at least one window has been finalized (TWAP is valid)
    initialized: bool,
    /// Total cumulative price √ó time since initialization (for backfill & blending)
    cumulative_total: u256,
    /// Last observed spot price (used for projection and backfill)
    last_price: u128,
    /// Oracle initialization timestamp
    initialized_at: u64,
    /// Rolling checkpoints used to approximate long windows
    checkpoints: vector<Checkpoint>,
    /// Timestamp of the most recent checkpoint
    last_checkpoint_at: u64,
}

// ============================================================================
// Events
// ============================================================================

public struct WindowFinalized has copy, drop {
    timestamp: u64,
    raw_twap: u128,
    capped_twap: u128,
    num_windows: u64,
}

// ============================================================================
// Creation
// ============================================================================

/// Create TWAP oracle with default 1-minute windows and 1% cap
public fun new_default(initial_price: u128, clock: &Clock): SimpleTWAP {
    new(initial_price, ONE_MINUTE_MS, DEFAULT_MAX_MOVEMENT_PPM, clock)
}

/// Create TWAP oracle with custom configuration
public fun new(
    initial_price: u128,
    window_size_ms: u64,
    max_movement_ppm: u64,
    clock: &Clock,
): SimpleTWAP {
    assert!(window_size_ms > 0, EInvalidConfig);
    assert!(max_movement_ppm > 0 && max_movement_ppm < PPM_DENOMINATOR, EInvalidConfig);

    let now = clock.timestamp_ms();

    let mut oracle = SimpleTWAP {
        last_window_twap: initial_price,
        cumulative_price: 0,
        window_start: now,
        last_update: now,
        window_size_ms,
        max_movement_ppm,
        initialized: true, // Initial price is valid TWAP (from AMM ratio or spot TWAP)
        cumulative_total: 0,
        last_price: initial_price,
        initialized_at: now,
        checkpoints: vector::empty(),
        last_checkpoint_at: now,
    };

    record_checkpoint(&mut oracle, now);

    oracle
}

// ============================================================================
// Core Update Logic - Multi-Step Arithmetic Capping
// ============================================================================

/// Update oracle with new price observation
///
/// KEY ALGORITHM:
/// 1. Accumulate price * time into current window
/// 2. If window(s) completed:
///    a. Calculate raw TWAP from accumulated data
///    b. Calculate FIXED cap (% of current TWAP)
///    c. Total movement = min(gap, cap √ó num_windows)
/// 3. Reset window
///
/// CRITICAL INSIGHT:
/// - Cap calculated ONCE per batch (fixed $ amount)
/// - Total movement = cap √ó num_windows (arithmetic)
/// - Cap recalculates BETWEEN batches (next update call)
/// - Prevents instant manipulation, allows gradual tracking
///
/// EXAMPLE:
/// - Price jumps $100 ‚Üí $200, stays for 10 minutes (10 windows)
/// - Batch 1: Cap = 1% of $100 = $1, movement = $1 √ó 10 = $10 ‚Üí $110
/// - Next update: Cap = 1% of $110 = $1.10, movement = $1.10 √ó 10 = $11 ‚Üí $121
/// - Cap grows between batches, enabling gradual price tracking
///
public fun update(oracle: &mut SimpleTWAP, price: u128, clock: &Clock) {
    let now = clock.timestamp_ms();

    // Prevent timestamp regression
    assert!(now >= oracle.last_update, ETimestampRegression);

    let elapsed = now - oracle.last_update;

    if (elapsed == 0) {
        oracle.last_price = price;
        return;
    };

    let price_time = (oracle.last_price as u256) * (elapsed as u256);

    // Accumulate price * time for current window
    oracle.cumulative_price = oracle.cumulative_price + price_time;

    // Track total cumulative for longer windows/backfill logic
    oracle.cumulative_total = oracle.cumulative_total + price_time;

    oracle.last_update = now;
    oracle.last_price = price;

    // Check if any window(s) completed
    let time_since_window = now - oracle.window_start;
    let num_windows = time_since_window / oracle.window_size_ms;

    if (num_windows > 0) {
        finalize_window(oracle, now, num_windows);
    };
    maybe_commit_checkpoint(oracle, now);
}

/// Finalize window - Take multiple capped steps with FIXED cap
///
/// ALGORITHM (matches oracle.move pattern):
/// - Calculate raw TWAP from accumulated price * time
/// - Calculate FIXED cap (% of current TWAP, stays constant for this batch)
/// - Take num_windows steps using the FIXED cap
/// - Cap gets recalculated next batch (grows between batches, not within)
///
/// KEY INSIGHT: Arithmetic steps within batch, geometric growth between batches
/// - Batch 1: Cap = 1% of $100 = $1, take 10 steps ‚Üí $110
/// - Batch 2: Cap = 1% of $110 = $1.10, take 10 steps ‚Üí $121
/// Result: Cap grows with TWAP, but steps are arithmetic within each batch
///
fun finalize_window(oracle: &mut SimpleTWAP, now: u64, num_windows: u64) {
    // The "raw" target is the current spot price we're tracking toward
    // We cap the movement from last_window_twap toward this spot price
    let raw_twap = oracle.last_price;

    // Calculate FIXED cap for this entire batch (% of current TWAP)
    let max_step_u256 =
        (oracle.last_window_twap as u256) *
        (oracle.max_movement_ppm as u256) / (PPM_DENOMINATOR as u256);
    assert!(max_step_u256 <= (std::u128::max_value!() as u256), EOverflow);
    let max_step = (max_step_u256 as u128);

    // Calculate total gap
    let (total_gap, going_up) = if (raw_twap > oracle.last_window_twap) {
        (raw_twap - oracle.last_window_twap, true)
    } else {
        (oracle.last_window_twap - raw_twap, false)
    };

    // Calculate total movement (capped by SINGLE max_step for O(1) gas)
    // CRITICAL: Take ONE step regardless of num_windows for predictable gas cost
    // This means catching up after missed windows requires multiple update() calls
    let max_total_movement = max_step;

    let actual_movement = if (total_gap > max_total_movement) {
        max_total_movement
    } else {
        total_gap
    };

    // Update TWAP with capped movement
    let capped_twap = if (going_up) {
        oracle.last_window_twap + actual_movement
    } else {
        oracle.last_window_twap - actual_movement
    };

    // Emit event
    event::emit(WindowFinalized {
        timestamp: now,
        raw_twap,
        capped_twap,
        num_windows,
    });

    // Update state (cap will be recalculated next batch based on new capped_twap)
    oracle.last_window_twap = capped_twap;
    oracle.window_start = oracle.window_start + (num_windows * oracle.window_size_ms);
    let remainder_duration = now - oracle.window_start;
    oracle.cumulative_price = (oracle.last_price as u256) * (remainder_duration as u256);
    // Note: initialized already set to true in constructor (saves 1 SSTORE ~100 gas)
}

// ============================================================================
// View Functions
// ============================================================================

/// Get current TWAP (last finalized window's capped TWAP)
///
/// NOTE: Oracle is initialized with valid TWAP from:
/// - Spot AMM: Initial pool ratio (e.g., reserve1/reserve0)
/// - Conditional AMM: Spot's TWAP at proposal creation time
///
/// This is O(1) - just returns a stored value
public fun get_twap(oracle: &SimpleTWAP): u128 {
    assert!(oracle.initialized, ENotInitialized);
    oracle.last_window_twap
}

/// Check if oracle has at least one full window of observations
public fun is_ready(oracle: &SimpleTWAP, clock: &Clock): bool {
    if (!oracle.initialized) {
        return false
    };
    let now = clock.timestamp_ms();
    if (now <= oracle.initialized_at) {
        return false
    };
    let elapsed = now - oracle.initialized_at;
    elapsed >= oracle.window_size_ms
}

/// Get last finalized window's TWAP (same as get_twap, for compatibility)
public fun last_finalized_twap(oracle: &SimpleTWAP): u128 {
    oracle.last_window_twap
}

/// Get window configuration
public fun window_size_ms(oracle: &SimpleTWAP): u64 {
    oracle.window_size_ms
}

/// Get max movement in PPM
public fun max_movement_ppm(oracle: &SimpleTWAP): u64 {
    oracle.max_movement_ppm
}

/// Get last observed price
public fun last_price(oracle: &SimpleTWAP): u128 {
    oracle.last_price
}

/// Get last update timestamp
public fun last_update(oracle: &SimpleTWAP): u64 {
    oracle.last_update
}

/// Get oracle initialization timestamp
public fun initialized_at(oracle: &SimpleTWAP): u64 {
    oracle.initialized_at
}

/// Total cumulative price √ó time since initialization
public fun cumulative_total(oracle: &SimpleTWAP): u256 {
    oracle.cumulative_total
}

/// Project cumulative price √ó time forward to target_timestamp (must be >= last_update)
public fun projected_cumulative_arithmetic_to(oracle: &SimpleTWAP, target_timestamp: u64): u256 {
    assert!(target_timestamp >= oracle.last_update, EInvalidProjection);
    let elapsed = target_timestamp - oracle.last_update;
    oracle.cumulative_total + ((oracle.last_price as u256) * (elapsed as u256))
}

/// Backfill oracle with conditional-period cumulative after proposal ends
public fun backfill_from_conditional(
    oracle: &mut SimpleTWAP,
    proposal_start: u64,
    proposal_end: u64,
    period_cumulative: u256,
    period_final_price: u128,
) {
    assert!(proposal_end > proposal_start, EInvalidBackfill);
    assert!(proposal_start == oracle.last_update, EInvalidBackfill);
    assert!(period_final_price > 0, EInvalidBackfill);

    oracle.cumulative_total = oracle.cumulative_total + period_cumulative;

    // Calculate number of windows spanned by backfill period
    let backfill_duration = proposal_end - proposal_start;
    let num_windows = backfill_duration / oracle.window_size_ms;

    // Apply capping logic to prevent security bypass
    if (num_windows > 0) {
        // Calculate FIXED cap for this backfill (% of current TWAP)
        let max_step_u256 =
            (oracle.last_window_twap as u256) *
            (oracle.max_movement_ppm as u256) / (PPM_DENOMINATOR as u256);
        assert!(max_step_u256 <= (std::u128::max_value!() as u256), EOverflow);
        let max_step = (max_step_u256 as u128);

        // Calculate total gap
        let (total_gap, going_up) = if (period_final_price > oracle.last_window_twap) {
            (period_final_price - oracle.last_window_twap, true)
        } else {
            (oracle.last_window_twap - period_final_price, false)
        };

        // Calculate total movement (capped by num_windows √ó max_step)
        let max_total_movement = if (max_step > 0 && num_windows > 0) {
            let max_total_u256 = (max_step as u256) * (num_windows as u256);
            if (max_total_u256 > (std::u128::max_value!() as u256)) {
                std::u128::max_value!()
            } else {
                (max_total_u256 as u128)
            }
        } else {
            0
        };

        let actual_movement = if (total_gap > max_total_movement) {
            max_total_movement
        } else {
            total_gap
        };

        // Apply capped movement
        oracle.last_window_twap = if (going_up) {
            oracle.last_window_twap + actual_movement
        } else {
            oracle.last_window_twap - actual_movement
        };
    };
    // else: backfill duration < window_size, keep current TWAP

    // Reset window starting at proposal end
    oracle.window_start = proposal_end;
    oracle.cumulative_price = 0;
    oracle.last_update = proposal_end;
    oracle.last_price = period_final_price;

    maybe_commit_checkpoint(oracle, proposal_end);
}

/// Attempt to commit a long-window checkpoint if interval elapsed
public fun try_commit_checkpoint(oracle: &mut SimpleTWAP, clock: &Clock): bool {
    let now = clock.timestamp_ms();
    if (now >= oracle.last_checkpoint_at + CHECKPOINT_INTERVAL_MS) {
        record_checkpoint(oracle, now);
        true
    } else {
        false
    }
}

/// Force a checkpoint regardless of interval (e.g., low-activity periods)
public fun force_commit_checkpoint(oracle: &mut SimpleTWAP, clock: &Clock) {
    let now = clock.timestamp_ms();
    if (now > oracle.last_checkpoint_at) {
        record_checkpoint(oracle, now);
    }
}

/// Get long-window TWAP using checkpoints.
/// Returns None if not enough history (no checkpoint older than window_ms)
public fun get_window_twap(
    oracle: &SimpleTWAP,
    window_ms: u64,
    clock: &Clock,
): option::Option<u128> {
    let now = clock.timestamp_ms();
    if (now <= window_ms) {
        return option::none()
    };

    let target = now - window_ms;
    let len = vector::length(&oracle.checkpoints);
    if (len == 0) {
        return option::none()
    };

    let mut idx_opt = option::none();
    let mut i = len;
    while (i > 0) {
        i = i - 1;
        let cp = vector::borrow(&oracle.checkpoints, i);
        if (cp.timestamp <= target) {
            idx_opt = option::some(i);
            break;
        };
    };

    if (option::is_none(&idx_opt)) {
        return option::none()
    };

    let idx = option::destroy_some(idx_opt);
    let cp = vector::borrow(&oracle.checkpoints, idx);
    let start_ts = cp.timestamp;
    let start_cumulative = cp.cumulative;

    let duration = now - start_ts;
    if (duration == 0) {
        return option::none()
    };

    let current_cumulative = projected_cumulative_arithmetic_to(oracle, now);
    let diff = current_cumulative - start_cumulative;
    let avg_u256 = diff / (duration as u256);
    assert!(avg_u256 <= (std::u128::max_value!() as u256), EOverflow);

    option::some(avg_u256 as u128)
}

/// Convenience wrapper for 90-day TWAP (returns None if insufficient history)
public fun get_ninety_day_twap(oracle: &SimpleTWAP, clock: &Clock): option::Option<u128> {
    get_window_twap(oracle, NINETY_DAYS_MS, clock)
}

/// Find checkpoint at or before target timestamp.
/// Returns None if no checkpoint exists before target.
public fun checkpoint_at_or_before(
    oracle: &SimpleTWAP,
    target_timestamp: u64,
): option::Option<Checkpoint> {
    let len = vector::length(&oracle.checkpoints);
    if (len == 0) {
        return option::none()
    };

    let mut i = len;
    while (i > 0) {
        i = i - 1;
        let cp = vector::borrow(&oracle.checkpoints, i);
        if (cp.timestamp <= target_timestamp) {
            return option::some(*cp)
        };
    };

    option::none()
}

// ============================================================================
// Internal Helpers
// ============================================================================

fun maybe_commit_checkpoint(oracle: &mut SimpleTWAP, now: u64) {
    if (now >= oracle.last_checkpoint_at + CHECKPOINT_INTERVAL_MS) {
        record_checkpoint(oracle, now);
    }
}

fun record_checkpoint(oracle: &mut SimpleTWAP, timestamp: u64) {
    let checkpoint = Checkpoint { timestamp, cumulative: oracle.cumulative_total };

    if (vector::length(&oracle.checkpoints) >= MAX_CHECKPOINTS) {
        let _ = vector::remove(&mut oracle.checkpoints, 0);
    };

    vector::push_back(&mut oracle.checkpoints, checkpoint);
    oracle.last_checkpoint_at = timestamp;
}

// ============================================================================
// Test Helpers
// ============================================================================

#[test_only]
public fun destroy_for_testing(oracle: SimpleTWAP) {
    let SimpleTWAP {
        last_window_twap: _,
        cumulative_price: _,
        window_start: _,
        last_update: _,
        window_size_ms: _,
        max_movement_ppm: _,
        initialized: _,
        cumulative_total: _,
        last_price: _,
        initialized_at: _,
        checkpoints: _,
        last_checkpoint_at: _,
    } = oracle;
}

#[test_only]
public fun get_cumulative_price(oracle: &SimpleTWAP): u256 {
    oracle.cumulative_price
}

#[test_only]
public fun get_window_start(oracle: &SimpleTWAP): u64 {
    oracle.window_start
}

#[test_only]
public fun get_last_update(oracle: &SimpleTWAP): u64 {
    oracle.last_update
}

#[test_only]
public fun get_cumulative_total(oracle: &SimpleTWAP): u256 {
    oracle.cumulative_total
}

#[test_only]
public fun get_initialized_at(oracle: &SimpleTWAP): u64 {
    oracle.initialized_at
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

module futarchy_markets_primitives::conditional_amm;

use futarchy_markets_primitives::futarchy_twap_oracle::{Self, Oracle};
use futarchy_one_shot_utils::constants;
use futarchy_one_shot_utils::math;
use std::u64;
use sui::balance::{Self, Balance};
use sui::clock::Clock;
use sui::event;
use sui::object::{Self, ID, UID};
use sui::sui::SUI;
use sui::tx_context::TxContext;

// === Introduction ===
// This is a Uniswap V2-style XY=K AMM implementation for futarchy prediction markets.
//
// === Live-Flow Model Architecture ===
// This AMM is part of the "live-flow" liquidity model which allows dynamic liquidity
// management even while proposals are active. Key features:
//
// 1. **No Liquidity Locking**: Unlike traditional prediction markets, liquidity providers
//    can add or remove liquidity at any time, even during active proposals.
//
// 2. **Conditional Token Pools**: Each AMM pool trades conditional tokens (not spot tokens)
//    for a specific outcome. This allows the spot pool to remain liquid.
//
// 3. **Proportional Liquidity**: When LPs add/remove from the spot pool during active
//    proposals, liquidity is proportionally distributed/collected across all outcome AMMs.
//
// 4. **LP Token Architecture**: Each AMM pool has its own LP token type, but in the live-flow
//    model, these are managed internally. LPs only receive spot pool LP tokens.
//
// The flow works as follows:
// - Add liquidity: Spot tokens ‚Üí Mint conditional tokens ‚Üí Distribute to AMMs
// - Remove liquidity: Collect from AMMs ‚Üí Redeem conditional tokens ‚Üí Return spot tokens

// === Errors ===
const ELowLiquidity: u64 = 0; // Pool liquidity below minimum threshold
const EPoolEmpty: u64 = 1; // Attempting to swap/remove from empty pool
const EExcessiveSlippage: u64 = 2; // Output amount less than minimum specified
const EDivByZero: u64 = 3; // Division by zero in calculations
const EZeroLiquidity: u64 = 4; // Pool has zero liquidity
const EPriceTooHigh: u64 = 5; // Price exceeds maximum allowed value
const EZeroAmount: u64 = 6; // Input amount is zero
const EMarketIdMismatch: u64 = 7; // Market ID doesn't match expected value
const EInsufficientLPTokens: u64 = 8; // Not enough LP tokens to burn
const EInvalidTokenType: u64 = 9; // Wrong conditional token type provided
const EOverflow: u64 = 10; // Arithmetic overflow detected
const EInvalidFeeRate: u64 = 11; // Fee rate is invalid (e.g., >= 100%)
const EKInvariantViolation: u64 = 12; // K-invariant violation (guards constant-product invariant)
const EImbalancedLiquidity: u64 = 13; // Liquidity deposit is too imbalanced (>1% difference)

// === Constants ===
const FEE_SCALE: u64 = 10000;
const DEFAULT_FEE: u64 = 30; // 0.3%
const MINIMUM_LIQUIDITY: u128 = 1000;
// Other constants moved to constants module

// === Structs ===

public struct LiquidityPool has key, store {
    id: UID,
    market_id: ID,
    outcome_idx: u8,
    asset_reserve: u64,
    stable_reserve: u64,
    fee_percent: u64,
    oracle: Oracle, // Futarchy oracle (for determining winner, internal use)
    protocol_fees_asset: u64, // Track accumulated asset token fees
    protocol_fees_stable: u64, // Track accumulated stable token fees
    lp_supply: u64, // Track total LP shares for this pool
    // Bucket tracking for LP withdrawal system
    // LIVE: Came from spot.LIVE via quantum split (will recombine to spot.LIVE)
    // TRANSITIONING: Came from spot.TRANSITIONING via quantum split (will recombine to spot.WITHDRAW_ONLY)
    // Note: Conditionals don't have WITHDRAW_ONLY - that only exists in spot after recombination
    asset_live: u64,
    asset_transitioning: u64,
    stable_live: u64,
    stable_transitioning: u64,
    lp_live: u64,
    lp_transitioning: u64,
}

// === Events ===
public struct SwapEvent has copy, drop {
    market_id: ID,
    outcome: u8,
    is_buy: bool,
    amount_in: u64,
    amount_out: u64,
    price_impact: u128,
    price: u128,
    sender: address,
    asset_reserve: u64,
    stable_reserve: u64,
    timestamp: u64,
}

public struct LiquidityAdded has copy, drop {
    market_id: ID,
    outcome: u8,
    asset_amount: u64,
    stable_amount: u64,
    lp_amount: u64,
    sender: address,
    timestamp: u64,
}

public struct LiquidityRemoved has copy, drop {
    market_id: ID,
    outcome: u8,
    asset_amount: u64,
    stable_amount: u64,
    lp_amount: u64,
    sender: address,
    timestamp: u64,
}

// === Public Functions ===
public fun new_pool(
    market_id: ID,
    outcome_idx: u8,
    fee_percent: u64,
    initial_asset: u64,
    initial_stable: u64,
    twap_initial_observation: u128,
    twap_start_delay: u64,
    twap_step_max: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): LiquidityPool {
    assert!(initial_asset > 0 && initial_stable > 0, EZeroAmount);
    let k = math::mul_div_to_128(initial_asset, initial_stable, 1);
    assert!(k >= MINIMUM_LIQUIDITY, ELowLiquidity);
    assert!(fee_percent <= constants::max_amm_fee_bps(), EInvalidFeeRate);

    // Use twap_initial_observation for BOTH oracles to ensure consistency
    let initial_price = twap_initial_observation;

    check_price_under_max(initial_price);

    // Initialize futarchy oracle (for determining winner)
    let oracle = futarchy_twap_oracle::new_oracle(
        initial_price,
        twap_start_delay,
        twap_step_max,
        ctx,
    );

    // Create pool object
    let pool = LiquidityPool {
        id: object::new(ctx),
        market_id,
        outcome_idx,
        asset_reserve: initial_asset,
        stable_reserve: initial_stable,
        fee_percent,
        oracle,
        protocol_fees_asset: 0,
        protocol_fees_stable: 0,
        lp_supply: 0, // Start at 0 so first provider logic works correctly
        // Initialize all liquidity in LIVE bucket (from quantum split)
        asset_live: initial_asset,
        asset_transitioning: 0,
        stable_live: initial_stable,
        stable_transitioning: 0,
        lp_live: 0, // Will be set when LP is added
        lp_transitioning: 0,
    };

    pool
}

// === Core Swap Functions ===
// Note: These functions take generic references to allow inline arbitrage
// without creating circular dependencies between spot_amm and conditional_amm

public fun swap_asset_to_stable(
    pool: &mut LiquidityPool,
    market_id: ID,
    amount_in: u64,
    min_amount_out: u64,
    clock: &Clock,
    ctx: &TxContext,
): u64 {
    assert!(pool.market_id == market_id, EMarketIdMismatch);
    assert!(amount_in > 0, EZeroAmount);

    // K-GUARD: Capture reserves before swap to validate constant-product invariant
    // WHY: LP fees stay in pool, so k must GROW. Catches fee accounting bugs.
    let k_before = (pool.asset_reserve as u128) * (pool.stable_reserve as u128);

    // When selling outcome tokens (asset -> stable):
    // STANDARD UNISWAP V2 FEE MODEL: Take fee from INPUT (asset token)
    // 1. Calculate the fee from the input amount (amount_in).
    // 2. The actual amount used for the swap (amount_in_after_fee) is the original input minus the fee.
    // 3. Split the total fee: 80% for LPs (lp_share), 20% for the protocol (protocol_share).
    // 4. `protocol_share` is moved to `pool.protocol_fees_asset` (fee in ASSET token).
    // 5. `amount_in_after_fee` is used to calculate the swap output.
    // 6. The pool's asset reserve increases by `amount_in_after_fee + lp_share`, growing `k`.
    let total_fee = calculate_fee(amount_in, pool.fee_percent);
    let lp_share = math::mul_div_to_64(
        total_fee,
        constants::conditional_lp_fee_share_bps(),
        constants::total_fee_bps(),
    );
    let protocol_share = total_fee - lp_share;

    // Amount used for the swap calculation (after removing fees)
    let amount_in_after_fee = amount_in - total_fee;

    // Calculate output based on amount after fee
    let amount_out = calculate_output(
        amount_in_after_fee,
        pool.asset_reserve,
        pool.stable_reserve,
    );

    // Send protocol's share to the fee collector (asset token fee)
    pool.protocol_fees_asset = pool.protocol_fees_asset + protocol_share;

    assert!(amount_out >= min_amount_out, EExcessiveSlippage);
    assert!(amount_out < pool.stable_reserve, EPoolEmpty);

    let price_impact = calculate_price_impact(
        amount_in_after_fee,
        pool.asset_reserve,
        amount_out,
        pool.stable_reserve,
    );

    // Capture previous reserve state before the update
    let old_asset = pool.asset_reserve;
    let old_stable = pool.stable_reserve;

    let timestamp = clock.timestamp_ms();
    let old_price = math::mul_div_to_128(old_stable, constants::price_precision_scale(), old_asset);
    // Oracle observation is recorded using the reserves *before* the swap.
    // This ensures that the TWAP accurately reflects the price at the beginning of the swap.
    write_observation(
        &mut pool.oracle,
        timestamp,
        old_price,
    );

    // Update reserves. The amount added to the asset reserve is the portion used for the swap
    // PLUS the LP share of the fee. The protocol share was already removed.
    let new_asset_reserve = pool.asset_reserve + amount_in_after_fee + lp_share;
    assert!(new_asset_reserve >= pool.asset_reserve, EOverflow);

    pool.asset_reserve = new_asset_reserve;
    pool.stable_reserve = pool.stable_reserve - amount_out;

    // K-GUARD: Validate k increased (LP fees stay in pool, so k must grow)
    // Formula: (asset + amount_in_after_fee + lp_share) * (stable - amount_out) >= asset * stable
    let k_after = (pool.asset_reserve as u128) * (pool.stable_reserve as u128);
    assert!(k_after >= k_before, EKInvariantViolation);

    let current_price = get_current_price(pool);
    check_price_under_max(current_price);

    event::emit(SwapEvent {
        market_id: pool.market_id,
        outcome: pool.outcome_idx,
        is_buy: false,
        amount_in,
        amount_out, // Amount after fee for event logging
        price_impact,
        price: current_price,
        sender: ctx.sender(),
        asset_reserve: pool.asset_reserve,
        stable_reserve: pool.stable_reserve,
        timestamp,
    });

    amount_out
}

// Modified swap_asset_to_stable (selling outcome tokens)
public fun swap_stable_to_asset(
    pool: &mut LiquidityPool,
    market_id: ID,
    amount_in: u64,
    min_amount_out: u64,
    clock: &Clock,
    ctx: &TxContext,
): u64 {
    assert!(pool.market_id == market_id, EMarketIdMismatch);
    assert!(amount_in > 0, EZeroAmount);

    // K-GUARD: Capture reserves before swap to validate constant-product invariant
    // WHY: LP fees stay in pool, so k must GROW. Catches fee accounting bugs.
    let k_before = (pool.asset_reserve as u128) * (pool.stable_reserve as u128);

    // When buying outcome tokens (stable -> asset):
    // STANDARD UNISWAP V2 FEE MODEL: Take fee from INPUT (stable token)
    // 1. Calculate the fee from the input amount (amount_in).
    // 2. The actual amount used for the swap (amount_in_after_fee) is the original input minus the fee.
    // 3. Split the total fee: 80% for LPs (lp_share), 20% for the protocol (protocol_share).
    // 4. `protocol_share` is moved to `pool.protocol_fees_stable` (fee in STABLE token).
    // 5. `amount_in_after_fee` is used to calculate the swap output.
    // 6. The pool's stable reserve increases by `amount_in_after_fee + lp_share`, growing `k`.
    let total_fee = calculate_fee(amount_in, pool.fee_percent);
    let lp_share = math::mul_div_to_64(
        total_fee,
        constants::conditional_lp_fee_share_bps(),
        constants::total_fee_bps(),
    );
    let protocol_share = total_fee - lp_share;

    // Amount used for the swap calculation
    let amount_in_after_fee = amount_in - total_fee;

    // Send protocol's share to the fee collector (stable token fee)
    pool.protocol_fees_stable = pool.protocol_fees_stable + protocol_share;

    // Calculate output based on amount after fee
    let amount_out = calculate_output(
        amount_in_after_fee,
        pool.stable_reserve,
        pool.asset_reserve,
    );

    assert!(amount_out >= min_amount_out, EExcessiveSlippage);
    assert!(amount_out < pool.asset_reserve, EPoolEmpty);

    let price_impact = calculate_price_impact(
        amount_in_after_fee,
        pool.stable_reserve,
        amount_out,
        pool.asset_reserve,
    );

    // Capture previous reserve state before the update
    let old_asset = pool.asset_reserve;
    let old_stable = pool.stable_reserve;

    let timestamp = clock.timestamp_ms();
    let old_price = math::mul_div_to_128(old_stable, constants::price_precision_scale(), old_asset);
    // Oracle observation is recorded using the reserves *before* the swap.
    // This ensures that the TWAP accurately reflects the price at the beginning of the swap.
    write_observation(
        &mut pool.oracle,
        timestamp,
        old_price,
    );

    // Update reserves. The amount added to the stable reserve is the portion used for the swap
    // PLUS the LP share of the fee. The protocol share was already removed.
    let new_stable_reserve = pool.stable_reserve + amount_in_after_fee + lp_share;
    assert!(new_stable_reserve >= pool.stable_reserve, EOverflow);

    pool.stable_reserve = new_stable_reserve;
    pool.asset_reserve = pool.asset_reserve - amount_out;

    // K-GUARD: Validate k increased (LP fees stay in pool, so k must grow)
    // Formula: (asset - amount_out) * (stable + amount_in_after_fee + lp_share) >= asset * stable
    let k_after = (pool.asset_reserve as u128) * (pool.stable_reserve as u128);
    assert!(k_after >= k_before, EKInvariantViolation);

    let current_price = get_current_price(pool);
    check_price_under_max(current_price);

    event::emit(SwapEvent {
        market_id: pool.market_id,
        outcome: pool.outcome_idx,
        is_buy: true,
        amount_in, // Original amount for event logging
        amount_out,
        price_impact,
        price: current_price,
        sender: ctx.sender(),
        asset_reserve: pool.asset_reserve,
        stable_reserve: pool.stable_reserve,
        timestamp,
    });

    amount_out
}

// === Liquidity Functions ===

/// Add liquidity proportionally to the AMM pool
/// Only handles calculations and reserve updates, no token operations
/// Returns the amount of LP tokens to mint
public fun add_liquidity_proportional(
    pool: &mut LiquidityPool,
    asset_amount: u64,
    stable_amount: u64,
    min_lp_out: u64,
    clock: &Clock,
    ctx: &TxContext,
): u64 {
    assert!(asset_amount > 0, EZeroAmount);
    assert!(stable_amount > 0, EZeroAmount);

    // Calculate LP tokens to mint based on current pool state
    let (lp_to_mint, new_lp_supply) = if (pool.lp_supply == 0) {
        // First liquidity provider - bootstrap the pool
        let k_squared = math::mul_div_to_128(asset_amount, stable_amount, 1);
        let k = (k_squared.sqrt() as u64);
        assert!(k > (MINIMUM_LIQUIDITY as u64), ELowLiquidity);
        // For the first liquidity provider, a small amount of LP tokens (MINIMUM_LIQUIDITY)
        // is intentionally burned and locked in the pool. This is a standard practice in Uniswap V2
        // to prevent division-by-zero errors and to ensure that LP token prices are always well-defined.
        // This amount is accounted for in the `lp_supply` but is not redeemable.
        let locked = (MINIMUM_LIQUIDITY as u64);
        let minted = k - locked;
        // Return the minted amount and the resulting total supply
        (minted, k)
    } else {
        // Subsequent providers - mint proportionally
        let lp_from_asset = math::mul_div_to_64(asset_amount, pool.lp_supply, pool.asset_reserve);
        let lp_from_stable = math::mul_div_to_64(
            stable_amount,
            pool.lp_supply,
            pool.stable_reserve,
        );

        // SECURITY: Enforce balanced liquidity to prevent price manipulation attacks
        // Calculate the imbalance between asset and stable contributions
        let max_delta = if (lp_from_asset > lp_from_stable) {
            lp_from_asset - lp_from_stable
        } else {
            lp_from_stable - lp_from_asset
        };

        // Calculate average LP amount for tolerance check
        let avg = (lp_from_asset + lp_from_stable) / 2;

        // Enforce 1% maximum imbalance tolerance
        // This prevents attacks where depositing 10,000 asset + 1 stable crashes price
        // Example attack: 10,000 asset + 1 stable ‚Üí only 1 LP ‚Üí price drops 91%
        // With this check: Max allowed imbalance is avg/100 (1% of average contribution)
        assert!(max_delta <= avg / 100, EImbalancedLiquidity);

        // Use minimum to ensure proper ratio (after imbalance check passes)
        let minted = lp_from_asset.min(lp_from_stable);
        (minted, pool.lp_supply + minted)
    };

    // Slippage protection: ensure LP tokens minted meet minimum expectation
    assert!(lp_to_mint >= min_lp_out, EExcessiveSlippage);

    // K-GUARD: Capture k before adding liquidity
    // WHY: Adding liquidity MUST strictly increase k. If not, arithmetic bug or overflow.
    let k_before = (pool.asset_reserve as u128) * (pool.stable_reserve as u128);

    // Update reserves with overflow checks
    let new_asset_reserve = pool.asset_reserve + asset_amount;
    let new_stable_reserve = pool.stable_reserve + stable_amount;
    // Use the precomputed total supply

    // Check for overflow
    assert!(new_asset_reserve >= pool.asset_reserve, EOverflow);
    assert!(new_stable_reserve >= pool.stable_reserve, EOverflow);
    assert!(new_lp_supply >= pool.lp_supply, EOverflow);

    pool.asset_reserve = new_asset_reserve;
    pool.stable_reserve = new_stable_reserve;
    pool.lp_supply = new_lp_supply;

    // K-GUARD: Validate k strictly increased
    // Formula: (asset + asset_amount) * (stable + stable_amount) > asset * stable
    let k_after = (pool.asset_reserve as u128) * (pool.stable_reserve as u128);
    assert!(k_after > k_before, EKInvariantViolation);

    event::emit(LiquidityAdded {
        market_id: pool.market_id,
        outcome: pool.outcome_idx,
        asset_amount,
        stable_amount,
        lp_amount: lp_to_mint,
        sender: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });

    lp_to_mint
}

/// Remove liquidity proportionally from the AMM pool
/// Only handles calculations and reserve updates, no token operations
/// Returns the amounts of asset and stable tokens to mint
public fun remove_liquidity_proportional(
    pool: &mut LiquidityPool,
    lp_amount: u64,
    clock: &Clock,
    ctx: &TxContext,
): (u64, u64) {
    // Check for zero liquidity in the pool first to provide a more accurate error message
    assert!(pool.lp_supply > 0, EZeroLiquidity);
    assert!(lp_amount > 0, EZeroAmount);

    // K-GUARD: Capture k before removing liquidity
    // WHY: Removing liquidity MUST strictly decrease k (but stay ‚â• minimum).
    let k_before = (pool.asset_reserve as u128) * (pool.stable_reserve as u128);

    // Calculate proportional share to remove from this AMM
    let asset_to_remove = math::mul_div_to_64(lp_amount, pool.asset_reserve, pool.lp_supply);
    let stable_to_remove = math::mul_div_to_64(lp_amount, pool.stable_reserve, pool.lp_supply);

    // Ensure minimum liquidity remains
    assert!(pool.asset_reserve > asset_to_remove, EPoolEmpty);
    assert!(pool.stable_reserve > stable_to_remove, EPoolEmpty);
    assert!(pool.lp_supply > lp_amount, EInsufficientLPTokens);

    // Ensure remaining liquidity is above minimum threshold
    let remaining_asset = pool.asset_reserve - asset_to_remove;
    let remaining_stable = pool.stable_reserve - stable_to_remove;
    let remaining_k = math::mul_div_to_128(remaining_asset, remaining_stable, 1);
    assert!(remaining_k >= (MINIMUM_LIQUIDITY as u128), ELowLiquidity);

    // Update pool state (underflow already checked by earlier asserts)
    pool.asset_reserve = pool.asset_reserve - asset_to_remove;
    pool.stable_reserve = pool.stable_reserve - stable_to_remove;
    pool.lp_supply = pool.lp_supply - lp_amount;

    // K-GUARD: Validate k strictly decreased but stays above minimum
    // Formula: (asset - asset_to_remove) * (stable - stable_to_remove) < asset * stable
    //          AND result >= MINIMUM_LIQUIDITY
    let k_after = (pool.asset_reserve as u128) * (pool.stable_reserve as u128);
    assert!(k_after < k_before, EKInvariantViolation); // Must decrease
    assert!(k_after >= (MINIMUM_LIQUIDITY as u128), ELowLiquidity); // But stay above min

    event::emit(LiquidityRemoved {
        market_id: pool.market_id,
        outcome: pool.outcome_idx,
        asset_amount: asset_to_remove,
        stable_amount: stable_to_remove,
        lp_amount,
        sender: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });

    (asset_to_remove, stable_to_remove)
}

public fun empty_all_amm_liquidity(pool: &mut LiquidityPool, _ctx: &mut TxContext): (u64, u64) {
    // Capture full reserves before zeroing them out
    let asset_amount_out = pool.asset_reserve;
    let stable_amount_out = pool.stable_reserve;

    pool.asset_reserve = 0;
    pool.stable_reserve = 0;

    // Reset LP accounting so the next quantum split reboots cleanly
    pool.lp_supply = 0;
    pool.asset_live = 0;
    pool.asset_transitioning = 0;
    pool.stable_live = 0;
    pool.stable_transitioning = 0;
    pool.lp_live = 0;
    pool.lp_transitioning = 0;

    (asset_amount_out, stable_amount_out)
}

// === Oracle Functions ===
// Update new_oracle to be simpler:
fun write_observation(oracle: &mut Oracle, timestamp: u64, price: u128) {
    oracle.write_observation(timestamp, price)
}

public fun get_oracle(pool: &LiquidityPool): &Oracle {
    &pool.oracle
}

// === View Functions ===

public fun get_reserves(pool: &LiquidityPool): (u64, u64) {
    (pool.asset_reserve, pool.stable_reserve)
}

public fun get_lp_supply(pool: &LiquidityPool): u64 {
    pool.lp_supply
}

/// Get bucket amounts for recombination
/// Returns (asset_live, asset_transitioning, stable_live, stable_transitioning, lp_live, lp_transitioning)
public fun get_bucket_amounts(pool: &LiquidityPool): (u64, u64, u64, u64, u64, u64) {
    (
        pool.asset_live,
        pool.asset_transitioning,
        pool.stable_live,
        pool.stable_transitioning,
        pool.lp_live,
        pool.lp_transitioning,
    )
}

/// Get pool fee in basis points
public fun get_fee_bps(pool: &LiquidityPool): u64 {
    pool.fee_percent
}

public fun get_price(pool: &LiquidityPool): u128 {
    pool.oracle.last_price()
}

public fun get_twap(pool: &mut LiquidityPool, clock: &Clock): u128 {
    update_twap_observation(pool, clock);
    pool.oracle.get_twap(clock)
}

public fun quote_swap_asset_to_stable(pool: &LiquidityPool, amount_in: u64): u64 {
    // Take fee from input (matching swap function)
    let total_fee = calculate_fee(amount_in, pool.fee_percent);
    let amount_in_after_fee = amount_in - total_fee;
    // Calculate output from after-fee amount
    calculate_output(
        amount_in_after_fee,
        pool.asset_reserve,
        pool.stable_reserve,
    )
}

public fun quote_swap_stable_to_asset(pool: &LiquidityPool, amount_in: u64): u64 {
    let amount_in_with_fee = amount_in - calculate_fee(amount_in, pool.fee_percent);
    calculate_output(
        amount_in_with_fee,
        pool.stable_reserve,
        pool.asset_reserve,
    )
}

// === Arbitrage Helper Functions ===

/// Feeless swap asset‚Üístable (for internal arbitrage only)
/// No fees charged to maximize arbitrage efficiency
///
/// AUDIT FIX: Now MUTATES reserves (Q3: swaps should always update state)
public(package) fun feeless_swap_asset_to_stable(pool: &mut LiquidityPool, amount_in: u64): u64 {
    assert!(amount_in > 0, EZeroAmount);
    assert!(pool.asset_reserve > 0 && pool.stable_reserve > 0, EPoolEmpty);

    // K-GUARD: Feeless swaps should preserve k EXACTLY (no fees = no k growth)
    // WHY: Validates arbitrage math is correct (used in executor's multi-pool swaps)
    let k_before = (pool.asset_reserve as u128) * (pool.stable_reserve as u128);

    // No fee for arbitrage swaps (fee-free constant product)
    let stable_out = calculate_output(
        amount_in,
        pool.asset_reserve,
        pool.stable_reserve,
    );
    assert!(stable_out < pool.stable_reserve, EPoolEmpty);

    // CRITICAL FIX: Update reserves! Any swap must mutate state.
    pool.asset_reserve = pool.asset_reserve + amount_in;
    pool.stable_reserve = pool.stable_reserve - stable_out;

    // K-GUARD: Validate k unchanged (feeless swap preserves k within rounding)
    // Formula: (asset + amount_in) * (stable - stable_out) ‚âà asset * stable
    // Allow tiny rounding tolerance (1 part in 10^6)
    let k_after = (pool.asset_reserve as u128) * (pool.stable_reserve as u128);
    let k_delta = if (k_after > k_before) { k_after - k_before } else { k_before - k_after };
    // 0.0001% tolerance (min 1 to prevent zero at low liquidity)
    let tolerance_calc = k_before / 1000000;
    let tolerance = if (tolerance_calc < 1) { 1 } else { tolerance_calc };
    assert!(k_delta <= tolerance, EKInvariantViolation);

    stable_out
}

/// Feeless swap stable‚Üíasset (for internal arbitrage only)
///
/// AUDIT FIX: Now MUTATES reserves (Q3: swaps should always update state)
public(package) fun feeless_swap_stable_to_asset(pool: &mut LiquidityPool, amount_in: u64): u64 {
    assert!(amount_in > 0, EZeroAmount);
    assert!(pool.asset_reserve > 0 && pool.stable_reserve > 0, EPoolEmpty);

    // K-GUARD: Feeless swaps should preserve k EXACTLY (no fees = no k growth)
    // WHY: Validates arbitrage math is correct (used in executor's multi-pool swaps)
    let k_before = (pool.asset_reserve as u128) * (pool.stable_reserve as u128);

    // No fee for arbitrage swaps
    let asset_out = calculate_output(
        amount_in,
        pool.stable_reserve,
        pool.asset_reserve,
    );
    assert!(asset_out < pool.asset_reserve, EPoolEmpty);

    // CRITICAL FIX: Update reserves! Any swap must mutate state.
    pool.stable_reserve = pool.stable_reserve + amount_in;
    pool.asset_reserve = pool.asset_reserve - asset_out;

    // K-GUARD: Validate k unchanged (feeless swap preserves k within rounding)
    // Formula: (asset - asset_out) * (stable + amount_in) ‚âà asset * stable
    // Allow tiny rounding tolerance (1 part in 10^6)
    let k_after = (pool.asset_reserve as u128) * (pool.stable_reserve as u128);
    let k_delta = if (k_after > k_before) { k_after - k_before } else { k_before - k_after };
    // 0.0001% tolerance (min 1 to prevent zero at low liquidity)
    let tolerance_calc = k_before / 1000000;
    let tolerance = if (tolerance_calc < 1) { 1 } else { tolerance_calc };
    assert!(k_delta <= tolerance, EKInvariantViolation);

    asset_out
}

/// Simulate asset‚Üístable swap without executing
/// Pure function for arbitrage optimization
///
/// STANDARD UNISWAP V2 FEE MODEL: Fee charged on INPUT (consistent with swap execution)
public fun simulate_swap_asset_to_stable(pool: &LiquidityPool, amount_in: u64): u64 {
    if (amount_in == 0) return 0;
    if (pool.asset_reserve == 0 || pool.stable_reserve == 0) return 0;

    // Take fee from input (matching swap function)
    let total_fee = calculate_fee(amount_in, pool.fee_percent);
    let amount_in_after_fee = if (amount_in > total_fee) {
        amount_in - total_fee
    } else {
        return 0
    };

    let stable_out = calculate_output(
        amount_in_after_fee,
        pool.asset_reserve,
        pool.stable_reserve,
    );

    if (stable_out >= pool.stable_reserve) return 0;

    stable_out
}

/// Simulate stable‚Üíasset swap without executing
public fun simulate_swap_stable_to_asset(pool: &LiquidityPool, amount_in: u64): u64 {
    if (amount_in == 0) return 0;
    if (pool.asset_reserve == 0 || pool.stable_reserve == 0) return 0;

    // Simulate with fee
    let total_fee = calculate_fee(amount_in, pool.fee_percent);
    let amount_in_after_fee = if (amount_in > total_fee) {
        amount_in - total_fee
    } else {
        return 0
    };

    let asset_out = calculate_output(
        amount_in_after_fee,
        pool.stable_reserve,
        pool.asset_reserve,
    );

    if (asset_out >= pool.asset_reserve) return 0;

    asset_out
}

fun calculate_price_impact(
    amount_in: u64,
    reserve_in: u64,
    amount_out: u64,
    reserve_out: u64,
): u128 {
    // Use u256 for intermediate calculations to prevent overflow
    let amount_in_256 = (amount_in as u256);
    let reserve_out_256 = (reserve_out as u256);
    let reserve_in_256 = (reserve_in as u256);

    // Calculate ideal output with u256 to prevent overflow
    let ideal_out_256 = (amount_in_256 * reserve_out_256) / reserve_in_256;
    assert!(ideal_out_256 <= (std::u128::max_value!() as u256), EOverflow);
    let ideal_out = (ideal_out_256 as u128);

    // The assert below ensures that `ideal_out` is always greater than or equal to `amount_out`.
    // This prevents underflow when calculating `ideal_out - (amount_out as u128)`.
    assert!(ideal_out >= (amount_out as u128), EOverflow); // Ensure no underflow
    math::mul_div_mixed(ideal_out - (amount_out as u128), FEE_SCALE, ideal_out)
}

// Update the LiquidityPool struct price calculation to use TWAP:
public fun get_current_price(pool: &LiquidityPool): u128 {
    assert!(pool.asset_reserve > 0 && pool.stable_reserve > 0, EZeroLiquidity);

    let price = math::mul_div_to_128(
        pool.stable_reserve,
        constants::price_precision_scale(),
        pool.asset_reserve,
    );

    price
}

public fun update_twap_observation(pool: &mut LiquidityPool, clock: &Clock) {
    let timestamp = clock.timestamp_ms();
    let current_price = get_current_price(pool);
    // Use the sum of reserves as a liquidity measure
    pool.oracle.write_observation(timestamp, current_price);
}

public fun set_oracle_start_time(pool: &mut LiquidityPool, market_id: ID, trading_start_time: u64) {
    assert!(get_ms_id(pool) == market_id, EMarketIdMismatch);
    pool.oracle.set_oracle_start_time(trading_start_time);
}

// === Private Functions ===
fun calculate_fee(amount: u64, fee_percent: u64): u64 {
    math::mul_div_to_64(amount, fee_percent, FEE_SCALE)
}

public fun calculate_output(amount_in_with_fee: u64, reserve_in: u64, reserve_out: u64): u64 {
    assert!(reserve_in > 0 && reserve_out > 0, EPoolEmpty);

    let denominator = reserve_in + amount_in_with_fee;
    assert!(denominator > 0, EDivByZero);
    let numerator = (amount_in_with_fee as u256) * (reserve_out as u256);
    let output = numerator / (denominator as u256);
    assert!(output <= (u64::max_value!() as u256), EOverflow);
    (output as u64)
}

public fun get_outcome_idx(pool: &LiquidityPool): u8 {
    pool.outcome_idx
}

public fun get_id(pool: &LiquidityPool): ID {
    pool.id.to_inner()
}

public fun get_k(pool: &LiquidityPool): u128 {
    math::mul_div_to_128(pool.asset_reserve, pool.stable_reserve, 1)
}

public fun check_price_under_max(price: u128) {
    let max_price = (0xFFFFFFFFFFFFFFFFu64 as u128) * (constants::price_precision_scale() as u128);
    assert!(price <= max_price, EPriceTooHigh)
}

/// Get accumulated protocol fees in asset token
public fun get_protocol_fees_asset(pool: &LiquidityPool): u64 {
    pool.protocol_fees_asset
}

/// Get accumulated protocol fees in stable token
public fun get_protocol_fees_stable(pool: &LiquidityPool): u64 {
    pool.protocol_fees_stable
}

/// DEPRECATED: Use get_protocol_fees_stable() instead
/// Returns stable fees for backward compatibility
public fun get_protocol_fees(pool: &LiquidityPool): u64 {
    pool.protocol_fees_stable
}

public fun get_ms_id(pool: &LiquidityPool): ID {
    pool.market_id
}

/// Reset both asset and stable protocol fees to zero
public fun reset_protocol_fees(pool: &mut LiquidityPool) {
    pool.protocol_fees_asset = 0;
    pool.protocol_fees_stable = 0;
}

// === Test Functions ===

#[test_only]
/// Test helper: wrapper for new_pool() with simplified signature
public fun new<AssetType, StableType>(
    fee_percent: u64,
    twap_start_delay: u64,
    twap_initial_observation: u128,
    twap_step_max: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): LiquidityPool {
    new_pool(
        object::id_from_address(@0x0), // market_id
        0, // outcome_idx
        fee_percent,
        1_000, // initial_asset
        1_000, // initial_stable
        twap_initial_observation,
        twap_start_delay,
        twap_step_max,
        clock,
        ctx,
    )
}

#[test_only]
/// Test helper: destroy a coin
public fun burn_for_testing<T>(coin: sui::coin::Coin<T>) {
    sui::test_utils::destroy(coin);
}

#[test_only]
/// Test helper: alias for get_lp_supply()
public fun lp_supply(pool: &LiquidityPool): u64 {
    get_lp_supply(pool)
}

#[test_only]
public fun create_test_pool(
    market_id: ID,
    outcome_idx: u8,
    fee_percent: u64,
    asset_reserve: u64,
    stable_reserve: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): LiquidityPool {
    let initial_price = math::mul_div_to_128(stable_reserve, 1_000_000_000_000, asset_reserve);

    let mut oracle_obj = futarchy_twap_oracle::new_oracle(
        initial_price,
        0, // Use 0 which is always a valid multiple of TWAP_PRICE_CAP_WINDOW
        1_000,
        ctx,
    );

    // Initialize oracle market start time for tests
    oracle_obj.set_oracle_start_time(clock.timestamp_ms());

    LiquidityPool {
        id: object::new(ctx),
        market_id,
        outcome_idx,
        asset_reserve,
        stable_reserve,
        fee_percent,
        oracle: oracle_obj,
        protocol_fees_asset: 0,
        protocol_fees_stable: 0,
        lp_supply: (MINIMUM_LIQUIDITY as u64),
        // Initialize all liquidity in LIVE bucket for testing
        asset_live: asset_reserve,
        asset_transitioning: 0,
        stable_live: stable_reserve,
        stable_transitioning: 0,
        lp_live: (MINIMUM_LIQUIDITY as u64),
        lp_transitioning: 0,
    }
}

#[test_only]
/// Create a pool with initial liquidity for testing arbitrage_math
public fun create_pool_for_testing(
    asset_amount: u64,
    stable_amount: u64,
    fee_bps: u64,
    ctx: &mut TxContext,
): LiquidityPool {
    use sui::clock;

    // Create a minimal oracle and simple_twap for testing
    let clock = clock::create_for_testing(ctx);
    let initial_price = if (asset_amount > 0 && stable_amount > 0) {
        ((stable_amount as u128) * 1_000_000_000) / (asset_amount as u128)
    } else {
        1_000_000_000
    };

    let oracle_obj = futarchy_twap_oracle::new_oracle(
        initial_price,
        0, // twap_start_delay - Use 0 which is always a valid multiple of TWAP_PRICE_CAP_WINDOW
        100, // twap_step_max (ppm)
        ctx,
    );

    clock::destroy_for_testing(clock);

    LiquidityPool {
        id: object::new(ctx),
        market_id: object::id_from_address(@0x0),
        outcome_idx: 0,
        asset_reserve: asset_amount,
        stable_reserve: stable_amount,
        fee_percent: fee_bps,
        oracle: oracle_obj,
        protocol_fees_asset: 0,
        protocol_fees_stable: 0,
        lp_supply: (MINIMUM_LIQUIDITY as u64),
        // Initialize all liquidity in LIVE bucket for testing
        asset_live: asset_amount,
        asset_transitioning: 0,
        stable_live: stable_amount,
        stable_transitioning: 0,
        lp_live: (MINIMUM_LIQUIDITY as u64),
        lp_transitioning: 0,
    }
}

#[test_only]
public fun destroy_for_testing(pool: LiquidityPool) {
    let LiquidityPool {
        id,
        market_id: _,
        outcome_idx: _,
        asset_reserve: _,
        stable_reserve: _,
        fee_percent: _,
        oracle,
        protocol_fees_asset: _,
        protocol_fees_stable: _,
        lp_supply: _,
        asset_live: _,
        asset_transitioning: _,
        stable_live: _,
        stable_transitioning: _,
        lp_live: _,
        lp_transitioning: _,
    } = pool;
    id.delete();
    oracle.destroy_for_testing();
}

#[test_only]
/// Add liquidity to a pool for testing (simplified version)
/// Takes coins directly, extracts values, updates reserves, and destroys coins
public fun add_liquidity_for_testing<AssetType, StableType>(
    pool: &mut LiquidityPool,
    asset_coin: sui::coin::Coin<AssetType>,
    stable_coin: sui::coin::Coin<StableType>,
    _fee_bps: u16, // Not used in test helper, kept for API compatibility
    _ctx: &mut TxContext,
) {
    // Extract amounts from coins
    let asset_amount = asset_coin.value();
    let stable_amount = stable_coin.value();

    // Destroy test coins (we just want to update reserves)
    sui::test_utils::destroy(asset_coin);
    sui::test_utils::destroy(stable_coin);

    // Update reserves directly (simplified for testing)
    pool.asset_reserve = pool.asset_reserve + asset_amount;
    pool.stable_reserve = pool.stable_reserve + stable_amount;

    // Update LP supply proportionally (simplified calculation for testing)
    if (pool.lp_supply == 0) {
        // First liquidity provider
        let k_squared = math::mul_div_to_128(asset_amount, stable_amount, 1);
        let k = (k_squared.sqrt() as u64);
        pool.lp_supply = k;
    } else {
        // Subsequent providers - mint proportionally
        let lp_from_asset = math::mul_div_to_64(
            asset_amount,
            pool.lp_supply,
            pool.asset_reserve - asset_amount,
        );
        let lp_from_stable = math::mul_div_to_64(
            stable_amount,
            pool.lp_supply,
            pool.stable_reserve - stable_amount,
        );
        let lp_to_mint = if (lp_from_asset < lp_from_stable) { lp_from_asset } else {
            lp_from_stable
        };
        pool.lp_supply = pool.lp_supply + lp_to_mint;
    };
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

module futarchy_markets_primitives::market_state;

use futarchy_markets_primitives::conditional_amm::LiquidityPool;
use std::string::String;
use sui::clock::Clock;
use sui::event;

// === Introduction ===
// This module tracks proposal life cycle and acts as a source of truth for proposal state

// === Errors ===
const ETradingAlreadyStarted: u64 = 0;
const EOutcomeOutOfBounds: u64 = 1;
const EAlreadyFinalized: u64 = 2;
const ETradingAlreadyEnded: u64 = 3;
const ETradingNotEnded: u64 = 4;
const ENotFinalized: u64 = 5;
const ETradingNotStarted: u64 = 6;
const EInvalidDuration: u64 = 7;

// === Constants ===
const MAX_TRADING_DURATION_MS: u64 = 30 * 24 * 60 * 60 * 1000; // 30 days

// === Structs ===
public struct MarketStatus has copy, drop, store {
    trading_started: bool,
    trading_ended: bool,
    finalized: bool,
}

public struct MarketState has key, store {
    id: UID,
    market_id: ID,
    dao_id: ID,
    outcome_count: u64,
    outcome_messages: vector<String>,
    // Market infrastructure - AMM pools for price discovery
    amm_pools: Option<vector<LiquidityPool>>,
    // Lifecycle state
    status: MarketStatus,
    winning_outcome: Option<u64>,
    creation_time: u64,
    trading_start: u64,
    trading_end: Option<u64>,
    finalization_time: Option<u64>,
}

// === Events ===
public struct TradingStartedEvent has copy, drop {
    market_id: ID,
    start_time: u64,
}

public struct TradingEndedEvent has copy, drop {
    market_id: ID,
    timestamp_ms: u64,
}

public struct MarketStateFinalizedEvent has copy, drop {
    market_id: ID,
    winning_outcome: u64,
    timestamp_ms: u64,
}

// === Public Package Functions ===
public fun new(
    market_id: ID,
    dao_id: ID,
    outcome_count: u64,
    outcome_messages: vector<String>,
    clock: &Clock,
    ctx: &mut TxContext,
): MarketState {
    let timestamp = clock.timestamp_ms();

    MarketState {
        id: object::new(ctx),
        market_id,
        dao_id,
        outcome_count,
        outcome_messages,
        amm_pools: option::none(), // Pools added later during market initialization
        status: MarketStatus {
            trading_started: false,
            trading_ended: false,
            finalized: false,
        },
        winning_outcome: option::none(),
        creation_time: timestamp,
        trading_start: 0,
        trading_end: option::none(),
        finalization_time: option::none(),
    }
}

public fun start_trading(state: &mut MarketState, duration_ms: u64, clock: &Clock) {
    assert!(!state.status.trading_started, ETradingAlreadyStarted);
    assert!(duration_ms > 0 && duration_ms <= MAX_TRADING_DURATION_MS, EInvalidDuration);

    let start_time = clock.timestamp_ms();
    let end_time = start_time + duration_ms;

    state.status.trading_started = true;
    state.trading_start = start_time;
    state.trading_end = option::some(end_time);

    event::emit(TradingStartedEvent {
        market_id: state.market_id,
        start_time,
    });
}

// === Public Functions ===
public fun assert_trading_active(state: &MarketState) {
    assert!(state.status.trading_started, ETradingNotStarted);
    assert!(!state.status.trading_ended, ETradingAlreadyEnded);
}

public fun assert_in_trading_or_pre_trading(state: &MarketState) {
    assert!(!state.status.trading_ended, ETradingAlreadyEnded);
    assert!(!state.status.finalized, EAlreadyFinalized);
}

public fun end_trading(state: &mut MarketState, clock: &Clock) {
    assert!(state.status.trading_started, ETradingNotStarted);
    assert!(!state.status.trading_ended, ETradingAlreadyEnded);

    let timestamp = clock.timestamp_ms();
    state.status.trading_ended = true;

    event::emit(TradingEndedEvent {
        market_id: state.market_id,
        timestamp_ms: timestamp,
    });
}

public fun finalize(state: &mut MarketState, winner: u64, clock: &Clock) {
    assert!(state.status.trading_ended, ETradingNotEnded);
    assert!(!state.status.finalized, EAlreadyFinalized);
    assert!(winner < state.outcome_count, EOutcomeOutOfBounds);

    let timestamp = clock.timestamp_ms();
    state.status.finalized = true;
    state.winning_outcome = option::some(winner);
    state.finalization_time = option::some(timestamp);

    event::emit(MarketStateFinalizedEvent {
        market_id: state.market_id,
        winning_outcome: winner,
        timestamp_ms: timestamp,
    });
}

// === Pool Management Functions ===

/// Initialize AMM pools for the market
/// Called once when market transitions to TRADING state
public fun set_amm_pools(state: &mut MarketState, pools: vector<LiquidityPool>) {
    assert!(state.amm_pools.is_none(), 0); // Pools can only be set once
    option::fill(&mut state.amm_pools, pools);
}

/// Check if market has AMM pools initialized
public fun has_amm_pools(state: &MarketState): bool {
    state.amm_pools.is_some()
}

/// Borrow AMM pools immutably
public fun borrow_amm_pools(state: &MarketState): &vector<LiquidityPool> {
    state.amm_pools.borrow()
}

/// Borrow AMM pools mutably
public fun borrow_amm_pools_mut(state: &mut MarketState): &mut vector<LiquidityPool> {
    state.amm_pools.borrow_mut()
}

/// Get a specific pool by outcome index
public fun get_pool_by_outcome(state: &MarketState, outcome_idx: u8): &LiquidityPool {
    let pools = state.amm_pools.borrow();
    &pools[(outcome_idx as u64)]
}

/// Get a specific pool mutably by outcome index
public fun get_pool_mut_by_outcome(state: &mut MarketState, outcome_idx: u8): &mut LiquidityPool {
    let pools = state.amm_pools.borrow_mut();
    &mut pools[(outcome_idx as u64)]
}

/// Get all pools (for cleanup/migration)
public(package) fun extract_amm_pools(state: &mut MarketState): vector<LiquidityPool> {
    state.amm_pools.extract()
}

// === Assertion Functions ===
public fun assert_market_finalized(state: &MarketState) {
    assert!(state.status.finalized, ENotFinalized);
}

public fun assert_not_finalized(state: &MarketState) {
    assert!(!state.status.finalized, EAlreadyFinalized);
}

public fun validate_outcome(state: &MarketState, outcome: u64) {
    assert!(outcome < state.outcome_count, EOutcomeOutOfBounds);
}

// === View Functions (Getters) ===
public fun market_id(state: &MarketState): ID {
    state.market_id
}

public fun outcome_count(state: &MarketState): u64 {
    state.outcome_count
}

// === View Functions (Predicates) ===
public fun is_trading_active(state: &MarketState): bool {
    state.status.trading_started && !state.status.trading_ended
}

public fun is_finalized(state: &MarketState): bool {
    state.status.finalized
}

public fun dao_id(state: &MarketState): ID {
    state.dao_id
}

public fun get_winning_outcome(state: &MarketState): u64 {
    use std::option;
    assert!(state.status.finalized, ENotFinalized);
    let opt_ref = &state.winning_outcome;
    assert!(option::is_some(opt_ref), ENotFinalized);
    *option::borrow(opt_ref)
}

public fun get_outcome_message(state: &MarketState, outcome_idx: u64): String {
    assert!(outcome_idx < state.outcome_count, EOutcomeOutOfBounds);
    state.outcome_messages[outcome_idx]
}

public fun get_creation_time(state: &MarketState): u64 {
    state.creation_time
}

public fun get_trading_end_time(state: &MarketState): Option<u64> {
    state.trading_end
}

public fun get_trading_start(state: &MarketState): u64 {
    state.trading_start
}

public fun get_finalization_time(state: &MarketState): Option<u64> {
    state.finalization_time
}

// === Test Functions ===
#[test_only]
public fun create_for_testing(outcomes: u64, ctx: &mut TxContext): MarketState {
    let dummy_id = object::new(ctx);
    let market_id = dummy_id.uid_to_inner();
    dummy_id.delete();

    MarketState {
        id: object::new(ctx),
        market_id,
        dao_id: market_id,
        outcome_messages: vector[],
        outcome_count: outcomes,
        amm_pools: option::none(),
        status: MarketStatus {
            trading_started: false,
            trading_ended: false,
            finalized: false,
        },
        winning_outcome: option::none(),
        creation_time: 0,
        trading_start: 0,
        trading_end: option::none(),
        finalization_time: option::none(),
    }
}

#[test_only]
public fun init_trading_for_testing(state: &mut MarketState) {
    state.status.trading_started = true;
    state.trading_start = 0;
    state.trading_end = option::some(9999999999999);
}
#[test_only]
public fun reset_state_for_testing(state: &mut MarketState) {
    state.status.trading_started = false;
    state.trading_start = 0;
}

#[test_only]
public fun finalize_for_testing(state: &mut MarketState) {
    state.status.trading_ended = true;
    state.status.finalized = true;
    state.winning_outcome = option::some(0);
    state.finalization_time = option::some(0);
}

#[test_only]
public fun destroy_for_testing(state: MarketState) {
    sui::test_utils::destroy(state);
}

#[test_only]
public fun copy_market_id(state: &MarketState): ID {
    state.market_id
}

#[test_only]
public fun copy_status(state: &MarketState): MarketStatus {
    state.status
}

#[test_only]
public fun copy_winning_outcome(state: &MarketState): Option<u64> {
    state.winning_outcome
}

#[test_only]
public fun test_set_winning_outcome(state: &mut MarketState, outcome: u64) {
    state.winning_outcome = option::some(outcome);
}

#[test_only]
public fun test_set_finalized(state: &mut MarketState) {
    state.status.finalized = true;
    state.status.trading_ended = true;
    state.finalization_time = option::some(0);
}

#[test_only]
/// Test helper to borrow AMM pool mutably by outcome index (u64 instead of u8)
public fun borrow_amm_pool_mut(state: &mut MarketState, outcome_idx: u64): &mut LiquidityPool {
    let pools = state.amm_pools.borrow_mut();
    &mut pools[outcome_idx]
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

module futarchy_markets_primitives::coin_escrow;

use futarchy_markets_primitives::market_state::MarketState;
use sui::balance::{Self, Balance};
use sui::coin::{Self, Coin, TreasuryCap, CoinMetadata};
use sui::dynamic_field;

// === Introduction ===
// The TokenEscrow manages TreasuryCap-based conditional coins in the futarchy prediction market system.
//
// === TreasuryCap-Based Conditional Coins ===
// Uses real Sui Coin<T> types instead of custom ConditionalToken structs:
// 1. **TreasuryCap Storage**: Each outcome has 2 TreasuryCaps (asset + stable) stored in dynamic fields
// 2. **Registry Integration**: Blank coins acquired from permissionless registry
// 3. **Quantum Liquidity**: Spot tokens exist simultaneously in ALL outcomes (not split between them)
//
// === Quantum Liquidity Invariant ===
// **CRITICAL**: 100 spot tokens ‚Üí 100 conditional tokens in EACH outcome
// - NOT proportional split (not 50/50 across 2 outcomes)
// - Liquidity exists fully in all markets simultaneously
// - Only highest-priced outcome wins at finalization
// - Invariant: spot_asset_balance == each_outcome_asset_supply (for ALL outcomes)
//
// === Architecture ===
// - TreasuryCaps stored via dynamic fields with AssetCapKey/StableCapKey
// - Vector-like indexing: outcome_index determines which cap to use
// - Mint/burn functions borrow caps mutably, perform operation, return cap to storage
// - No Supply objects - total_supply() comes directly from TreasuryCap

// === Errors ===
const EInsufficientBalance: u64 = 0; // Token balance insufficient for operation
const EIncorrectSequence: u64 = 1; // Tokens not provided in correct sequence/order
const EWrongMarket: u64 = 2; // Token belongs to different market
const EWrongTokenType: u64 = 3; // Wrong token type (asset vs stable)
const ESuppliesNotInitialized: u64 = 4; // Token supplies not yet initialized
const EOutcomeOutOfBounds: u64 = 5; // Outcome index exceeds market outcomes
const EWrongOutcome: u64 = 6; // Token outcome doesn't match expected
const ENotEnough: u64 = 7; // Not enough tokens/balance for operation
const ENotEnoughLiquidity: u64 = 8; // Insufficient liquidity in escrow
const EInsufficientAsset: u64 = 9; // Not enough asset tokens provided
const EInsufficientStable: u64 = 10; // Not enough stable tokens provided
const EMarketNotExpired: u64 = 11; // Market hasn't reached expiry period
const EBadWitness: u64 = 12; // Invalid one-time witness
const EZeroAmount: u64 = 13; // Amount must be greater than zero
const EInvalidAssetType: u64 = 14; // Asset type must be 0 (asset) or 1 (stable)
const EOverflow: u64 = 15; // Arithmetic overflow protection

// === Constants ===
const TOKEN_TYPE_ASSET: u8 = 0;
const TOKEN_TYPE_STABLE: u8 = 1;
const TOKEN_TYPE_LP: u8 = 2;
const ETokenTypeMismatch: u64 = 100;
const MARKET_EXPIRY_PERIOD_MS: u64 = 2_592_000_000; // 30 days in ms

// === Key Structures for TreasuryCap Storage ===
/// Key for asset conditional coin TreasuryCaps (indexed by outcome)
public struct AssetCapKey has copy, drop, store {
    outcome_index: u64,
}

/// Key for stable conditional coin TreasuryCaps (indexed by outcome)
public struct StableCapKey has copy, drop, store {
    outcome_index: u64,
}

// === Structs ===
public struct TokenEscrow<phantom AssetType, phantom StableType> has key, store {
    id: UID,
    market_state: MarketState,
    // Central balances used for tokens and liquidity
    escrowed_asset: Balance<AssetType>,
    escrowed_stable: Balance<StableType>,
    // TreasuryCaps stored as dynamic fields on UID (vector-like access by index)
    // Asset caps: dynamic_field with AssetCapKey { outcome_index } -> TreasuryCap<T>
    // Stable caps: dynamic_field with StableCapKey { outcome_index } -> TreasuryCap<T>
    // Each outcome's TreasuryCap has a unique generic type T
    outcome_count: u64, // Track how many outcomes have registered caps
}

public struct COIN_ESCROW has drop {}

// === Events ===
public struct LiquidityWithdrawal has copy, drop {
    escrowed_asset: u64,
    escrowed_stable: u64,
    asset_amount: u64,
    stable_amount: u64,
}

public struct LiquidityDeposit has copy, drop {
    escrowed_asset: u64,
    escrowed_stable: u64,
    asset_amount: u64,
    stable_amount: u64,
}

public struct TokenRedemption has copy, drop {
    outcome: u64,
    token_type: u8,
    amount: u64,
}

public fun new<AssetType, StableType>(
    market_state: MarketState,
    ctx: &mut TxContext,
): TokenEscrow<AssetType, StableType> {
    TokenEscrow {
        id: object::new(ctx),
        market_state,
        escrowed_asset: balance::zero(),
        escrowed_stable: balance::zero(),
        outcome_count: 0, // Will be incremented as caps are registered
    }
}

/// NEW: Register conditional coin TreasuryCaps for an outcome
/// Must be called once per outcome with both asset and stable caps
/// Caps are stored as dynamic fields with vector-like indexing semantics
public fun register_conditional_caps<
    AssetType,
    StableType,
    AssetConditionalCoin,
    StableConditionalCoin,
>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    asset_treasury_cap: TreasuryCap<AssetConditionalCoin>,
    stable_treasury_cap: TreasuryCap<StableConditionalCoin>,
) {
    let market_outcome_count = escrow.market_state.outcome_count();
    assert!(outcome_idx < market_outcome_count, EOutcomeOutOfBounds);

    // Must register in order (like pushing to a vector)
    assert!(outcome_idx == escrow.outcome_count, EIncorrectSequence);

    // Store TreasuryCaps as dynamic fields with index-based keys
    let asset_key = AssetCapKey { outcome_index: outcome_idx };
    let stable_key = StableCapKey { outcome_index: outcome_idx };

    dynamic_field::add(&mut escrow.id, asset_key, asset_treasury_cap);
    dynamic_field::add(&mut escrow.id, stable_key, stable_treasury_cap);

    // Increment count (like vector length)
    escrow.outcome_count = escrow.outcome_count + 1;
}

// === NEW: TreasuryCap-based Mint/Burn Helpers ===

/// Mint conditional coins for a specific outcome using its TreasuryCap
/// Borrows the cap, mints, and returns it (maintains vector-like storage)
public fun mint_conditional_asset<AssetType, StableType, ConditionalCoinType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_index: u64,
    amount: u64,
    ctx: &mut TxContext,
): Coin<ConditionalCoinType> {
    let market_outcome_count = escrow.market_state.outcome_count();
    assert!(outcome_index < market_outcome_count, EOutcomeOutOfBounds);

    // Borrow the TreasuryCap from dynamic field
    let asset_key = AssetCapKey { outcome_index };
    let cap: &mut TreasuryCap<ConditionalCoinType> = dynamic_field::borrow_mut(
        &mut escrow.id,
        asset_key,
    );

    // Mint and return
    coin::mint(cap, amount, ctx)
}

/// Mint conditional stable coins for a specific outcome
public fun mint_conditional_stable<AssetType, StableType, ConditionalCoinType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_index: u64,
    amount: u64,
    ctx: &mut TxContext,
): Coin<ConditionalCoinType> {
    let market_outcome_count = escrow.market_state.outcome_count();
    assert!(outcome_index < market_outcome_count, EOutcomeOutOfBounds);

    // Borrow the TreasuryCap from dynamic field
    let stable_key = StableCapKey { outcome_index };
    let cap: &mut TreasuryCap<ConditionalCoinType> = dynamic_field::borrow_mut(
        &mut escrow.id,
        stable_key,
    );

    // Mint and return
    coin::mint(cap, amount, ctx)
}

/// Burn conditional asset coins for a specific outcome
public fun burn_conditional_asset<AssetType, StableType, ConditionalCoinType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_index: u64,
    coin: Coin<ConditionalCoinType>,
) {
    let market_outcome_count = escrow.market_state.outcome_count();
    assert!(outcome_index < market_outcome_count, EOutcomeOutOfBounds);

    // Borrow the TreasuryCap from dynamic field
    let asset_key = AssetCapKey { outcome_index };
    let cap: &mut TreasuryCap<ConditionalCoinType> = dynamic_field::borrow_mut(
        &mut escrow.id,
        asset_key,
    );

    // Burn
    coin::burn(cap, coin);
}

/// Burn conditional stable coins for a specific outcome
public fun burn_conditional_stable<AssetType, StableType, ConditionalCoinType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_index: u64,
    coin: Coin<ConditionalCoinType>,
) {
    let market_outcome_count = escrow.market_state.outcome_count();
    assert!(outcome_index < market_outcome_count, EOutcomeOutOfBounds);

    // Borrow the TreasuryCap from dynamic field
    let stable_key = StableCapKey { outcome_index };
    let cap: &mut TreasuryCap<ConditionalCoinType> = dynamic_field::borrow_mut(
        &mut escrow.id,
        stable_key,
    );

    // Burn
    coin::burn(cap, coin);
}

// === NEW: Generic Mint/Burn for Balance-Based Operations ===

/// Generic mint function for conditional coins (used by balance unwrap)
/// Takes outcome_index and is_asset to determine which TreasuryCap to use
public(package) fun mint_conditional<AssetType, StableType, ConditionalCoinType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_index: u64,
    is_asset: bool,
    amount: u64,
    ctx: &mut TxContext,
): Coin<ConditionalCoinType> {
    if (is_asset) {
        mint_conditional_asset<AssetType, StableType, ConditionalCoinType>(
            escrow,
            outcome_index,
            amount,
            ctx,
        )
    } else {
        mint_conditional_stable<AssetType, StableType, ConditionalCoinType>(
            escrow,
            outcome_index,
            amount,
            ctx,
        )
    }
}

/// Generic burn function for conditional coins (used by balance wrap)
public(package) fun burn_conditional<AssetType, StableType, ConditionalCoinType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_index: u64,
    is_asset: bool,
    coin: Coin<ConditionalCoinType>,
) {
    if (is_asset) {
        burn_conditional_asset<AssetType, StableType, ConditionalCoinType>(
            escrow,
            outcome_index,
            coin,
        )
    } else {
        burn_conditional_stable<AssetType, StableType, ConditionalCoinType>(
            escrow,
            outcome_index,
            coin,
        )
    }
}

/// Deposit spot coins to escrow (for balance-based operations)
/// Returns amounts deposited (for balance tracking)
public fun deposit_spot_coins<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    asset_coin: Coin<AssetType>,
    stable_coin: Coin<StableType>,
): (u64, u64) {
    let asset_amt = asset_coin.value();
    let stable_amt = stable_coin.value();

    // Require at least one non-zero amount
    assert!(asset_amt > 0 || stable_amt > 0, EZeroAmount);

    // Add to escrow reserves
    balance::join(&mut escrow.escrowed_asset, coin::into_balance(asset_coin));
    balance::join(&mut escrow.escrowed_stable, coin::into_balance(stable_coin));

    (asset_amt, stable_amt)
}

/// Withdraw spot coins from escrow (for complete set burn)
public fun withdraw_from_escrow<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    asset_amount: u64,
    stable_amount: u64,
    ctx: &mut TxContext,
): (Coin<AssetType>, Coin<StableType>) {
    assert!(balance::value(&escrow.escrowed_asset) >= asset_amount, ENotEnoughLiquidity);
    assert!(balance::value(&escrow.escrowed_stable) >= stable_amount, ENotEnoughLiquidity);

    let asset_bal = balance::split(&mut escrow.escrowed_asset, asset_amount);
    let stable_bal = balance::split(&mut escrow.escrowed_stable, stable_amount);

    (coin::from_balance(asset_bal, ctx), coin::from_balance(stable_bal, ctx))
}

/// Get the total supply of a specific outcome's asset conditional coin
public fun get_asset_supply<AssetType, StableType, ConditionalCoinType>(
    escrow: &TokenEscrow<AssetType, StableType>,
    outcome_index: u64,
): u64 {
    let asset_key = AssetCapKey { outcome_index };
    let cap: &TreasuryCap<ConditionalCoinType> = dynamic_field::borrow(&escrow.id, asset_key);
    coin::total_supply(cap)
}

/// Get the total supply of a specific outcome's stable conditional coin
public fun get_stable_supply<AssetType, StableType, ConditionalCoinType>(
    escrow: &TokenEscrow<AssetType, StableType>,
    outcome_index: u64,
): u64 {
    let stable_key = StableCapKey { outcome_index };
    let cap: &TreasuryCap<ConditionalCoinType> = dynamic_field::borrow(&escrow.id, stable_key);
    coin::total_supply(cap)
}

// === Getters ===

/// Get the market state from escrow
public fun get_market_state<AssetType, StableType>(
    escrow: &TokenEscrow<AssetType, StableType>,
): &MarketState {
    &escrow.market_state
}

/// Get mutable market state from escrow
public fun get_market_state_mut<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
): &mut MarketState {
    &mut escrow.market_state
}

/// Get the market state ID from escrow
public fun market_state_id<AssetType, StableType>(escrow: &TokenEscrow<AssetType, StableType>): ID {
    escrow.market_state.market_id()
}

/// Get the number of outcomes that have registered TreasuryCaps
public fun caps_registered_count<AssetType, StableType>(
    escrow: &TokenEscrow<AssetType, StableType>,
): u64 {
    escrow.outcome_count
}

/// Deposit spot liquidity into escrow (quantum liquidity model)
/// This adds to the escrow balances that will be split quantum-mechanically across all outcomes
public fun deposit_spot_liquidity<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    asset: Balance<AssetType>,
    stable: Balance<StableType>,
) {
    escrow.escrowed_asset.join(asset);
    escrow.escrowed_stable.join(stable);
}

// === Burn and Withdraw Helpers (For Redemption) ===

/// Burn conditional asset coins and withdraw equivalent spot asset
/// Used when redeeming conditional coins back to spot tokens (e.g., after market finalization)
public fun burn_conditional_asset_and_withdraw<AssetType, StableType, ConditionalCoinType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_index: u64,
    amount: u64,
    ctx: &mut TxContext,
): Coin<AssetType> {
    // Mint the conditional coins to burn them (quantum liquidity: amounts must match)
    let conditional_coin = mint_conditional_asset<AssetType, StableType, ConditionalCoinType>(
        escrow,
        outcome_index,
        amount,
        ctx,
    );

    // Burn the conditional coins
    burn_conditional_asset<AssetType, StableType, ConditionalCoinType>(
        escrow,
        outcome_index,
        conditional_coin,
    );

    // Withdraw equivalent spot tokens (1:1 due to quantum liquidity)
    let asset_balance = escrow.escrowed_asset.split(amount);
    coin::from_balance(asset_balance, ctx)
}

/// Burn conditional stable coins and withdraw equivalent spot stable
public fun burn_conditional_stable_and_withdraw<AssetType, StableType, ConditionalCoinType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_index: u64,
    amount: u64,
    ctx: &mut TxContext,
): Coin<StableType> {
    // Mint the conditional coins to burn them
    let conditional_coin = mint_conditional_stable<AssetType, StableType, ConditionalCoinType>(
        escrow,
        outcome_index,
        amount,
        ctx,
    );

    // Burn the conditional coins
    burn_conditional_stable<AssetType, StableType, ConditionalCoinType>(
        escrow,
        outcome_index,
        conditional_coin,
    );

    // Withdraw equivalent spot tokens
    let stable_balance = escrow.escrowed_stable.split(amount);
    coin::from_balance(stable_balance, ctx)
}

// === Deposit and Mint Helpers (For Creating Conditional Coins) ===

/// Deposit spot asset and mint equivalent conditional asset coins
/// Quantum liquidity: Depositing X spot mints X conditional in specified outcome
public fun deposit_asset_and_mint_conditional<AssetType, StableType, ConditionalCoinType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_index: u64,
    asset_coin: Coin<AssetType>,
    ctx: &mut TxContext,
): Coin<ConditionalCoinType> {
    let amount = asset_coin.value();

    // Deposit spot tokens to escrow
    let asset_balance = coin::into_balance(asset_coin);
    escrow.escrowed_asset.join(asset_balance);

    // Mint equivalent conditional coins (1:1 due to quantum liquidity)
    mint_conditional_asset<AssetType, StableType, ConditionalCoinType>(
        escrow,
        outcome_index,
        amount,
        ctx,
    )
}

/// Deposit spot stable and mint equivalent conditional stable coins
public fun deposit_stable_and_mint_conditional<AssetType, StableType, ConditionalCoinType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_index: u64,
    stable_coin: Coin<StableType>,
    ctx: &mut TxContext,
): Coin<ConditionalCoinType> {
    let amount = stable_coin.value();

    // Deposit spot tokens to escrow
    let stable_balance = coin::into_balance(stable_coin);
    escrow.escrowed_stable.join(stable_balance);

    // Mint equivalent conditional coins
    mint_conditional_stable<AssetType, StableType, ConditionalCoinType>(
        escrow,
        outcome_index,
        amount,
        ctx,
    )
}

/// Get escrow spot balances (read-only)
public fun get_spot_balances<AssetType, StableType>(
    escrow: &TokenEscrow<AssetType, StableType>,
): (u64, u64) {
    (escrow.escrowed_asset.value(), escrow.escrowed_stable.value())
}

/// Withdraw asset balance from escrow (for internal use)
public fun withdraw_asset_balance<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    amount: u64,
    ctx: &mut TxContext,
): Coin<AssetType> {
    let balance = escrow.escrowed_asset.split(amount);
    coin::from_balance(balance, ctx)
}

/// Withdraw stable balance from escrow (for internal use)
public fun withdraw_stable_balance<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    amount: u64,
    ctx: &mut TxContext,
): Coin<StableType> {
    let balance = escrow.escrowed_stable.split(amount);
    coin::from_balance(balance, ctx)
}

// === Quantum Liquidity Invariant ===
//
// INVARIANT (enforced by construction):
// - spot_asset_balance == each_outcome_asset_supply (for ALL outcomes)
// - spot_stable_balance == each_outcome_stable_supply (for ALL outcomes)
//
// This invariant is maintained by the mint/burn operations:
// - deposit_and_mint: deposit X spot ‚Üí mint X conditional (1:1)
// - burn_and_withdraw: burn X conditional ‚Üí withdraw X spot (1:1)
// - split operations: deposit spot ‚Üí mint conditional in all outcomes
// - recombine operations: burn conditional from all outcomes ‚Üí withdraw spot
//
// No validation function needed - operations enforce invariant by construction.

// === Complete Set Operations (Split/Recombine) ===
// Uses PTB hot potato pattern - see TYPE_PARAMETER_EXPLOSION_PROBLEM.md

/// Progress tracker for splitting a spot asset coin into a complete set of conditional asset coins.
/// This struct MUST be fully consumed via `finish_split_asset_progress` to preserve the quantum invariant.
public struct SplitAssetProgress<phantom AssetType, phantom StableType> has drop {
    market_id: ID,
    amount: u64,
    outcome_count: u64,
    next_outcome: u64,
}

public fun drop_split_asset_progress<AssetType, StableType>(
    progress: SplitAssetProgress<AssetType, StableType>,
) {
    let SplitAssetProgress { market_id: _, amount: _, outcome_count, next_outcome } = progress;
    assert!(next_outcome == outcome_count, EIncorrectSequence);
}

/// Progress tracker for splitting a spot stable coin into a complete set of conditional stable coins.
public struct SplitStableProgress<phantom AssetType, phantom StableType> has drop {
    market_id: ID,
    amount: u64,
    outcome_count: u64,
    next_outcome: u64,
}

public fun drop_split_stable_progress<AssetType, StableType>(
    progress: SplitStableProgress<AssetType, StableType>,
) {
    let SplitStableProgress { market_id: _, amount: _, outcome_count, next_outcome } = progress;
    assert!(next_outcome == outcome_count, EIncorrectSequence);
}

/// Progress tracker for recombining conditional asset coins back into a spot asset coin.
/// All outcomes must be processed sequentially from 0 ‚Üí outcome_count - 1.
public struct RecombineAssetProgress<phantom AssetType, phantom StableType> has drop {
    market_id: ID,
    amount: u64,
    outcome_count: u64,
    next_outcome: u64,
}

public fun drop_recombine_asset_progress<AssetType, StableType>(
    progress: RecombineAssetProgress<AssetType, StableType>,
) {
    let RecombineAssetProgress { market_id: _, amount: _, outcome_count, next_outcome } = progress;
    assert!(next_outcome == outcome_count, EIncorrectSequence);
}

/// Progress tracker for recombining conditional stable coins back into a spot stable coin.
public struct RecombineStableProgress<phantom AssetType, phantom StableType> has drop {
    market_id: ID,
    amount: u64,
    outcome_count: u64,
    next_outcome: u64,
}

public fun drop_recombine_stable_progress<AssetType, StableType>(
    progress: RecombineStableProgress<AssetType, StableType>,
) {
    let RecombineStableProgress { market_id: _, amount: _, outcome_count, next_outcome } = progress;
    assert!(next_outcome == outcome_count, EIncorrectSequence);
}

/// Begin splitting a spot asset coin into a complete set of conditional assets.
/// Returns a progress object that must be passed through `split_asset_progress_step`
/// for each outcome, then finalized with `finish_split_asset_progress`.
public fun start_split_asset_progress<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    spot_asset: Coin<AssetType>,
): SplitAssetProgress<AssetType, StableType> {
    let amount = spot_asset.value();
    assert!(amount > 0, EZeroAmount);

    let outcome_count = caps_registered_count(escrow);
    assert!(outcome_count > 0, ESuppliesNotInitialized);

    let asset_balance = coin::into_balance(spot_asset);
    escrow.escrowed_asset.join(asset_balance);

    SplitAssetProgress {
        market_id: market_state_id(escrow),
        amount,
        outcome_count,
        next_outcome: 0,
    }
}

/// Mint the next conditional asset coin in the sequence.
/// Caller is responsible for transferring or otherwise handling the returned coin.
public fun split_asset_progress_step<AssetType, StableType, ConditionalCoinType>(
    mut progress: SplitAssetProgress<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_index: u8,
    ctx: &mut TxContext,
): (SplitAssetProgress<AssetType, StableType>, Coin<ConditionalCoinType>) {
    assert!(market_state_id(escrow) == progress.market_id, EWrongMarket);

    let index = (outcome_index as u64);
    assert!(progress.next_outcome < progress.outcome_count, EOutcomeOutOfBounds);
    assert!(index == progress.next_outcome, EIncorrectSequence);

    let coin = mint_conditional_asset<AssetType, StableType, ConditionalCoinType>(
        escrow,
        index,
        progress.amount,
        ctx,
    );

    progress.next_outcome = progress.next_outcome + 1;

    (progress, coin)
}

/// Ensure the split operation covered all outcomes. Must be called exactly once per progress object.
public fun finish_split_asset_progress<AssetType, StableType>(
    progress: SplitAssetProgress<AssetType, StableType>,
) {
    let SplitAssetProgress { market_id: _, amount: _, outcome_count, next_outcome } = progress;
    assert!(next_outcome == outcome_count, EIncorrectSequence);
}

/// Begin splitting a spot stable coin into a complete set of conditional stables.
public fun start_split_stable_progress<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    spot_stable: Coin<StableType>,
): SplitStableProgress<AssetType, StableType> {
    let amount = spot_stable.value();
    assert!(amount > 0, EZeroAmount);

    let outcome_count = caps_registered_count(escrow);
    assert!(outcome_count > 0, ESuppliesNotInitialized);

    let stable_balance = coin::into_balance(spot_stable);
    escrow.escrowed_stable.join(stable_balance);

    SplitStableProgress {
        market_id: market_state_id(escrow),
        amount,
        outcome_count,
        next_outcome: 0,
    }
}

/// Mint the next conditional stable coin in the sequence.
public fun split_stable_progress_step<AssetType, StableType, ConditionalCoinType>(
    mut progress: SplitStableProgress<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_index: u8,
    ctx: &mut TxContext,
): (SplitStableProgress<AssetType, StableType>, Coin<ConditionalCoinType>) {
    assert!(market_state_id(escrow) == progress.market_id, EWrongMarket);

    let index = (outcome_index as u64);
    assert!(progress.next_outcome < progress.outcome_count, EOutcomeOutOfBounds);
    assert!(index == progress.next_outcome, EIncorrectSequence);

    let coin = mint_conditional_stable<AssetType, StableType, ConditionalCoinType>(
        escrow,
        index,
        progress.amount,
        ctx,
    );

    progress.next_outcome = progress.next_outcome + 1;

    (progress, coin)
}

/// Ensure the stable split operation covered all outcomes.
public fun finish_split_stable_progress<AssetType, StableType>(
    progress: SplitStableProgress<AssetType, StableType>,
) {
    let SplitStableProgress { market_id: _, amount: _, outcome_count, next_outcome } = progress;
    assert!(next_outcome == outcome_count, EIncorrectSequence);
}

/// Begin recombining conditional asset coins into a spot asset coin.
/// Consumes and burns the first coin (must be outcome index 0).
public fun start_recombine_asset_progress<AssetType, StableType, ConditionalCoinType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_index: u8,
    coin: Coin<ConditionalCoinType>,
): RecombineAssetProgress<AssetType, StableType> {
    let index = (outcome_index as u64);
    assert!(index == 0, EIncorrectSequence);

    let outcome_count = caps_registered_count(escrow);
    assert!(outcome_count > 0, ESuppliesNotInitialized);
    assert!(index < outcome_count, EOutcomeOutOfBounds);

    let amount = coin.value();
    assert!(amount > 0, EZeroAmount);

    burn_conditional_asset<AssetType, StableType, ConditionalCoinType>(
        escrow,
        index,
        coin,
    );

    RecombineAssetProgress {
        market_id: market_state_id(escrow),
        amount,
        outcome_count,
        next_outcome: 1,
    }
}

/// Burn the next conditional asset coin in the recombination sequence.
public fun recombine_asset_progress_step<AssetType, StableType, ConditionalCoinType>(
    mut progress: RecombineAssetProgress<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_index: u8,
    coin: Coin<ConditionalCoinType>,
): RecombineAssetProgress<AssetType, StableType> {
    assert!(market_state_id(escrow) == progress.market_id, EWrongMarket);

    let index = (outcome_index as u64);
    assert!(progress.next_outcome < progress.outcome_count, EOutcomeOutOfBounds);
    assert!(index == progress.next_outcome, EIncorrectSequence);

    let amount = coin.value();
    assert!(amount == progress.amount, EInsufficientBalance);

    burn_conditional_asset<AssetType, StableType, ConditionalCoinType>(
        escrow,
        index,
        coin,
    );

    progress.next_outcome = progress.next_outcome + 1;
    progress
}

/// Finish recombination and withdraw the corresponding spot asset coin.
public fun finish_recombine_asset_progress<AssetType, StableType>(
    progress: RecombineAssetProgress<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    ctx: &mut TxContext,
): Coin<AssetType> {
    let RecombineAssetProgress { market_id: _, amount, outcome_count, next_outcome } = progress;
    assert!(next_outcome == outcome_count, EIncorrectSequence);
    withdraw_asset_balance(escrow, amount, ctx)
}

/// Begin recombining conditional stable coins into spot stable.
public fun start_recombine_stable_progress<AssetType, StableType, ConditionalCoinType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_index: u8,
    coin: Coin<ConditionalCoinType>,
): RecombineStableProgress<AssetType, StableType> {
    let index = (outcome_index as u64);
    assert!(index == 0, EIncorrectSequence);

    let outcome_count = caps_registered_count(escrow);
    assert!(outcome_count > 0, ESuppliesNotInitialized);
    assert!(index < outcome_count, EOutcomeOutOfBounds);

    let amount = coin.value();
    assert!(amount > 0, EZeroAmount);

    burn_conditional_stable<AssetType, StableType, ConditionalCoinType>(
        escrow,
        index,
        coin,
    );

    RecombineStableProgress {
        market_id: market_state_id(escrow),
        amount,
        outcome_count,
        next_outcome: 1,
    }
}

/// Burn the next conditional stable coin in the recombination sequence.
public fun recombine_stable_progress_step<AssetType, StableType, ConditionalCoinType>(
    mut progress: RecombineStableProgress<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_index: u8,
    coin: Coin<ConditionalCoinType>,
): RecombineStableProgress<AssetType, StableType> {
    assert!(market_state_id(escrow) == progress.market_id, EWrongMarket);

    let index = (outcome_index as u64);
    assert!(progress.next_outcome < progress.outcome_count, EOutcomeOutOfBounds);
    assert!(index == progress.next_outcome, EIncorrectSequence);

    let amount = coin.value();
    assert!(amount == progress.amount, EInsufficientBalance);

    burn_conditional_stable<AssetType, StableType, ConditionalCoinType>(
        escrow,
        index,
        coin,
    );

    progress.next_outcome = progress.next_outcome + 1;
    progress
}

/// Finish recombination and withdraw the corresponding spot stable coin.
public fun finish_recombine_stable_progress<AssetType, StableType>(
    progress: RecombineStableProgress<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    ctx: &mut TxContext,
): Coin<StableType> {
    let RecombineStableProgress { market_id: _, amount, outcome_count, next_outcome } = progress;
    assert!(next_outcome == outcome_count, EIncorrectSequence);
    withdraw_stable_balance(escrow, amount, ctx)
}

// === Test Helpers ===

#[test_only]
/// Create a blank TreasuryCap for testing (zero supply, blank metadata)
/// This simulates getting a blank coin from the registry
public fun create_test_treasury_cap<CoinType: drop>(
    otw: CoinType,
    ctx: &mut TxContext,
): (TreasuryCap<CoinType>, CoinMetadata<CoinType>) {
    // Create coin with blank metadata
    let (treasury_cap, metadata) = coin::create_currency(
        otw,
        0, // decimals
        b"", // symbol (empty)
        b"", // name (empty)
        b"", // description (empty)
        option::none(), // icon_url (empty)
        ctx,
    );

    (treasury_cap, metadata)
}

#[test_only]
/// Create a test escrow with a real MarketState (not a mock)
/// This is a simplified helper that creates an actual TokenEscrow with sensible defaults
public fun create_test_escrow<AssetType, StableType>(
    outcome_count: u64,
    ctx: &mut TxContext,
): TokenEscrow<AssetType, StableType> {
    // Create a real MarketState using existing test infrastructure
    let market_state = futarchy_markets_primitives::market_state::create_for_testing(
        outcome_count,
        ctx,
    );

    // Create and return the TokenEscrow with the real MarketState
    new<AssetType, StableType>(market_state, ctx)
}

#[test_only]
/// Create a test escrow with a provided MarketState
/// Useful when you need to customize the market state before creating the escrow
public fun create_test_escrow_with_market_state<AssetType, StableType>(
    _outcome_count: u64, // Not used, but kept for API compatibility
    market_state: MarketState,
    ctx: &mut TxContext,
): TokenEscrow<AssetType, StableType> {
    new<AssetType, StableType>(market_state, ctx)
}

#[test_only]
/// Destroy escrow for testing (with remaining balances)
/// Useful for cleaning up test state
public fun destroy_for_testing<AssetType, StableType>(escrow: TokenEscrow<AssetType, StableType>) {
    let TokenEscrow {
        id,
        market_state,
        escrowed_asset,
        escrowed_stable,
        outcome_count: _,
    } = escrow;

    // Destroy balances
    balance::destroy_for_testing(escrowed_asset);
    balance::destroy_for_testing(escrowed_stable);

    // Destroy market state
    futarchy_markets_primitives::market_state::destroy_for_testing(market_state);

    // Delete UID (TreasuryCaps in dynamic fields will be destroyed automatically)
    object::delete(id);
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// ============================================================================
/// FUTARCHY TWAP ORACLE - WRITE-THROUGH TWAP FOR PREDICTION MARKETS (INTERNAL)
/// ============================================================================
///
/// PURPOSE: Internal oracle for futarchy decision-making and proposal resolution
///
/// USED BY:
/// - Conditional AMMs during proposals (outcome evaluation)
/// - Proposal resolution (determining winners based on TWAP)
/// - NOT for external protocols (use pass_through_oracle instead)
///
/// KEY FEATURES:
/// - Write-through pattern (MUST update before reading)
/// - Price capping to prevent manipulation up or down
/// - Complex window-based accumulation
/// - Designed specifically for futarchy mechanics
/// - Internal use only (wrapped by pass_through_oracle for external access)
///
/// BEHAVIOR:
/// - During proposals: Each conditional AMM maintains its own oracle
/// - After finalization: Winning outcome's TWAP fills gap in spot oracle
/// - External protocols use pass_through_oracle (pass-through wrapper)
///
/// WHY IT EXISTS:
/// Futarchy needs precise, manipulation-resistant price discovery during
/// proposals. This oracle enforces atomic write-then-read to ensure prices
/// are always fresh and prevents time-based manipulation attacks.
///
/// FOR EXTERNAL INTEGRATIONS:
/// Use pass_through_oracle.move instead - it provides a standard Uniswap-like
/// interface that automatically switches between spot and conditional oracles
/// without requiring understanding of futarchy mechanics.
///
/// ============================================================================

module futarchy_markets_primitives::futarchy_twap_oracle;

use futarchy_one_shot_utils::constants;
use futarchy_one_shot_utils::math;
use std::u128;
use std::u64;
use sui::clock::Clock;
use sui::event;

// === Introduction ===
// Crankless Time Weighted Average Price (TWAP) Oracle

// === Constants ===
// Constants moved to constants module
// Using constants::twap_price_cap_window(), constants::one_week_ms(), constants::ppm_denominator()

// === Errors ===
const ETimestampRegression: u64 = 0;
const ETwapNotStarted: u64 = 1;
const EZeroPeriod: u64 = 2;
const EZeroInitialization: u64 = 3;
const EZeroStep: u64 = 4;
const ELongDelay: u64 = 5;
const EStaleTwap: u64 = 6;
const EOverflowVRamp: u64 = 7;
const EOverflowVFlat: u64 = 8;
const EOverflowSDevMag: u64 = 9;
const EOverflowBasePriceSumFinal: u64 = 10;
const EOverflowVSumPricesAdd: u64 = 11;
const EInternalTwapError: u64 = 12;
const ENoneFullWindowTwapDelay: u64 = 13;
const EMarketNotStarted: u64 = 14;
const EMarketAlreadyStarted: u64 = 15;
const EInvalidCapPpm: u64 = 16;
const EStepOverflow: u64 = 17;

// === Structs ===
public struct Oracle has key, store {
    id: UID,
    last_price: u128,
    last_timestamp: u64,
    total_cumulative_price: u256,
    // TWAP calculation fields - using u256 for overflow protection
    // Max TWAP accumulation is U256 Max ‚âà1.16 x 10^77
    // Max TWAP daily accumulation:
    //     Max price observation = u64::max_value!() x 1_000_000_000_000;
    //     Milliseconds a day (7 x 24 √ó 3,600 √ó 1,000) * max price observation
    //     Allows for 1.04√ó10 ^ 37 days of accumulation.
    last_window_end_cumulative_price: u256,
    last_window_end: u64,
    last_window_twap: u128,
    twap_start_delay: u64,
    // Reduces attacker advantage with surprise proposals
    twap_cap_step: u64,
    // Scaled relative maximum step size for TWAP calculations
    market_start_time: Option<u64>,
    twap_initialization_price: u128,
}

// === Events ===

public struct PriceEvent has copy, drop {
    last_price: u128,
}

// === Public Functions ===
public fun new_oracle(
    twap_initialization_price: u128,
    twap_start_delay: u64,
    twap_cap_ppm: u64,
    ctx: &mut TxContext,
): Oracle {
    assert!(twap_initialization_price > 0, EZeroInitialization);
    assert!(twap_cap_ppm > 0, EZeroStep);
    assert!(twap_cap_ppm <= constants::ppm_denominator(), EInvalidCapPpm);
    assert!(twap_start_delay < constants::one_week_ms(), ELongDelay); // One week in milliseconds
    assert!((twap_start_delay % constants::twap_price_cap_window()) == 0, ENoneFullWindowTwapDelay);

    // Calculate the absolute step from PPM and initialization price
    // Use checked multiplication to avoid overflow
    let step_u128 = if (
        twap_cap_ppm > 0 && twap_initialization_price > (u128::max_value!() / (twap_cap_ppm as u128))
    ) {
        // Would overflow, use max u64 as step
        (u64::max_value!() as u128)
    } else {
        twap_initialization_price * (twap_cap_ppm as u128) / (constants::ppm_denominator() as u128)
    };
    assert!(step_u128 <= (std::u64::max_value!() as u128), EStepOverflow);
    let mut twap_cap_step = step_u128 as u64;
    // Ensure step is at least 1 to avoid division by zero
    if (twap_cap_step == 0) {
        twap_cap_step = 1;
    };

    Oracle {
        id: object::new(ctx),
        last_price: twap_initialization_price,
        last_timestamp: 0, // set to current time when trading starts
        total_cumulative_price: 0,
        last_window_end_cumulative_price: 0,
        last_window_end: 0, // set to current time when trading starts
        last_window_twap: twap_initialization_price,
        twap_start_delay: twap_start_delay,
        twap_cap_step: twap_cap_step,
        market_start_time: option::none(), // nullable so that TWAP is not valid if not properly initialized
        twap_initialization_price: twap_initialization_price,
    }
}

// === Private Functions ===
fun one_step_cap_price_change(twap_base: u128, new_price: u128, twap_cap_step: u64): u128 {
    if (new_price > twap_base) {
        // Cap upward movement: min(new_price, saturating_add(twap_base, max_change))
        u128::min(new_price, math::saturating_add(twap_base, (twap_cap_step as u128)))
    } else {
        // Cap downward movement: max(new_price, saturating_sub(twap_base, max_change))
        u128::max(new_price, math::saturating_sub(twap_base, (twap_cap_step as u128)))
    }
}

// Called before swaps, LP events and before reading TWAP
public fun write_observation(oracle: &mut Oracle, timestamp: u64, price: u128) {
    // Sanity time checks
    assert!(oracle.market_start_time.is_some(), EMarketNotStarted);
    let market_start_time_val = *oracle.market_start_time.borrow();
    assert!(timestamp >= oracle.last_timestamp, ETimestampRegression);

    let delay_threshold = market_start_time_val + oracle.twap_start_delay;
    // --- Case 0: No time has passed ---
    if (timestamp == oracle.last_timestamp) {
        // If last_price update is not needed here, just return.
        // twap_accumulate would also do nothing if called with 0 duration.
        return
    };

    // --- Case 1: Current observation interval is entirely BEFORE delay_threshold ---
    if (oracle.last_timestamp < delay_threshold && timestamp < delay_threshold) {
        twap_accumulate(oracle, timestamp, price);
        return
    };

    // --- Case 2: Current observation interval CROSSES (or starts at and goes beyond) delay_threshold ---
    if (oracle.last_timestamp <= delay_threshold && timestamp >= delay_threshold) {
        // Part A: Process segment up to delay_threshold.
        if (delay_threshold > oracle.last_timestamp) {
            twap_accumulate(oracle, delay_threshold, price);
        };

        // Part B: RESET accumulators and mark the true start of the accumulation period.
        oracle.total_cumulative_price = 0;
        oracle.last_window_end_cumulative_price = 0;
        oracle.last_window_end = delay_threshold;

        // Part C: Process segment from delay_threshold to current `timestamp`.
        // This uses the fresh accumulators.
        if (timestamp > delay_threshold) {
            // Ensure there's a duration for this segment
            // twap_accumulate will use oracle.last_timestamp (which is delay_threshold)
            twap_accumulate(oracle, timestamp, price);
        };
        return
    };

    // --- Case 3: Current observation interval is entirely AT or AFTER delay_threshold ---
    if (oracle.last_timestamp >= delay_threshold) {
        twap_accumulate(oracle, timestamp, price);
        return
    }
}

fun twap_accumulate(oracle: &mut Oracle, timestamp: u64, price: u128) {
    // --- Input Validation ---
    // Ensure timestamp is not regressing
    assert!(timestamp >= oracle.last_timestamp, ETimestampRegression);
    // Ensure initial state is consistent (last_timestamp should not be before the window end it relates to)
    // This is a pre-condition check, assuming the state was valid before this call.
    assert!(oracle.last_timestamp >= oracle.last_window_end, ETimestampRegression);

    // --- Handle Edge Case: No time passed ---
    let time_since_last_update = timestamp - oracle.last_timestamp;

    // --- Stage 1: Accumulate for the initial partial window segment ---
    // This segment starts at oracle.last_timestamp and ends at the first of:
    // 1. The next window boundary (relative to oracle.last_window_end).
    // 2. The final input timestamp.

    let diff_from_last_boundary = oracle.last_timestamp - oracle.last_window_end;
    let elapsed_in_current_segment = diff_from_last_boundary % constants::twap_price_cap_window();

    let time_to_next_boundary = constants::twap_price_cap_window() - elapsed_in_current_segment;

    let duration_stage1 = std::u64::min(
        time_to_next_boundary, // Limit by the time until the next window boundary
        time_since_last_update, // Limit by the total time available until the target timestamp
    );

    if (duration_stage1 > 0) {
        let end_timestamp_stage1 = oracle.last_timestamp + duration_stage1;
        intra_window_accumulation(
            oracle, // Passes mutable reference, state will be updated
            price,
            duration_stage1,
            end_timestamp_stage1, // This timestamp becomes the new oracle.last_timestamp
        );
        // After this call, oracle.last_timestamp is updated to end_timestamp_stage1.
        // If end_timestamp_stage1 hit a window boundary, oracle.last_window_end and TWAP state are also updated.
    };

    // --- Stage 2: Process all full windows that fit *after* Stage 1 ended ---
    // The starting point for these full windows is the current oracle.last_timestamp
    // (which is the end timestamp of the segment processed in Stage 1).

    let time_remaining_after_stage1 = timestamp - oracle.last_timestamp; // Use updated oracle.last_timestamp

    if (time_remaining_after_stage1 >= constants::twap_price_cap_window()) {
        let num_full_windows = time_remaining_after_stage1 / constants::twap_price_cap_window();

        // Calculate the end timestamp after processing these full windows.
        // Start from the *current* oracle.last_timestamp (end of Stage 1 segment).
        let end_timestamp_stage2 =
            oracle.last_timestamp + num_full_windows * constants::twap_price_cap_window();

        multi_full_window_accumulation(
            oracle, // Passes mutable reference, state will be updated
            price,
            num_full_windows,
            end_timestamp_stage2, // This timestamp becomes the new oracle.last_timestamp and oracle.last_window_end
        );
        // After this call, oracle.last_timestamp and oracle.last_window_end are updated to end_timestamp_stage2.
        // The oracle's TWAP state (last_window_twap, cumulative_price) is also updated for these full windows.
    };

    // --- Stage 3: Process any remaining partial window after Stage 2 ended ---
    // The starting point is the current oracle.last_timestamp
    // (which is the end timestamp of the segment processed in Stage 2, or Stage 1 if Stage 2 was skipped).

    let duration_stage3 = timestamp - oracle.last_timestamp; // Use updated oracle.last_timestamp

    // If duration_stage3 > 0, there is time left to accumulate up to the final timestamp.
    if (duration_stage3 > 0) {
        intra_window_accumulation(
            oracle, // Passes mutable reference, state will be updated
            price,
            duration_stage3,
            timestamp, // The end timestamp for this final segment is the target timestamp
        );
        // After this call, oracle.last_timestamp is updated to the final input timestamp.
        // If the final timestamp hits a window boundary, oracle.last_window_end and TWAP state are also updated.
    };
    assert!(oracle.last_timestamp == timestamp, EInternalTwapError); // Assuming an internal error code
}

fun intra_window_accumulation(
    oracle: &mut Oracle,
    price: u128,
    additional_time_to_include: u64,
    timestamp: u64,
) {
    let capped_price = one_step_cap_price_change(
        oracle.last_window_twap,
        price,
        oracle.twap_cap_step,
    );

    // Add accumulation for the partial period within the current (still open) window
    let scaled_price = (capped_price as u256);
    let price_contribution = scaled_price * (additional_time_to_include as u256);
    oracle.total_cumulative_price = oracle.total_cumulative_price + price_contribution;

    let time_since_last_window_end = timestamp - oracle.last_window_end;
    oracle.last_timestamp = timestamp;
    oracle.last_price = (scaled_price as u128);

    event::emit(PriceEvent {
        last_price: oracle.last_price,
    });

    if (time_since_last_window_end == constants::twap_price_cap_window()) {
        // Update last window data on window boundary
        oracle.last_window_end = timestamp;
        oracle.last_window_twap = (
            (
                (oracle.total_cumulative_price - oracle.last_window_end_cumulative_price) / (constants::twap_price_cap_window() as u256),
            ) as u128,
        );
        oracle.last_window_end_cumulative_price = oracle.total_cumulative_price
    }
}

fun multi_full_window_accumulation(
    oracle: &mut Oracle,
    price: u128,
    num_new_windows: u64, // N_W
    timestamp: u64,
) {
    // Notation: v_ = value, n_ = number/count, k_ = index, s_ = sum, g_ = gap
    // G_abs = |P - B|
    let g_abs: u128;
    if (price > oracle.last_window_twap) {
        g_abs = price - oracle.last_window_twap;
    } else {
        g_abs = oracle.last_window_twap - price;
    };

    let k_cap_idx_u128: u128;
    if (g_abs == 0) {
        k_cap_idx_u128 = 0;
    } else if (oracle.twap_cap_step == 0) {
        // If step is 0 (from very small PPM), treat as unlimited steps
        k_cap_idx_u128 = (u64::max_value!() as u128);
    } else {
        k_cap_idx_u128 = (g_abs - 1) / (oracle.twap_cap_step as u128) + 1;
    };

    let k_cap_idx: u64;
    if (k_cap_idx_u128 > (u64::max_value!() as u128)) {
        k_cap_idx = u64::max_value!();
    } else {
        k_cap_idx = k_cap_idx_u128 as u64;
    };

    let k_ramp_limit: u64;
    if (k_cap_idx == 0) {
        k_ramp_limit = 0;
    } else {
        k_ramp_limit = k_cap_idx - 1;
    };

    // N_ramp_terms = min(N_W, k_ramp_limit)
    let n_ramp_terms = std::u64::min(num_new_windows, k_ramp_limit); // n_ramp_terms is u64

    // V_ramp = \Delta_M * N_ramp_terms * (N_ramp_terms + 1) / 2
    let v_ramp: u128;
    if (n_ramp_terms == 0) {
        v_ramp = 0;
    } else {
        let nrt_u128 = n_ramp_terms as u128;
        let sum_indices_part: u128;
        // Calculate nrt_u128 * (nrt_u128 + 1) / 2 safely to avoid overflow.
        // Max nrt_u128 is std::u64::MAX (~2^64).
        // (nrt_u128/2) * (nrt_u128+1) OR ((nrt_u128+1)/2) * nrt_u128 will be ~2^63 * 2^64 = 2^127, which fits u128.
        if (nrt_u128 % 2 == 0) {
            sum_indices_part = (nrt_u128 / 2) * (nrt_u128 + 1);
        } else {
            sum_indices_part = ((nrt_u128 + 1) / 2) * nrt_u128;
        };

        // Check for overflow: delta_max_per_step * sum_indices_part
        if (
            sum_indices_part > 0 && (oracle.twap_cap_step as u128) > 0 && (oracle.twap_cap_step as u128) > u128::max_value!() / sum_indices_part
        ) {
            abort (EOverflowVRamp)
        };
        v_ramp = (oracle.twap_cap_step as u128) * sum_indices_part;
    };

    // V_flat = G_abs * (N_W - N_ramp_terms)
    let num_flat_terms = num_new_windows - n_ramp_terms; // u64
    let v_flat: u128;
    if (num_flat_terms == 0) {
        v_flat = 0;
    } else {
        let nft_u128 = num_flat_terms as u128;
        // Check for overflow: g_abs * nft_u128
        if (nft_u128 > 0 && g_abs > 0 && g_abs > u128::max_value!() / nft_u128) {
            abort (EOverflowVFlat)
        };
        v_flat = g_abs * nft_u128;
    };

    // S_dev_mag = V_ramp + V_flat
    // Check for overflow: v_ramp + v_flat
    if (v_ramp > u128::max_value!() - v_flat) {
        // Equivalent to v_ramp + v_flat > u128::max_value!()
        abort (EOverflowSDevMag)
    };
    let s_dev_mag = v_ramp + v_flat;

    // V_sum_prices = N_W * B + sign(P-B) * S_dev_mag
    let base_price_sum: u128;
    let nw_u128 = num_new_windows as u128;
    // Check for overflow: oracle.last_window_twap * nw_u128
    if (
        nw_u128 > 0 && oracle.last_window_twap > 0 && oracle.last_window_twap > u128::max_value!() / nw_u128
    ) {
        abort (EOverflowBasePriceSumFinal)
    };
    base_price_sum = oracle.last_window_twap * nw_u128;

    let v_sum_prices: u128;
    if (price >= oracle.last_window_twap) {
        // sign(P-B) is 0 or 1
        // Check for overflow: base_price_sum + s_dev_mag
        if (base_price_sum > u128::max_value!() - s_dev_mag) {
            abort (EOverflowVSumPricesAdd)
        };
        v_sum_prices = base_price_sum + s_dev_mag;
    } else {
        // sign(P-B) is -1
        // Since P'_i = B - dev_i, and we assume price (P) >= 0,
        // then P'_i >= 0 (as B - dev_i >= P >= 0).
        // So sum of P'_i (which is V_sum_prices) must be >= 0.
        // This also implies N_W * B >= S_dev_mag.
        // Thus, base_price_sum >= s_dev_mag, and subtraction will not underflow below zero.
        v_sum_prices = base_price_sum - s_dev_mag;
    };

    // P'_N_W = B + sign(P-B) * min(N_W * \Delta_M, G_abs)
    let p_n_w_effective: u128;

    // Calculate N_W * \Delta_M
    // delta_max_per_step is > 0 here. num_new_windows > 0.
    // No overflow possible: num_new_windows is u64, twap_cap_step is u64
    let nw_times_delta_m = (num_new_windows as u128) * (oracle.twap_cap_step as u128);

    let deviation_for_p_n_w = std::u128::min(nw_times_delta_m, g_abs);

    if (price >= oracle.last_window_twap) {
        p_n_w_effective = math::saturating_add(oracle.last_window_twap, deviation_for_p_n_w);
    } else {
        // price < oracle.last_window_twap
        p_n_w_effective = math::saturating_sub(oracle.last_window_twap, deviation_for_p_n_w);
    };

    oracle.last_timestamp = timestamp;
    oracle.last_window_end = timestamp;
    let cumulative_price_contribution =
        (v_sum_prices as u256) * (constants::twap_price_cap_window() as u256);
    oracle.last_window_end_cumulative_price =
        oracle.total_cumulative_price + cumulative_price_contribution;
    oracle.total_cumulative_price = oracle.total_cumulative_price + cumulative_price_contribution;
    oracle.last_price = p_n_w_effective;

    event::emit(PriceEvent {
        last_price: oracle.last_price,
    });

    oracle.last_window_twap = p_n_w_effective;
}

/// ARCHITECTURAL DECISION: Mutation-Required TWAP Oracle
///
/// This oracle REQUIRES write_observation() before get_twap() in the same transaction.
/// The assertion `current_time == oracle.last_timestamp` is INTENTIONAL.
///
/// Why this differs from read-only TWAP patterns:
/// - Stale prices are attack vectors, not features
/// - Interpolation adds complexity and manipulation surface
/// - The AMM determines prices; the oracle just tracks them
/// - Every TWAP read MUST reflect current AMM state
///
/// This design makes it IMPOSSIBLE to:
/// ‚úó Read stale/manipulated TWAPs
/// ‚úó Forget to update before critical operations
/// ‚úó Have price inconsistency within a transaction
///
/// This pattern differs from typical read-only oracles by design.
/// Serving stale TWAPs for "cleaner interfaces" is how protocols get exploited.
///
/// The AMM's get_twap() handles the update + read atomically.
/// The oracle just validates freshness. This is correct.
public fun get_twap(oracle: &Oracle, clock: &Clock): u128 {
    assert!(oracle.market_start_time.is_some(), EMarketNotStarted);
    let market_start_time_val = *oracle.market_start_time.borrow();
    let current_time = clock.timestamp_ms();

    // REQUIRED: Caller must have called write_observation() in this same transaction
    // This ensures TWAP is always fresh and prevents stale price exploitation
    assert!(current_time == oracle.last_timestamp, EStaleTwap);

    // Time checks
    assert!(oracle.last_timestamp != 0, ETimestampRegression);
    assert!(current_time - market_start_time_val >= oracle.twap_start_delay, ETwapNotStarted);
    assert!(current_time >= market_start_time_val, ETimestampRegression);

    // Calculate period
    let period = ( current_time - market_start_time_val) - oracle.twap_start_delay;
    assert!(period > 0, EZeroPeriod);

    // Calculate TWAP - dividing cumulative price by period gives average price
    // Safe cast: For reasonable token prices over max 7-day proposals,
    // TWAP will be far below u128::MAX (even 10^18 price √ó 7 days / period ‚âà 10^15)
    let twap = (oracle.total_cumulative_price) / (period as u256);

    (twap as u128)
}

public fun set_oracle_start_time(oracle: &mut Oracle, market_start_time_param: u64) {
    // Prevent re-initialization
    assert!(oracle.market_start_time.is_none(), EMarketAlreadyStarted);

    oracle.market_start_time = option::some(market_start_time_param);
    oracle.last_window_end = market_start_time_param;
    oracle.last_timestamp = market_start_time_param;
}

// === View Functions ===
public fun last_price(oracle: &Oracle): u128 {
    oracle.last_price
}

public fun last_timestamp(oracle: &Oracle): u64 {
    oracle.last_timestamp
}

public fun config(oracle: &Oracle): (u64, u64) {
    (oracle.twap_start_delay, oracle.twap_cap_step)
}

public fun market_start_time(oracle: &Oracle): Option<u64> {
    oracle.market_start_time
}

public fun twap_initialization_price(oracle: &Oracle): u128 {
    oracle.twap_initialization_price
}

public fun total_cumulative_price(oracle: &Oracle): u256 {
    oracle.total_cumulative_price
}

public fun id(o: &Oracle): &UID {
    &o.id
}

// === Test Functions ===
#[test_only]
use std::debug;

#[test_only]
public fun debug_print_state(oracle: &Oracle) {
    debug::print(&b"Oracle State:");
    debug::print(&oracle.last_price);
    debug::print(&oracle.last_timestamp);
    debug::print(&oracle.total_cumulative_price);
}

#[test_only]
public fun debug_get_state(oracle: &Oracle): (u128, u64, u256) {
    (oracle.last_price, oracle.last_timestamp, oracle.total_cumulative_price)
}

#[test_only]
public fun test_oracle(ctx: &mut TxContext): Oracle {
    new_oracle(
        10000, // twap_initialization_price
        60_000, // twap_start_delay
        1000, // twap_cap_ppm (0.1% of initialization price)
        ctx,
    )
}

#[test_only]
public fun destroy_for_testing(oracle: Oracle) {
    let Oracle {
        id,
        last_price: _,
        last_timestamp: _,
        total_cumulative_price: _,
        last_window_end: _,
        last_window_end_cumulative_price: _,
        last_window_twap: _,
        twap_start_delay: _,
        twap_cap_step: _,
        market_start_time: _,
        twap_initialization_price: _,
    } = oracle;
    id.delete();
}

#[test_only]
public fun debug_get_window_twap(oracle: &Oracle): u128 {
    oracle.last_window_twap
}

#[test_only]
public fun is_twap_valid(oracle: &Oracle, min_period: u64, clock: &Clock): bool {
    let current_time = clock.timestamp_ms();
    current_time >= oracle.last_timestamp + min_period
}

#[test_only]
public fun debug_get_full_state(
    oracle: &Oracle,
): (
    u128, // last_price
    u64, // last_timestamp
    u256, // total_cumulative_price
    u256, // last_window_end_cumulative_price
    u64, // last_window_end
    u128, // last_window_twap
    Option<u64>, // market_start_time
    u128, // twap_initialization_price
    u64, // twap_start_delay
    u64, // twap_cap_step
) {
    (
        oracle.last_price,
        oracle.last_timestamp,
        oracle.total_cumulative_price,
        oracle.last_window_end_cumulative_price,
        oracle.last_window_end,
        oracle.last_window_twap,
        oracle.market_start_time,
        oracle.twap_initialization_price,
        oracle.twap_start_delay,
        oracle.twap_cap_step,
    )
}

#[test_only]
public fun set_last_timestamp_for_testing(oracle: &mut Oracle, new_last_timestamp: u64) {
    oracle.last_timestamp = new_last_timestamp;
}

#[test_only]
public fun set_last_window_end_for_testing(oracle: &mut Oracle, new_last_window_end: u64) {
    oracle.last_window_end = new_last_window_end;
}

#[test_only]
public fun set_last_window_twap_for_testing(oracle: &mut Oracle, new_last_window_twap: u128) {
    oracle.last_window_twap = new_last_window_twap;
}

#[test_only]
public fun set_cumulative_prices_for_testing(
    oracle: &mut Oracle,
    total_cumulative_price: u256,
    last_window_end_cumulative_price: u256,
) {
    oracle.total_cumulative_price = total_cumulative_price;
    oracle.last_window_end_cumulative_price = last_window_end_cumulative_price;
}

#[test_only]
public fun call_twap_accumulate_for_testing(oracle: &mut Oracle, timestamp: u64, price: u128) {
    twap_accumulate(oracle, timestamp, price);
}

#[test_only]
public fun get_last_window_end_cumulative_price_for_testing(oracle: &Oracle): u256 {
    oracle.last_window_end_cumulative_price
}

#[test_only]
public fun get_total_cumulative_price_for_testing(oracle: &Oracle): u256 {
    oracle.total_cumulative_price
}

#[test_only]
public fun get_last_window_end_for_testing(oracle: &Oracle): u64 {
    oracle.last_window_end
}

#[test_only]
public fun call_intra_window_accumulation_for_testing(
    oracle: &mut Oracle,
    price: u128,
    additional_time_to_include: u64,
    timestamp: u64,
) {
    intra_window_accumulation(
        oracle,
        price,
        additional_time_to_include,
        timestamp,
    );
}

#[test_only]
public fun call_multi_full_window_accumulation_for_testing(
    oracle: &mut Oracle,
    price: u128,
    num_new_windows: u64,
    timestamp: u64,
) {
    multi_full_window_accumulation(
        oracle,
        price,
        num_new_windows,
        timestamp,
    );
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Fee scheduling module for dynamic AMM fees
/// Supports linear decay from high launch fees (99%) to standard spot fees (0.3%)
/// After decay period ends, pool uses the final_fee_bps as the permanent spot fee
/// Simplified linear decay for gas efficiency and predictability
module futarchy_markets_primitives::fee_scheduler;

// === Errors ===
const EInitialFeeTooHigh: u64 = 0;
const EDurationTooLong: u64 = 1;
const EDecayOverflow: u64 = 2;

// === Constants ===
const MAX_INITIAL_FEE_BPS: u64 = 9900; // 99% maximum (DAO policy)
const MAX_DURATION_MS: u64 = 86_400_000; // 24 hours maximum
const FEE_SCALE: u64 = 10000; // 100% in basis points
const PRECISION_SCALE: u128 = 10000; // Scaling factor to avoid precision loss in division

// === Structs ===

/// Fee schedule configuration for linear decay from high launch fee to spot fee
/// Simplified API: just specify initial MEV fee and duration
/// Final fee comes from the pool's base spot_amm_fee_bps (set in pool, not here)
/// Fee decays linearly: fee(t) = initial_fee - (initial_fee - final_fee) * (t / duration)
public struct FeeSchedule has store, copy, drop {
    /// Initial MEV protection fee in basis points (0-9900, e.g., 9900 = 99%)
    initial_fee_bps: u64,

    /// Total duration of fee decay in milliseconds (0-86400000 = 0-24 hours)
    /// If 0, MEV protection is skipped (use base pool fee immediately)
    duration_ms: u64,
}

// === Public Functions ===

/// Create a new fee schedule with linear decay
///
/// Schedules linear decay from high initial MEV fee (0-99%) to the pool's base spot fee.
/// After the decay period ends, the pool permanently uses its base spot_amm_fee_bps.
///
/// # Parameters
/// - initial_fee_bps: Initial MEV protection fee (0-9900 bps = 0%-99%)
/// - duration_ms: Duration of decay period (0-86400000 ms = 0-24 hours)
///
/// # Constraints
/// - initial_fee_bps must be <= 9900 (99% maximum - DAO policy)
/// - duration_ms must be <= 86_400_000 (24 hours maximum)
/// - If duration_ms is 0, MEV protection is skipped entirely
/// - If initial_fee_bps is 0, effectively no MEV protection
///
/// # Decay Formula
/// fee(t) = initial_fee_bps - (initial_fee_bps - final_fee_bps) * (t / duration_ms)
/// where final_fee_bps comes from pool's base spot_amm_fee_bps
public fun new_schedule(
    initial_fee_bps: u64,
    duration_ms: u64,
): FeeSchedule {
    // Validate parameters
    assert!(initial_fee_bps <= FEE_SCALE, EInitialFeeTooHigh); // Can't exceed 100%
    assert!(initial_fee_bps <= MAX_INITIAL_FEE_BPS, EInitialFeeTooHigh); // DAO policy: max 99%
    assert!(duration_ms <= MAX_DURATION_MS, EDurationTooLong);

    FeeSchedule {
        initial_fee_bps,
        duration_ms,
    }
}

/// Calculate current fee based on elapsed time and pool's base fee
/// Uses LINEAR decay (simple, fast, predictable)
///
/// # Edge cases (hard-coded):
/// - t = 0: return initial_fee_bps (max MEV protection)
/// - t >= duration: return final_fee_bps (spot fee)
/// - duration = 0: skip MEV, always return final_fee_bps
///
/// # Linear decay (0 < t < duration):
/// - Formula: fee(t) = initial - (initial - final) * (t / duration)
/// - Smooth decay every millisecond
/// - Guaranteed to reach final_fee exactly at duration end
/// - Fast: just 2 multiplications, 2 divisions
public fun get_current_fee(
    schedule: &FeeSchedule,
    final_fee_bps: u64,
    start_time: u64,
    current_time: u64,
): u64 {
    // Edge case: duration = 0, skip MEV protection
    if (schedule.duration_ms == 0) {
        return final_fee_bps
    };

    // Edge case: if final fee >= initial fee, no decay needed
    if (final_fee_bps >= schedule.initial_fee_bps) {
        return final_fee_bps
    };

    // Edge case: before start, return initial fee (max protection)
    if (current_time <= start_time) {
        return schedule.initial_fee_bps
    };

    let elapsed = current_time - start_time;

    // Edge case: after duration ends, return final fee (spot fee)
    if (elapsed >= schedule.duration_ms) {
        return final_fee_bps
    };

    // Linear interpolation: fee(t) = initial - (initial - final) * (t / duration)
    let fee_drop = schedule.initial_fee_bps - final_fee_bps;

    // Scale elapsed by PRECISION_SCALE to avoid precision loss in division
    let progress = ((elapsed as u128) * PRECISION_SCALE) / (schedule.duration_ms as u128);
    let decay_amount = ((fee_drop as u128) * progress) / PRECISION_SCALE;

    // Safety: ensure decay_amount doesn't overflow u64 before subtraction
    // Given constraints: fee_drop <= 9900, progress <= 10000, result <= 9900 (always fits in u64)
    assert!(decay_amount <= (schedule.initial_fee_bps as u128), EDecayOverflow);

    let current_fee = schedule.initial_fee_bps - (decay_amount as u64);

    // Clamp to final_fee_bps (safety for rounding)
    if (current_fee < final_fee_bps) {
        final_fee_bps
    } else {
        current_fee
    }
}

/// Create default launch protection schedule: 99% ‚Üí spot fee over 2 hours
/// Uses linear decay (simple and gas-efficient)
public fun default_launch_schedule(): FeeSchedule {
    FeeSchedule {
        initial_fee_bps: 9900,        // 99% MEV protection fee
        duration_ms: 7_200_000,       // 2 hours
    }
}

// === Getters ===

public fun initial_fee_bps(schedule: &FeeSchedule): u64 {
    schedule.initial_fee_bps
}

public fun duration_ms(schedule: &FeeSchedule): u64 {
    schedule.duration_ms
}

/// Get maximum allowed initial fee (DAO policy)
public fun max_initial_fee_bps(): u64 {
    MAX_INITIAL_FEE_BPS
}

/// Get maximum allowed duration
public fun max_duration_ms(): u64 {
    MAX_DURATION_MS
}

/// Get fee scale (100% in basis points)
public fun fee_scale(): u64 {
    FEE_SCALE
}

// === Test Helpers ===

#[test_only]
public fun new_schedule_for_testing(
    initial: u64,
    duration: u64,
): FeeSchedule {
    new_schedule(initial, duration)
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Balance-based conditional market position tracking
///
/// This module provides a type-agnostic way to track conditional market positions
/// without requiring N type parameters. Instead of tracking Coin<Cond0Asset>, Coin<Cond1Asset>, etc.,
/// we track balances as u64 values in a dense vector.
///
/// **Key Innovation:** Eliminates type explosion by decoupling balance tracking from types.
/// Users only need typed coins when unwrapping to use in external DeFi.
///
/// **Storage Layout:**
/// balances = [out0_asset, out0_stable, out1_asset, out1_stable, ...]
/// Index formula: idx = (outcome_idx * 2) + (is_asset ? 0 : 1)

module futarchy_markets_primitives::conditional_balance;

use futarchy_markets_primitives::coin_escrow;
use std::string::{Self, String};
use std::vector;
use sui::coin::Coin;
use sui::display::{Self, Display};
use sui::event;
use sui::object::{Self, UID, ID};
use sui::package::{Self, Publisher};

// === One-Time Witness ===
public struct CONDITIONAL_BALANCE has drop {}

// === Errors ===
const EInvalidOutcomeIndex: u64 = 0;
const EInvalidBalanceAccess: u64 = 1;
const ENotEmpty: u64 = 2;
const EInsufficientBalance: u64 = 3;
const EInvalidOutcomeCount: u64 = 4;
const EOutcomeCountExceedsMax: u64 = 5;
const EProposalMismatch: u64 = 6;
const EOutcomeNotRegistered: u64 = 7;

// === Constants ===
const VERSION: u8 = 1;
const MIN_OUTCOMES: u8 = 2;
const MAX_OUTCOMES: u8 = 200;

// === Events ===

/// Emitted when balance is unwrapped to a typed coin
public struct BalanceUnwrapped has copy, drop {
    balance_id: ID,
    outcome_idx: u8,
    is_asset: bool,
    amount: u64,
}

/// Emitted when a typed coin is wrapped back to balance
public struct BalanceWrapped has copy, drop {
    balance_id: ID,
    outcome_idx: u8,
    is_asset: bool,
    amount: u64,
}

// === Structs ===

/// Balance object tracking all conditional market positions
///
/// This object stores balances for ALL outcomes in a single dense vector.
/// No type parameters for conditional coins - only phantom types for base coins.
///
/// Example for 3 outcomes:
/// balances[0] = Outcome 0 asset balance
/// balances[1] = Outcome 0 stable balance
/// balances[2] = Outcome 1 asset balance
/// balances[3] = Outcome 1 stable balance
/// balances[4] = Outcome 2 asset balance
/// balances[5] = Outcome 2 stable balance
public struct ConditionalMarketBalance<phantom AssetType, phantom StableType> has key, store {
    id: UID,
    market_id: ID, // ID of the market this balance belongs to
    outcome_count: u8,
    version: u8, // For future migrations
    /// Dense vector: [out0_asset, out0_stable, out1_asset, out1_stable, ...]
    /// Index formula: idx = (outcome_idx * 2) + (is_asset ? 0 : 1)
    balances: vector<u64>,
}

// === Display ===

/// Create display for conditional balance NFTs
///
/// Shows balance as basic NFT in wallets with image, name, description.
/// No wrapper needed - balance object IS the NFT.
///
/// Uses template syntax `{id}` to show unique object ID so users can:
/// - Identify which NFT has value
/// - Track positions across multiple swaps
/// - Know whether to burn/merge/hold
public fun create_display(
    otw: CONDITIONAL_BALANCE,
    ctx: &mut TxContext,
): (Publisher, Display<ConditionalMarketBalance<sui::sui::SUI, sui::sui::SUI>>) {
    let publisher = package::claim(otw, ctx);

    let mut display = display::new<ConditionalMarketBalance<sui::sui::SUI, sui::sui::SUI>>(
        &publisher,
        ctx,
    );

    // NFT fields with dynamic object ID for user identification
    // Template syntax {id} gets filled with actual object ID by Sui
    display::add(&mut display, string::utf8(b"name"), string::utf8(b"Govex Incomplete Set - {id}"));
    display::add(
        &mut display,
        string::utf8(b"description"),
        string::utf8(
            b"Incomplete conditional token set from Govex futarchy. Contains dust from spot swaps. Object ID: {id}. Check if this has value before burning. Redeem after proposal resolves to claim winning outcome.",
        ),
    );
    display::add(
        &mut display,
        string::utf8(b"image_url"),
        string::utf8(b"https://govex.ai/nft/incomplete-set.png"),
    );
    display::add(&mut display, string::utf8(b"project_url"), string::utf8(b"https://govex.ai"));
    display::add(&mut display, string::utf8(b"creator"), string::utf8(b"Govex protocol"));

    display::update_version(&mut display);

    (publisher, display)
}

// === Creation ===

/// Create new balance object for a proposal
///
/// Initializes with zero balances for all outcomes.
/// Used when starting arbitrage or when user wants to track positions.
///
/// # Arguments
/// * `outcome_count` - Number of outcomes (must be between 2 and 200)
///
/// # Panics
/// * If outcome_count < 2 or > 200
public fun new<AssetType, StableType>(
    market_id: ID,
    outcome_count: u8,
    ctx: &mut TxContext,
): ConditionalMarketBalance<AssetType, StableType> {
    // Validate outcome count
    assert!(outcome_count >= MIN_OUTCOMES, EInvalidOutcomeCount);
    assert!(outcome_count <= MAX_OUTCOMES, EOutcomeCountExceedsMax);

    // Initialize with zeros for all outcomes
    // Each outcome has 2 slots: asset (even idx) and stable (odd idx)
    let size = (outcome_count as u64) * 2;
    let balances = vector::tabulate!(size, |_| 0u64);

    ConditionalMarketBalance {
        id: object::new(ctx),
        market_id,
        outcome_count,
        version: VERSION,
        balances,
    }
}

// === Balance Access ===

/// Get balance for specific outcome + type
///
/// # Arguments
/// * `outcome_idx` - Which outcome (0, 1, 2, ...)
/// * `is_asset` - true for asset balance, false for stable balance
public fun get_balance<AssetType, StableType>(
    balance: &ConditionalMarketBalance<AssetType, StableType>,
    outcome_idx: u8,
    is_asset: bool,
): u64 {
    assert!((outcome_idx as u64) < (balance.outcome_count as u64), EInvalidOutcomeIndex);
    let idx = calculate_index(outcome_idx, is_asset);
    *vector::borrow(&balance.balances, idx)
}

/// Set balance for specific outcome + type
///
/// Directly replaces the balance value.
public fun set_balance<AssetType, StableType>(
    balance: &mut ConditionalMarketBalance<AssetType, StableType>,
    outcome_idx: u8,
    is_asset: bool,
    amount: u64,
) {
    assert!((outcome_idx as u64) < (balance.outcome_count as u64), EInvalidOutcomeIndex);
    let idx = calculate_index(outcome_idx, is_asset);
    *vector::borrow_mut(&mut balance.balances, idx) = amount;
}

/// Add to balance (quantum mint pattern)
///
/// Used when depositing coins for quantum liquidity.
/// The same amount gets added to ALL outcomes simultaneously.
public fun add_to_balance<AssetType, StableType>(
    balance: &mut ConditionalMarketBalance<AssetType, StableType>,
    outcome_idx: u8,
    is_asset: bool,
    amount: u64,
) {
    assert!((outcome_idx as u64) < (balance.outcome_count as u64), EInvalidOutcomeIndex);
    let idx = calculate_index(outcome_idx, is_asset);
    let current = vector::borrow_mut(&mut balance.balances, idx);
    *current = *current + amount;
}

/// Subtract from balance
///
/// Used when swapping or burning conditional coins.
/// Aborts if insufficient balance.
public fun sub_from_balance<AssetType, StableType>(
    balance: &mut ConditionalMarketBalance<AssetType, StableType>,
    outcome_idx: u8,
    is_asset: bool,
    amount: u64,
) {
    assert!((outcome_idx as u64) < (balance.outcome_count as u64), EInvalidOutcomeIndex);
    let idx = calculate_index(outcome_idx, is_asset);
    let current = vector::borrow_mut(&mut balance.balances, idx);
    assert!(*current >= amount, EInsufficientBalance);
    *current = *current - amount;
}

// === Utility Functions ===

/// Find minimum balance across all outcomes for given type
///
/// Used to determine complete set size (can only burn/redeem complete sets).
/// In arbitrage, this represents the maximum amount we can withdraw as profit.
///
/// Returns 0 if all balances are 0 (correct behavior for empty balance).
public fun find_min_balance<AssetType, StableType>(
    balance: &ConditionalMarketBalance<AssetType, StableType>,
    is_asset: bool,
): u64 {
    // Start with first outcome's balance instead of u64::max to handle empty case
    let mut min = get_balance(balance, 0, is_asset);
    let mut i = 1u8;

    while ((i as u64) < (balance.outcome_count as u64)) {
        let bal = get_balance(balance, i, is_asset);
        if (bal < min) {
            min = bal;
        };
        i = i + 1;
    };

    min
}

/// Merge all balances from source into destination with zero-skipping optimization
///
/// Optimized for sparse incomplete sets (typical case: 1-2 non-zero outcomes).
/// Used when same recipient swaps multiple times - accumulates into one position.
///
/// # Performance
/// - **Best case** (all zeros): N operations (read src only)
/// - **Typical case** (2 non-zero in 3-outcome market): N + 4 operations (67% faster than 3N)
/// - **Worst case** (all non-zero): 3N operations (read dest + read src + write dest per slot)
///
/// Where N = outcome_count √ó 2 (asset + stable per outcome)
///
/// # Arguments
/// * `dest` - Destination balance (will be modified)
/// * `src` - Source balance (will be consumed)
///
/// # Panics
/// * If market_id doesn't match
/// * If outcome_count doesn't match
public fun merge<AssetType, StableType>(
    dest: &mut ConditionalMarketBalance<AssetType, StableType>,
    src: ConditionalMarketBalance<AssetType, StableType>,
) {
    // Validate compatibility
    assert!(dest.market_id == src.market_id, EProposalMismatch);
    assert!(dest.outcome_count == src.outcome_count, EInvalidOutcomeCount);

    // Merge with zero-skipping optimization
    // Most incomplete sets have only 1-2 non-zero outcomes, so skip processing zeros
    let mut i = 0;
    let len = vector::length(&src.balances);
    while (i < len) {
        let src_val = *vector::borrow(&src.balances, i);
        // Only process non-zero source values (33-67% faster for typical sparse data)
        if (src_val > 0) {
            let dest_val = *vector::borrow(&dest.balances, i);
            *vector::borrow_mut(&mut dest.balances, i) = dest_val + src_val;
        };
        i = i + 1;
    };

    // Destroy source (now logically empty after merge)
    let ConditionalMarketBalance { id, market_id: _, outcome_count: _, version: _, balances: _ } =
        src;
    object::delete(id);
}

/// Check if all balances are zero
///
/// Used before destroying the balance object.
public fun is_empty<AssetType, StableType>(
    balance: &ConditionalMarketBalance<AssetType, StableType>,
): bool {
    is_empty_vector(&balance.balances)
}

/// Destroy balance object (must be empty)
///
/// Aborts if any balance is non-zero.
/// This ensures we don't accidentally lose funds.
public fun destroy_empty<AssetType, StableType>(
    balance: ConditionalMarketBalance<AssetType, StableType>,
) {
    let ConditionalMarketBalance { id, market_id: _, outcome_count: _, version: _, balances } =
        balance;
    assert!(is_empty_vector(&balances), ENotEmpty);
    object::delete(id);
}

// === Getters ===

/// Get the market ID this balance tracks
public fun market_id<AssetType, StableType>(
    balance: &ConditionalMarketBalance<AssetType, StableType>,
): ID {
    balance.market_id
}

/// Get the number of outcomes
public fun outcome_count<AssetType, StableType>(
    balance: &ConditionalMarketBalance<AssetType, StableType>,
): u8 {
    balance.outcome_count
}

/// Get immutable reference to balance vector (for advanced operations)
public fun borrow_balances<AssetType, StableType>(
    balance: &ConditionalMarketBalance<AssetType, StableType>,
): &vector<u64> {
    &balance.balances
}

/// Get object ID
public fun id<AssetType, StableType>(
    balance: &ConditionalMarketBalance<AssetType, StableType>,
): ID {
    object::uid_to_inner(&balance.id)
}

// === Internal Helpers ===

/// Calculate vector index from outcome + type
///
/// Formula: idx = (outcome_idx * 2) + (is_asset ? 0 : 1)
/// - Even indices (0, 2, 4, ...) = asset balances
/// - Odd indices (1, 3, 5, ...) = stable balances
fun calculate_index(outcome_idx: u8, is_asset: bool): u64 {
    (outcome_idx as u64) * 2 + (if (is_asset) { 0 } else { 1 })
}

/// Check if vector is all zeros
fun is_empty_vector(vec: &vector<u64>): bool {
    let mut i = 0;
    while (i < vector::length(vec)) {
        if (*vector::borrow(vec, i) != 0) {
            return false
        };
        i = i + 1;
    };
    true
}

// === Unwrap/Wrap Functions ===

/// Unwrap balance to get actual Coin<ConditionalType>
///
/// PUBLIC: Users need this to convert balances to typed coins for external DeFi protocols.
///
/// This converts a balance amount into a real typed Coin that can be used
/// in external DeFi protocols or traded on DEXes.
///
/// # Security
/// * Validates escrow matches balance's proposal_id (prevents cross-market minting)
/// * Validates outcome is registered in escrow
/// * Emits event for off-chain tracking
///
/// # Arguments
/// * `balance` - The balance object to unwrap from
/// * `escrow` - Token escrow to mint the conditional coin (MUST match balance's proposal)
/// * `outcome_idx` - Which outcome to unwrap
/// * `is_asset` - true for asset, false for stable
///
/// # Returns
/// * Typed Coin<ConditionalCoinType> that can be used externally
///
/// # Aborts
/// * `EProposalMismatch` - If escrow doesn't match balance's proposal_id
/// * `EOutcomeNotRegistered` - If outcome_idx not registered in escrow
/// * `EInvalidBalanceAccess` - If balance is zero or outcome_idx invalid
///
/// # Example
/// ```move
/// // User has outcome 0 asset balance of 1000
/// let coin = conditional_balance::unwrap_to_coin<SUI, USDC, Cond0Asset>(
///     &mut balance,
///     &mut escrow,
///     0,      // outcome_idx
///     true,   // is_asset
///     ctx
/// );
/// // Now user has a Coin<Cond0Asset> worth 1000
/// ```
public fun unwrap_to_coin<AssetType, StableType, ConditionalCoinType>(
    balance: &mut ConditionalMarketBalance<AssetType, StableType>,
    escrow: &mut coin_escrow::TokenEscrow<AssetType, StableType>,
    outcome_idx: u8,
    is_asset: bool,
    ctx: &mut TxContext,
): Coin<ConditionalCoinType> {
    // CRITICAL: Validate escrow matches balance's market
    let escrow_market_id = coin_escrow::market_state_id(escrow);
    assert!(balance.market_id == escrow_market_id, EProposalMismatch);

    // Validate outcome is registered in escrow
    let registered_count = coin_escrow::caps_registered_count(escrow);
    assert!((outcome_idx as u64) < registered_count, EOutcomeNotRegistered);

    // Get current balance
    let amount = get_balance(balance, outcome_idx, is_asset);
    assert!(amount > 0, EInvalidBalanceAccess);

    // CORRECT ORDER: Mint first, then clear balance
    // This ensures if minting fails, balance isn't lost
    let coin = coin_escrow::mint_conditional<AssetType, StableType, ConditionalCoinType>(
        escrow,
        (outcome_idx as u64),
        is_asset,
        amount,
        ctx,
    );

    // Only clear balance after successful mint
    set_balance(balance, outcome_idx, is_asset, 0);

    // Emit event for off-chain tracking
    event::emit(BalanceUnwrapped {
        balance_id: id(balance),
        outcome_idx,
        is_asset,
        amount,
    });

    coin
}

/// Wrap coin back into balance
///
/// PUBLIC: Users need this to convert typed coins back to balances from external DeFi.
///
/// This converts a typed Coin back into a balance amount.
/// Useful when bringing coins back from external DeFi protocols.
///
/// # Security
/// * Validates escrow matches balance's proposal_id (prevents cross-market burning)
/// * Validates outcome is registered in escrow
/// * Validates coin amount is non-zero
/// * Emits event for off-chain tracking
///
/// # Arguments
/// * `balance` - The balance object to add to
/// * `escrow` - Token escrow to burn the conditional coin (MUST match balance's proposal)
/// * `coin` - The conditional coin to wrap
/// * `outcome_idx` - Which outcome this coin belongs to
/// * `is_asset` - true for asset, false for stable
///
/// # Aborts
/// * `EProposalMismatch` - If escrow doesn't match balance's proposal_id
/// * `EOutcomeNotRegistered` - If outcome_idx not registered in escrow
/// * `EInvalidBalanceAccess` - If coin amount is zero or outcome_idx invalid
///
/// # Example
/// ```move
/// // User receives Coin<Cond0Asset> from external DEX
/// conditional_balance::wrap_coin<SUI, USDC, Cond0Asset>(
///     &mut balance,
///     &mut escrow,
///     coin,
///     0,      // outcome_idx
///     true,   // is_asset
/// );
/// // Now balance has been increased by coin amount
/// ```
public fun wrap_coin<AssetType, StableType, ConditionalCoinType>(
    balance: &mut ConditionalMarketBalance<AssetType, StableType>,
    escrow: &mut coin_escrow::TokenEscrow<AssetType, StableType>,
    coin: Coin<ConditionalCoinType>,
    outcome_idx: u8,
    is_asset: bool,
) {
    // CRITICAL: Validate escrow matches balance's market
    let escrow_market_id = coin_escrow::market_state_id(escrow);
    assert!(balance.market_id == escrow_market_id, EProposalMismatch);

    // Validate outcome is registered in escrow
    let registered_count = coin_escrow::caps_registered_count(escrow);
    assert!((outcome_idx as u64) < registered_count, EOutcomeNotRegistered);

    let amount = coin.value();
    assert!(amount > 0, EInvalidBalanceAccess); // Consistency with unwrap

    // Burn coin back to escrow
    coin_escrow::burn_conditional<AssetType, StableType, ConditionalCoinType>(
        escrow,
        (outcome_idx as u64),
        is_asset,
        coin,
    );

    // Add to balance
    add_to_balance(balance, outcome_idx, is_asset, amount);

    // Emit event for off-chain tracking
    event::emit(BalanceWrapped {
        balance_id: id(balance),
        outcome_idx,
        is_asset,
        amount,
    });
}

// === Test Helpers ===

#[test_only]
/// Create balance with non-zero initial amounts (for testing)
public fun new_with_amounts<AssetType, StableType>(
    market_id: ID,
    outcome_count: u8,
    initial_amounts: vector<u64>,
    ctx: &mut TxContext,
): ConditionalMarketBalance<AssetType, StableType> {
    assert!(vector::length(&initial_amounts) == (outcome_count as u64) * 2, 0);

    ConditionalMarketBalance {
        id: object::new(ctx),
        market_id,
        outcome_count,
        version: VERSION,
        balances: initial_amounts,
    }
}

#[test_only]
/// Get mutable reference to balances (for testing)
public fun borrow_balances_mut_for_testing<AssetType, StableType>(
    balance: &mut ConditionalMarketBalance<AssetType, StableType>,
): &mut vector<u64> {
    &mut balance.balances
}

#[test_only]
/// Destroy balance unconditionally for testing (even if non-empty)
/// ONLY use in tests - production code should use destroy_empty
public fun destroy_for_testing<AssetType, StableType>(
    balance: ConditionalMarketBalance<AssetType, StableType>,
) {
    let ConditionalMarketBalance { id, market_id: _, outcome_count: _, version: _, balances: _ } =
        balance;
    object::delete(id);
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Oracle Actions - Price-Based Unlocks
///
/// Clean price-based grant system with:
/// - N tiers with N recipients each
/// - Time bounds (earliest + latest execution)
/// - Price conditions per tier
/// - Launchpad enforcement (global minimum)
/// - Cancelable or immutable grants
/// - Emergency freeze control
///
module futarchy_oracle::oracle_actions;

use std::string::String;
use sui::object;
use sui::tx_context;
use sui::clock::Clock;
use sui::event;
use sui::bcs;
use sui::coin;
use sui::table::{Self, Table};
use account_protocol::{
    bcs_validation,
    executable::{Self, Executable},
    account::Account,
    intents,
    version_witness::VersionWitness,
    action_validation,
    package_registry::PackageRegistry,
};
use account_actions::currency;
use futarchy_core::resource_requests;
use futarchy_markets_core::unified_spot_pool::{Self, UnifiedSpotPool};
use futarchy_markets_primitives::conditional_amm::LiquidityPool;

// === Action Type Markers ===

public struct CreateOracleGrant has drop {}
public struct CancelGrant has drop {}

// === Marker Functions ===

public fun create_oracle_grant_marker(): CreateOracleGrant { CreateOracleGrant {} }
public fun cancel_grant_marker(): CancelGrant { CancelGrant {} }

// === Constants ===

const PRICE_MULTIPLIER_SCALE: u64 = 1_000_000_000; // 1e9
const MAX_TIME_OFFSET_MS: u64 = 315_360_000_000; // 10 years

// DAO states
const DAO_STATE_TERMINATED: u8 = 1;

// === Errors ===

const EInvalidAmount: u64 = 0;
const EPriceConditionNotMet: u64 = 2;
const EPriceBelowLaunchpad: u64 = 3;
const ETierAlreadyExecuted: u64 = 4;
const ENotRecipient: u64 = 5;
const EAlreadyCanceled: u64 = 6;
const EInsufficientVested: u64 = 8;
const ETimeCalculationOverflow: u64 = 9;
const EDaoDissolving: u64 = 10;
const EGrantNotCancelable: u64 = 11;
const EExecutionTooEarly: u64 = 14;
const EGrantExpired: u64 = 15;
const EWrongAccount: u64 = 16;
const EEmptyTiers: u64 = 18;

// === Core Structs ===

/// Launchpad price enforcement (applies globally to all tiers in RELATIVE mode only)
public struct LaunchpadEnforcement has store, copy, drop {
    enabled: bool,
    minimum_multiplier: u64,  // Scaled 1e9
    launchpad_price: u128,    // Absolute price at grant creation (1e12 scale)
}

/// Price condition for a tier
public struct PriceCondition has store, copy, drop {
    threshold: u128,  // Absolute price (scaled 1e12)
    is_above: bool,   // true = unlock above, false = unlock below
}

/// Recipient allocation
public struct RecipientMint has store, copy, drop {
    recipient: address,
    amount: u64,
}

/// Price tier - one unlock condition with N recipients
public struct PriceTier has store, copy, drop {
    price_condition: Option<PriceCondition>,
    recipients: vector<RecipientMint>,
    executed: bool,
    description: String,
}

/// Claim capability - transferable
public struct GrantClaimCap has key, store {
    id: UID,
    grant_id: ID,
}

/// Price-based mint grant - simplified
public struct PriceBasedMintGrant<phantom AssetType, phantom StableType> has key {
    id: UID,

    // === TIER STRUCTURE ===
    tiers: vector<PriceTier>,
    total_amount: u64,
    use_relative_pricing: bool,  // true = thresholds are multipliers, false = absolute prices

    // === PER-RECIPIENT TRACKING ===
    recipient_claims: Table<address, u64>,

    // === LAUNCHPAD ENFORCEMENT (global) ===
    launchpad_enforcement: LaunchpadEnforcement,

    // === TIME BOUNDS ===
    earliest_execution: Option<u64>,
    latest_execution: Option<u64>,

    // === STATE ===
    cancelable: bool,
    canceled: bool,

    // === METADATA ===
    description: String,
    created_at: u64,
    dao_id: ID,
}

// === Storage Keys ===

public struct GrantStorageKey has copy, drop, store {}

public struct GrantStorage has store {
    grants: sui::table::Table<ID, GrantInfo>,
    grant_ids: vector<ID>,
    total_grants: u64,
}

public struct GrantInfo has store, copy, drop {
    recipient: address,
    cancelable: bool,
}

// === Events ===

public struct GrantCreated has copy, drop {
    grant_id: ID,
    total_amount: u64,
    tier_count: u64,
    timestamp: u64,
}

public struct TokensClaimed has copy, drop {
    grant_id: ID,
    tier_index: u64,
    recipient: address,
    amount_claimed: u64,
    timestamp: u64,
}

public struct GrantCanceled has copy, drop {
    grant_id: ID,
    timestamp: u64,
}

// === Helper Functions ===

/// Convert relative threshold to absolute price
public fun relative_to_absolute_threshold(
    launchpad_price_abs_1e12: u128,
    multiplier_1e9: u64
): u128 {
    (launchpad_price_abs_1e12 * (multiplier_1e9 as u128)) / (PRICE_MULTIPLIER_SCALE as u128)
}

/// Create absolute price condition
public fun absolute_price_condition(
    price: u128,
    is_above: bool,
): PriceCondition {
    PriceCondition {
        threshold: price,
        is_above,
    }
}

/// Create recipient mint
public fun new_recipient_mint(recipient: address, amount: u64): RecipientMint {
    RecipientMint { recipient, amount }
}

// === Constructor Functions ===

/// Create price-based grant with N tiers and N recipients per tier
///
/// @param tiers: Vector of price tiers, each with price condition + recipients
/// @param use_relative_pricing: true = thresholds are multipliers of launchpad, false = absolute prices
/// @param launchpad_multiplier: Minimum price multiplier (0 = disabled, scaled 1e9)
///                              ONLY enforced when use_relative_pricing = true
/// @param earliest_execution_offset_ms: Minimum time before claiming (0 = immediate)
/// @param expiry_years: Maximum time to claim (0 = no expiry)
public fun create_grant<AssetType, StableType>(
    account: &mut Account,
    registry: &PackageRegistry,
    tiers: vector<PriceTier>,
    use_relative_pricing: bool,
    launchpad_multiplier: u64,
    earliest_execution_offset_ms: u64,
    expiry_years: u64,
    cancelable: bool,
    description: String,
    dao_id: ID,
    version: VersionWitness,
    clock: &Clock,
    ctx: &mut TxContext,
): ID {
    // Validation
    assert!(vector::length(&tiers) > 0, EEmptyTiers);

    let now = clock.timestamp_ms();

    // Calculate total amount across all tiers
    let mut total_amount = 0u64;
    let mut i = 0;
    let tier_count = vector::length(&tiers);
    while (i < tier_count) {
        let tier = vector::borrow(&tiers, i);
        let mut j = 0;
        let recipient_count = vector::length(&tier.recipients);
        while (j < recipient_count) {
            total_amount = total_amount + vector::borrow(&tier.recipients, j).amount;
            j = j + 1;
        };
        i = i + 1;
    };

    assert!(total_amount > 0, EInvalidAmount);

    // Read launchpad price from DAO config
    let dao_config = account_protocol::account::config(account);
    let launchpad_price_opt = futarchy_core::futarchy_config::get_launchpad_initial_price(dao_config);
    let launchpad_price = if (launchpad_price_opt.is_some()) {
        *launchpad_price_opt.borrow()
    } else {
        0u128
    };

    // Calculate time bounds
    let earliest_execution_opt = if (earliest_execution_offset_ms > 0) {
        assert!(earliest_execution_offset_ms <= MAX_TIME_OFFSET_MS, ETimeCalculationOverflow);
        std::option::some(now + earliest_execution_offset_ms)
    } else {
        std::option::none()
    };

    let latest_execution_opt = if (expiry_years > 0) {
        let expiry_ms = expiry_years * 365 * 24 * 60 * 60 * 1000;
        assert!(expiry_ms <= MAX_TIME_OFFSET_MS, ETimeCalculationOverflow);
        std::option::some(now + expiry_ms)
    } else {
        std::option::none()
    };

    let grant_id = object::new(ctx);
    let grant_id_inner = object::uid_to_inner(&grant_id);

    event::emit(GrantCreated {
        grant_id: grant_id_inner,
        total_amount,
        tier_count,
        timestamp: now,
    });

    let grant = PriceBasedMintGrant<AssetType, StableType> {
        id: grant_id,
        tiers,
        total_amount,
        use_relative_pricing,
        recipient_claims: table::new(ctx),
        launchpad_enforcement: LaunchpadEnforcement {
            enabled: launchpad_multiplier > 0,
            minimum_multiplier: launchpad_multiplier,
            launchpad_price,
        },
        earliest_execution: earliest_execution_opt,
        latest_execution: latest_execution_opt,
        cancelable,
        canceled: false,
        description,
        created_at: now,
        dao_id,
    };

    // Share the grant
    transfer::share_object(grant);

    // Ensure grant storage exists and register grant
    ensure_grant_storage(account, registry, version, ctx);
    register_grant(account, registry, grant_id_inner, cancelable, version);

    grant_id_inner
}

// === View Functions ===

public fun total_amount<A, S>(grant: &PriceBasedMintGrant<A, S>): u64 {
    grant.total_amount
}

public fun is_canceled<A, S>(grant: &PriceBasedMintGrant<A, S>): bool {
    grant.canceled
}

public fun description<A, S>(grant: &PriceBasedMintGrant<A, S>): &String {
    &grant.description
}

public fun tier_count<A, S>(grant: &PriceBasedMintGrant<A, S>): u64 {
    vector::length(&grant.tiers) as u64
}

// === Emergency Controls ===

/// Cancel a grant
public fun cancel_grant<A, S>(
    grant: &mut PriceBasedMintGrant<A, S>,
    clock: &Clock
) {
    assert!(grant.cancelable, EGrantNotCancelable);
    assert!(!grant.canceled, EAlreadyCanceled);
    grant.canceled = true;

    event::emit(GrantCanceled {
        grant_id: object::id(grant),
        timestamp: clock.timestamp_ms()
    });
}

// === Resource Request Pattern ===

/// Claim action data
public struct ClaimGrantAction has store, drop {
    grant_id: ID,
    tier_index: u64,
    recipient: address,
    claimable_amount: u64,
    dao_address: address,
}

// === Claim Helper Functions ===

/// Validate claim eligibility (DAO state, grant state, timing, cap ownership)
fun validate_claim_eligibility<AssetType, StableType>(
    account: &Account,
    registry: &PackageRegistry,
    version: VersionWitness,
    grant: &PriceBasedMintGrant<AssetType, StableType>,
    claim_cap: &GrantClaimCap,
    clock: &Clock,
) {
    // Check DAO is not dissolving
    assert_not_dissolving(account, registry, version);

    // Verify claim cap matches grant
    assert!(claim_cap.grant_id == object::id(grant), EWrongAccount);

    // Check grant is not canceled/frozen
    assert!(!grant.canceled, EAlreadyCanceled);
    let now = clock.timestamp_ms();

    // Check time bounds
    if (grant.earliest_execution.is_some()) {
        let earliest = grant.earliest_execution.borrow();
        assert!(now >= *earliest, EExecutionTooEarly);
    };

    if (grant.latest_execution.is_some()) {
        let latest = grant.latest_execution.borrow();
        assert!(now <= *latest, EGrantExpired);
    };
}

/// Validate price conditions (tier-specific + launchpad global minimum)
fun validate_price_conditions<AssetType, StableType>(
    grant: &PriceBasedMintGrant<AssetType, StableType>,
    tier: &PriceTier,
    spot_pool: &UnifiedSpotPool<AssetType, StableType>,
    conditional_pools: &vector<LiquidityPool>,
    clock: &Clock,
) {
    validate_price_conditions_with_enforcement(
        grant.launchpad_enforcement,
        grant.use_relative_pricing,
        tier,
        spot_pool,
        conditional_pools,
        clock
    );
}

/// Validate price conditions with pre-extracted launchpad enforcement
/// This avoids borrow conflicts when tier is already mutably borrowed
fun validate_price_conditions_with_enforcement<AssetType, StableType>(
    launchpad_enforcement: LaunchpadEnforcement,
    use_relative_pricing: bool,
    tier: &PriceTier,
    spot_pool: &UnifiedSpotPool<AssetType, StableType>,
    _conditional_pools: &vector<LiquidityPool>,
    clock: &Clock,
) {
    // Read oracle price directly from spot (auto-arb keeps prices synced)
    let current_price = unified_spot_pool::get_geometric_twap(
        spot_pool,
        clock
    );

    // Check tier price condition
    if (tier.price_condition.is_some()) {
        let condition = tier.price_condition.borrow();

        // Calculate actual threshold based on pricing mode
        let actual_threshold = if (use_relative_pricing) {
            // Relative mode: threshold is a multiplier of launchpad price
            (launchpad_enforcement.launchpad_price * condition.threshold) / (PRICE_MULTIPLIER_SCALE as u128)
        } else {
            // Absolute mode: threshold is already an absolute price
            condition.threshold
        };

        let threshold_condition = PriceCondition {
            threshold: actual_threshold,
            is_above: condition.is_above,
        };

        assert!(
            check_price_condition(&threshold_condition, current_price),
            EPriceConditionNotMet
        );
    };

    // Check launchpad enforcement (global minimum) - ONLY for relative pricing mode
    if (use_relative_pricing && launchpad_enforcement.enabled) {
        let min_price = (launchpad_enforcement.launchpad_price *
                         (launchpad_enforcement.minimum_multiplier as u128)) /
                         (PRICE_MULTIPLIER_SCALE as u128);
        assert!(current_price >= min_price, EPriceBelowLaunchpad);
    };
}

/// Find recipient's allocation in the tier
/// Returns claimable amount for the recipient
fun find_recipient_allocation(tier: &PriceTier, recipient: address): u64 {
    let mut claimable_amount = 0u64;
    let mut found = false;
    let mut i = 0;
    let recipient_count = vector::length(&tier.recipients);

    while (i < recipient_count) {
        let recipient_mint = vector::borrow(&tier.recipients, i);
        if (recipient_mint.recipient == recipient) {
            claimable_amount = recipient_mint.amount;
            found = true;
            break
        };
        i = i + 1;
    };

    assert!(found, ENotRecipient);
    assert!(claimable_amount > 0, EInsufficientVested);

    claimable_amount
}

/// Update claim tracking for recipient and mark tier as executed
fun update_claim_tracking<AssetType, StableType>(
    grant: &mut PriceBasedMintGrant<AssetType, StableType>,
    tier: &mut PriceTier,
    recipient: address,
    claimable_amount: u64,
) {
    // Check if already claimed
    let already_claimed = if (table::contains(&grant.recipient_claims, recipient)) {
        *table::borrow(&grant.recipient_claims, recipient)
    } else {
        0u64
    };

    // Update recipient tracking
    let new_claimed = already_claimed + claimable_amount;
    assert!(new_claimed >= already_claimed, ETimeCalculationOverflow);

    if (table::contains(&mut grant.recipient_claims, recipient)) {
        *table::borrow_mut(&mut grant.recipient_claims, recipient) = new_claimed;
    } else {
        table::add(&mut grant.recipient_claims, recipient, new_claimed);
    };

    // Mark tier as executed
    // Note: Currently marks tier executed when anyone claims
    // Future enhancement: track per-recipient execution separately
    tier.executed = true;
}

// === Claim Functions ===

/// Claim tokens from a specific tier (STEP 1: Validation)
///
/// Refactored into helper functions for:
/// - Eligibility validation (DAO state, grant state, timing, cap)
/// - Price condition checks (tier + launchpad)
/// - Recipient lookup and allocation
/// - Claim tracking and tier execution
///
/// Returns ResourceRequest that must be fulfilled in same PTB
public fun claim_grant<AssetType, StableType>(
    account: &Account,
    registry: &PackageRegistry,
    version: VersionWitness,
    grant: &mut PriceBasedMintGrant<AssetType, StableType>,
    tier_index: u64,
    claim_cap: &GrantClaimCap,
    spot_pool: &UnifiedSpotPool<AssetType, StableType>,
    conditional_pools: &vector<LiquidityPool>,
    clock: &Clock,
    ctx: &mut TxContext,
): resource_requests::ResourceRequest<ClaimGrantAction> {
    // Phase 1: Validate claim eligibility
    validate_claim_eligibility(account, registry, version, grant, claim_cap, clock);

    // Phase 2: Extract launchpad enforcement and pricing mode before mutable borrow
    let launchpad_enforcement = grant.launchpad_enforcement;
    let use_relative_pricing = grant.use_relative_pricing;

    // Phase 3-5: Work with tier (in its own scope to control borrowing)
    let (recipient, claimable_amount) = {
        assert!(tier_index < vector::length(&grant.tiers), EInvalidAmount);
        let tier = vector::borrow_mut(&mut grant.tiers, tier_index);
        assert!(!tier.executed, ETierAlreadyExecuted);

        // Validate price conditions
        validate_price_conditions_with_enforcement(launchpad_enforcement, use_relative_pricing, tier, spot_pool, conditional_pools, clock);

        // Find recipient allocation
        let recipient = tx_context::sender(ctx);
        let claimable_amount = find_recipient_allocation(tier, recipient);

        // Mark tier as executed before dropping the borrow
        tier.executed = true;

        (recipient, claimable_amount)
    }; // tier borrow ends here

    // Phase 6: Update recipient claim tracking (after dropping tier borrow)
    // We need to drop the tier borrow before accessing grant.recipient_claims
    let already_claimed = if (table::contains(&grant.recipient_claims, recipient)) {
        *table::borrow(&grant.recipient_claims, recipient)
    } else {
        0u64
    };

    let new_claimed = already_claimed + claimable_amount;
    assert!(new_claimed >= already_claimed, ETimeCalculationOverflow);

    if (table::contains(&mut grant.recipient_claims, recipient)) {
        *table::borrow_mut(&mut grant.recipient_claims, recipient) = new_claimed;
    } else {
        table::add(&mut grant.recipient_claims, recipient, new_claimed);
    };

    // Phase 7: Create resource request
    let dao_address = object::id_to_address(&grant.dao_id);
    let action = ClaimGrantAction {
        grant_id: object::id(grant),
        tier_index,
        recipient,
        claimable_amount,
        dao_address,
    };

    resource_requests::new_resource_request(action, ctx)
}

/// Fulfill claim by minting tokens from DAO's TreasuryCap (STEP 2)
#[allow(unused_type_parameter)]
public fun fulfill_claim_grant_from_account<AssetType, StableType, Config>(
    request: resource_requests::ResourceRequest<ClaimGrantAction>,
    account: &mut Account,
    registry: &PackageRegistry,
    clock: &Clock,
    ctx: &mut tx_context::TxContext,
) {
    let action = resource_requests::extract_action(request);

    // Verify correct DAO Account
    let account_addr = account.addr();
    assert!(account_addr == action.dao_address, EWrongAccount);

    // Borrow TreasuryCap from Account
    let treasury_cap = currency::borrow_treasury_cap_mut<AssetType>(account, registry);

    // Mint tokens
    let minted_coin = coin::mint<AssetType>(treasury_cap, action.claimable_amount, ctx);

    // Transfer to recipient
    transfer::public_transfer(minted_coin, action.recipient);

    // Emit event
    event::emit(TokensClaimed {
        grant_id: action.grant_id,
        tier_index: action.tier_index,
        recipient: action.recipient,
        amount_claimed: action.claimable_amount,
        timestamp: clock.timestamp_ms(),
    });
}

/// Check if price condition is met
fun check_price_condition(condition: &PriceCondition, current_price: u128): bool {
    if (condition.is_above) {
        current_price >= condition.threshold
    } else {
        current_price <= condition.threshold
    }
}

// === Grant Registry Management ===

fun ensure_grant_storage(account: &mut Account, registry: &PackageRegistry, version_witness: VersionWitness, ctx: &mut TxContext) {
    use account_protocol::account;

    if (!account::has_managed_data(account, GrantStorageKey {})) {
        account::add_managed_data(
            account,
            registry,
            GrantStorageKey {},
            GrantStorage {
                grants: sui::table::new(ctx),
                grant_ids: vector::empty(),
                total_grants: 0,
            },
            version_witness
        );
    }
}

fun register_grant(
    account: &mut Account,
    registry: &PackageRegistry,
    grant_id: ID,
    cancelable: bool,
    version_witness: VersionWitness,
) {
    use account_protocol::account;

    let storage: &mut GrantStorage = account::borrow_managed_data_mut(
        account,
        registry,
        GrantStorageKey {},
        version_witness
    );

    let info = GrantInfo {
        recipient: @0x0,  // Multi-recipient, no single owner
        cancelable,
    };

    sui::table::add(&mut storage.grants, grant_id, info);
    storage.grant_ids.push_back(grant_id);
    storage.total_grants = storage.total_grants + 1;
}

fun assert_not_dissolving(account: &Account, registry: &PackageRegistry, version_witness: VersionWitness) {
    use account_protocol::account;
    use futarchy_core::futarchy_config;

    let dao_state: &futarchy_config::DaoState = account::borrow_managed_data(
        account,
        registry,
        futarchy_config::new_dao_state_key(),
        version_witness
    );

    assert!(
        futarchy_config::operational_state(dao_state) != DAO_STATE_TERMINATED,
        EDaoDissolving
    );
}

public fun get_all_grant_ids(account: &Account, registry: &PackageRegistry, version_witness: VersionWitness): vector<ID> {
    use account_protocol::account;

    if (!account::has_managed_data(account, GrantStorageKey {})) {
        return vector::empty()
    };

    let storage: &GrantStorage = account::borrow_managed_data(
        account,
        registry,
        GrantStorageKey {},
        version_witness
    );

    storage.grant_ids
}

// === Action Structs for Proposal System ===

public struct CreateOracleGrantAction<phantom AssetType, phantom StableType> has store, drop, copy {
    tier_specs: vector<TierSpec>,
    use_relative_pricing: bool,
    launchpad_multiplier: u64,
    earliest_execution_offset_ms: u64,
    expiry_years: u64,
    cancelable: bool,
    description: String,
}

public struct TierSpec has store, drop, copy {
    price_threshold: u128,
    is_above: bool,
    recipients: vector<RecipientMint>,
    tier_description: String,
}

public struct CancelGrantAction has store, drop, copy {
    grant_id: ID,
}

// === Action Constructors ===

public fun new_create_oracle_grant<AssetType, StableType>(
    tier_specs: vector<TierSpec>,
    use_relative_pricing: bool,
    launchpad_multiplier: u64,
    earliest_execution_offset_ms: u64,
    expiry_years: u64,
    cancelable: bool,
    description: String,
): CreateOracleGrantAction<AssetType, StableType> {
    CreateOracleGrantAction {
        tier_specs,
        use_relative_pricing,
        launchpad_multiplier,
        earliest_execution_offset_ms,
        expiry_years,
        cancelable,
        description,
    }
}

public fun new_tier_spec(
    price_threshold: u128,
    is_above: bool,
    recipients: vector<RecipientMint>,
    tier_description: String,
): TierSpec {
    TierSpec {
        price_threshold,
        is_above,
        recipients,
        tier_description,
    }
}

public fun new_cancel_grant(grant_id: ID): CancelGrantAction {
    CancelGrantAction { grant_id }
}

// === Helper Functions for BCS Deserialization ===

/// Deserialize tier specifications from BCS reader
fun deserialize_tier_specs(reader: &mut bcs::BCS): vector<TierSpec> {
    let tier_spec_count = bcs::peel_vec_length(reader);
    let mut tier_specs = vector::empty<TierSpec>();
    let mut i = 0;

    while (i < tier_spec_count) {
        let price_threshold = bcs::peel_u128(reader);
        let is_above = bcs::peel_bool(reader);

        // Deserialize recipients for this tier
        let recipients = deserialize_recipients(reader);

        let tier_description_bytes = bcs::peel_vec_u8(reader);
        let tier_description = std::string::utf8(tier_description_bytes);

        vector::push_back(&mut tier_specs, TierSpec {
            price_threshold,
            is_above,
            recipients,
            tier_description,
        });
        i = i + 1;
    };

    tier_specs
}

/// Deserialize recipient mints from BCS reader
fun deserialize_recipients(reader: &mut bcs::BCS): vector<RecipientMint> {
    let recipient_count = bcs::peel_vec_length(reader);
    let mut recipients = vector::empty<RecipientMint>();
    let mut j = 0;

    while (j < recipient_count) {
        let recipient = bcs::peel_address(reader);
        let amount = bcs::peel_u64(reader);
        vector::push_back(&mut recipients, RecipientMint { recipient, amount });
        j = j + 1;
    };

    recipients
}

/// Convert TierSpecs to PriceTiers for grant creation
fun convert_tier_specs_to_price_tiers(tier_specs: &vector<TierSpec>): vector<PriceTier> {
    let mut tiers = vector::empty<PriceTier>();
    let mut k = 0;

    while (k < vector::length(tier_specs)) {
        let spec = vector::borrow(tier_specs, k);
        let tier = PriceTier {
            price_condition: std::option::some(PriceCondition {
                threshold: spec.price_threshold,
                is_above: spec.is_above,
            }),
            recipients: spec.recipients,
            executed: false,
            description: spec.tier_description,
        };
        vector::push_back(&mut tiers, tier);
        k = k + 1;
    };

    tiers
}

/// Create and distribute claim caps to all recipients across all tiers
fun distribute_claim_caps(tier_specs: &vector<TierSpec>, grant_id: ID, ctx: &mut TxContext) {
    let mut m = 0;

    while (m < vector::length(tier_specs)) {
        let spec = vector::borrow(tier_specs, m);
        let mut n = 0;

        while (n < vector::length(&spec.recipients)) {
            let recipient_mint = vector::borrow(&spec.recipients, n);
            let claim_cap = GrantClaimCap {
                id: object::new(ctx),
                grant_id,
            };
            transfer::transfer(claim_cap, recipient_mint.recipient);
            n = n + 1;
        };
        m = m + 1;
    };
}

// === Execution Functions ===

/// Execute create oracle grant action from proposal
/// Refactored into smaller helper functions for clarity
public fun do_create_oracle_grant<AssetType, StableType, Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version: VersionWitness,
    _witness: IW,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Validate DAO state and ensure storage exists
    assert_not_dissolving(account, registry, version);
    ensure_grant_storage(account, registry, version, ctx);

    // Extract and validate action spec
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));
    action_validation::assert_action_type<CreateOracleGrant>(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, 0); // EUnsupportedActionVersion

    // Deserialize action data from BCS
    let action_data = intents::action_spec_data(spec);
    let mut reader = bcs::new(*action_data);

    let tier_specs = deserialize_tier_specs(&mut reader);
    let use_relative_pricing = bcs::peel_bool(&mut reader);
    let launchpad_multiplier = bcs::peel_u64(&mut reader);
    let earliest_execution_offset_ms = bcs::peel_u64(&mut reader);
    let expiry_years = bcs::peel_u64(&mut reader);
    let cancelable = bcs::peel_bool(&mut reader);
    let description_bytes = bcs::peel_vec_u8(&mut reader);

    bcs_validation::validate_all_bytes_consumed(reader);

    // Convert deserialized data to runtime structures
    let description = std::string::utf8(description_bytes);
    let dao_id = object::id(account);
    let tiers = convert_tier_specs_to_price_tiers(&tier_specs);

    // Create the grant
    let grant_id = create_grant<AssetType, StableType>(
        account,
        registry,
        tiers,
        use_relative_pricing,
        launchpad_multiplier,
        earliest_execution_offset_ms,
        expiry_years,
        cancelable,
        description,
        dao_id,
        version,
        clock,
        ctx,
    );

    // Distribute claim caps to all recipients
    distribute_claim_caps(&tier_specs, grant_id, ctx);

    executable::increment_action_idx(executable);
}

public fun do_cancel_grant<AssetType, StableType, Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    _account: &mut Account,
    _version: VersionWitness,
    _witness: IW,
    grant: &mut PriceBasedMintGrant<AssetType, StableType>,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));
    action_validation::assert_action_type<CancelGrant>(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, 0); // EUnsupportedActionVersion

    // Validate action_data is empty (no fields)
    let action_data = intents::action_spec_data(spec);
    let reader = bcs::new(*action_data);
    bcs_validation::validate_all_bytes_consumed(reader);

    cancel_grant(grant, clock);
    executable::increment_action_idx(executable);
}

// === Garbage Collection ===

/// Delete create oracle grant action from expired intent
public fun delete_create_oracle_grant<AssetType, StableType>(expired: &mut intents::Expired) {
    let action_spec = intents::remove_action_spec(expired);
    let action_data = intents::action_spec_action_data(action_spec);
    let mut reader = bcs::new(action_data);

    // Deserialize tier specs
    let tier_spec_count = bcs::peel_vec_length(&mut reader);
    let mut i = 0;
    while (i < tier_spec_count) {
        reader.peel_u128(); // price_threshold
        reader.peel_bool(); // is_above

        // Deserialize recipients for this tier
        let recipient_count = bcs::peel_vec_length(&mut reader);
        let mut j = 0;
        while (j < recipient_count) {
            reader.peel_address(); // recipient
            reader.peel_u64(); // amount
            j = j + 1;
        };

        reader.peel_vec_u8(); // tier_description
        i = i + 1;
    };

    reader.peel_bool(); // use_relative_pricing
    reader.peel_u64(); // launchpad_multiplier
    reader.peel_u64(); // earliest_execution_offset_ms
    reader.peel_u64(); // expiry_years
    reader.peel_bool(); // cancelable
    reader.peel_vec_u8(); // description
    let _ = reader.into_remainder_bytes();
}

/// Delete cancel grant action from expired intent
public fun delete_cancel_grant(expired: &mut intents::Expired) {
    let action_spec = intents::remove_action_spec(expired);
    let action_data = intents::action_spec_action_data(action_spec);
    let mut reader = bcs::new(action_data);
    reader.peel_address(); // grant_id as ID
    let _ = reader.into_remainder_bytes();
}

// === Test-Only Functions ===

#[test_only]
/// Convert TierSpecs to PriceTiers for testing
public fun convert_tier_specs_for_testing(tier_specs: vector<TierSpec>): vector<PriceTier> {
    convert_tier_specs_to_price_tiers(&tier_specs)
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Factory for creating futarchy DAOs using account_protocol
/// This is the main entry point for creating DAOs in the Futarchy protocol
module futarchy_factory::factory;

use account_actions::{currency, vault};
use account_protocol::package_registry::{Self as package_registry, PackageRegistry};
use account_protocol::account::{Self, Account};
use futarchy_core::dao_config::{
    Self,
    DaoConfig,
    TradingParams,
    TwapConfig,
    GovernanceConfig,
    MetadataConfig
};
use futarchy_core::futarchy_config::{Self, FutarchyConfig};
use futarchy_core::version;
use futarchy_markets_core::fee::{Self, FeeManager};
use futarchy_markets_core::unified_spot_pool::{Self, UnifiedSpotPool};
use futarchy_one_shot_utils::constants;
use futarchy_one_shot_utils::coin_registry;
use account_actions::init_action_specs::InitActionSpecs;
use futarchy_types::signed::{Self as signed, SignedU128};
use std::ascii::String as AsciiString;
use std::option::Option;
use std::string::{String, String as UTF8String};
use std::type_name::{Self, TypeName};
use std::vector;
use sui::clock::Clock;
use sui::coin::{Self, Coin, TreasuryCap, CoinMetadata};
use sui::event;
use sui::object::{Self, ID, UID};
use sui::sui::SUI;
use sui::transfer;
use sui::tx_context::TxContext;
use sui::url;
use sui::vec_set::{Self, VecSet};

// === Storage Keys ===

/// Key for storing CoinMetadata in Account
public struct CoinMetadataKey<phantom CoinType> has copy, drop, store {}

// === Errors ===
const EPaused: u64 = 1;
const EStableTypeNotAllowed: u64 = 2;
const EBadWitness: u64 = 3;
const EHighTwapThreshold: u64 = 4;
const ELowTwapWindowCap: u64 = 5;
const ELongTradingTime: u64 = 6;
const ELongReviewTime: u64 = 7;
const ELongTwapDelayTime: u64 = 8;
const ETwapInitialTooLarge: u64 = 9;
const EDelayNearTotalTrading: u64 = 10;
const EInvalidStateForAction: u64 = 11;
const EPermanentlyDisabled: u64 = 12;
const EAlreadyDisabled: u64 = 13;

// === Constants ===
const TWAP_MINIMUM_WINDOW_CAP: u64 = 1;
const MAX_TRADING_TIME: u64 = 604_800_000; // 7 days in ms
const MAX_REVIEW_TIME: u64 = 604_800_000; // 7 days in ms
const MAX_TWAP_START_DELAY: u64 = 86_400_000; // 1 day in ms
const MAX_TWAP_THRESHOLD: u64 = 1_000_000; // 10x increase required to pass

// === Structs ===

/// One-time witness for factory initialization
public struct FACTORY has drop {}

/// Factory for creating futarchy DAOs
public struct Factory has key, store {
    id: UID,
    dao_count: u64,
    paused: bool,
    permanently_disabled: bool,
    owner_cap_id: ID,
    allowed_stable_types: VecSet<TypeName>,
    // Launchpad fee configuration (in MIST - 1 SUI = 1_000_000_000 MIST)
    launchpad_bid_fee: u64,              // Fee users pay per contribution (default: 0.1 SUI)
    launchpad_cranker_reward: u64,       // Reward crankers get per claim (default: 0.05 SUI)
    launchpad_settlement_reward: u64,    // Reward per cap processed in settlement (default: 0.05 SUI)
}

/// Admin capability for factory operations
public struct FactoryOwnerCap has key, store {
    id: UID,
}

/// Validator capability for DAO verification
public struct ValidatorAdminCap has key, store {
    id: UID,
}

// === Events ===

public struct DAOCreated has copy, drop {
    account_id: address,
    dao_name: AsciiString,
    asset_type: UTF8String,
    stable_type: UTF8String,
    creator: address,
    affiliate_id: UTF8String,
    timestamp: u64,
}

public struct StableCoinTypeAdded has copy, drop {
    type_str: UTF8String,
    admin: address,
    timestamp: u64,
}

public struct StableCoinTypeRemoved has copy, drop {
    type_str: UTF8String,
    admin: address,
    timestamp: u64,
}

public struct FactoryPermanentlyDisabled has copy, drop {
    admin: address,
    dao_count_at_shutdown: u64,
    timestamp: u64,
}

public struct LaunchpadFeesUpdated has copy, drop {
    admin: address,
    old_bid_fee: u64,
    new_bid_fee: u64,
    old_cranker_reward: u64,
    new_cranker_reward: u64,
    old_settlement_reward: u64,
    new_settlement_reward: u64,
    timestamp: u64,
}

public struct VerificationApproved has copy, drop {
    dao_id: ID,
    verification_id: ID,
    level: u8,
    attestation_url: String,
    admin_review_text: String,
    validator: address,
    timestamp: u64,
}

public struct VerificationRejected has copy, drop {
    dao_id: ID,
    verification_id: ID,
    reason: String,
    validator: address,
    timestamp: u64,
}

public struct DaoScoreSet has copy, drop {
    dao_id: ID,
    score: u64,
    reason: String,
    validator: address,
    timestamp: u64,
}

// === Internal Helper Functions ===
// Note: Action registry removed - using statically-typed pattern like move-framework

// Test helpers removed - no longer needed without action registry

// === Public Functions ===

fun init(witness: FACTORY, ctx: &mut TxContext) {
    assert!(sui::types::is_one_time_witness(&witness), EBadWitness);

    let owner_cap = FactoryOwnerCap {
        id: object::new(ctx),
    };

    let factory = Factory {
        id: object::new(ctx),
        dao_count: 0,
        paused: false,
        permanently_disabled: false,
        owner_cap_id: object::id(&owner_cap),
        allowed_stable_types: vec_set::empty(),
        // Initialize with default launchpad fees
        launchpad_bid_fee: constants::launchpad_bid_fee_per_contribution(),
        launchpad_cranker_reward: constants::launchpad_cranker_reward_per_claim(),
        launchpad_settlement_reward: constants::launchpad_reward_per_cap_processed(),
    };

    let validator_cap = ValidatorAdminCap {
        id: object::new(ctx),
    };

    transfer::share_object(factory);
    transfer::public_transfer(owner_cap, ctx.sender());
    transfer::public_transfer(validator_cap, ctx.sender());
}

/// Create a new futarchy DAO with Extensions
public fun create_dao<AssetType: drop, StableType: drop>(
    factory: &mut Factory,
    registry: &PackageRegistry,
    fee_manager: &mut FeeManager,
    payment: Coin<SUI>,
    affiliate_id: UTF8String, // Partner identifier (UUID from subclient, empty string if none)
    min_asset_amount: u64,
    min_stable_amount: u64,
    dao_name: AsciiString,
    icon_url_string: AsciiString,
    review_period_ms: u64,
    trading_period_ms: u64,
    twap_start_delay: u64,
    twap_step_max: u64,
    twap_initial_observation: u128,
    twap_threshold: SignedU128,
    amm_total_fee_bps: u64,
    description: UTF8String,
    max_outcomes: u64,
    _agreement_lines: vector<UTF8String>,
    _agreement_difficulties: vector<u64>,
    treasury_cap: TreasuryCap<AssetType>,
    coin_metadata: CoinMetadata<AssetType>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Validate caps at entry point
    coin_registry::validate_coin_set(&treasury_cap, &coin_metadata);

    create_dao_internal_with_extensions<AssetType, StableType>(
        factory,
        registry,
        fee_manager,
        payment,
        affiliate_id,
        min_asset_amount,
        min_stable_amount,
        dao_name,
        icon_url_string,
        review_period_ms,
        trading_period_ms,
        twap_start_delay,
        twap_step_max,
        twap_initial_observation,
        twap_threshold,
        amm_total_fee_bps,
        description,
        max_outcomes,
        _agreement_lines,
        _agreement_difficulties,
        treasury_cap,
        coin_metadata,
        vector::empty<InitActionSpecs>(),
        clock,
        ctx,
    );
}

/// Create a DAO and atomically execute a batch of init intents before sharing.
public fun create_dao_with_init_specs<AssetType: drop, StableType: drop>(
    factory: &mut Factory,
    registry: &PackageRegistry,
    fee_manager: &mut FeeManager,
    payment: Coin<SUI>,
    affiliate_id: UTF8String,
    min_asset_amount: u64,
    min_stable_amount: u64,
    dao_name: AsciiString,
    icon_url_string: AsciiString,
    review_period_ms: u64,
    trading_period_ms: u64,
    twap_start_delay: u64,
    twap_step_max: u64,
    twap_initial_observation: u128,
    twap_threshold: SignedU128,
    amm_total_fee_bps: u64,
    description: UTF8String,
    max_outcomes: u64,
    _agreement_lines: vector<UTF8String>,
    _agreement_difficulties: vector<u64>,
    treasury_cap: TreasuryCap<AssetType>,
    coin_metadata: CoinMetadata<AssetType>,
    init_specs: vector<InitActionSpecs>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Validate caps at entry point
    coin_registry::validate_coin_set(&treasury_cap, &coin_metadata);

    create_dao_internal_with_extensions<AssetType, StableType>(
        factory,
        registry,
        fee_manager,
        payment,
        affiliate_id,
        min_asset_amount,
        min_stable_amount,
        dao_name,
        icon_url_string,
        review_period_ms,
        trading_period_ms,
        twap_start_delay,
        twap_step_max,
        twap_initial_observation,
        twap_threshold,
        amm_total_fee_bps,
        description,
        max_outcomes,
        _agreement_lines,
        _agreement_difficulties,
        treasury_cap,
        coin_metadata,
        init_specs,
        clock,
        ctx,
    );
}

/// Internal function to create a DAO with Extensions and optional TreasuryCap
#[allow(lint(share_owned))]
public(package) fun create_dao_internal_with_extensions<AssetType: drop, StableType: drop>(
    factory: &mut Factory,
    registry: &PackageRegistry,
    fee_manager: &mut FeeManager,
    payment: Coin<SUI>,
    affiliate_id: UTF8String,
    min_asset_amount: u64,
    min_stable_amount: u64,
    dao_name: AsciiString,
    icon_url_string: AsciiString,
    review_period_ms: u64,
    trading_period_ms: u64,
    twap_start_delay: u64,
    twap_step_max: u64,
    twap_initial_observation: u128,
    twap_threshold: SignedU128,
    amm_total_fee_bps: u64,
    description: UTF8String,
    max_outcomes: u64,
    _agreement_lines: vector<UTF8String>,
    _agreement_difficulties: vector<u64>,
    treasury_cap: TreasuryCap<AssetType>,
    coin_metadata: CoinMetadata<AssetType>,
    init_specs: vector<InitActionSpecs>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Check factory is not permanently disabled
    assert!(!factory.permanently_disabled, EPermanentlyDisabled);

    // Check factory is active
    assert!(!factory.paused, EPaused);

    // Check if StableType is allowed
    let stable_type_name = type_name::with_defining_ids<StableType>();
    assert!(factory.allowed_stable_types.contains(&stable_type_name), EStableTypeNotAllowed);

    // Process payment
    fee::deposit_dao_creation_payment(fee_manager, payment, clock, ctx);

    // DoS protection: limit affiliate_id length (UUID is 36 chars, leave room for custom IDs)
    assert!(affiliate_id.length() <= 64, EInvalidStateForAction);

    // Validate parameters
    assert!(twap_step_max >= TWAP_MINIMUM_WINDOW_CAP, ELowTwapWindowCap);
    assert!(review_period_ms <= MAX_REVIEW_TIME, ELongReviewTime);
    assert!(trading_period_ms <= MAX_TRADING_TIME, ELongTradingTime);
    assert!(twap_start_delay <= MAX_TWAP_START_DELAY, ELongTwapDelayTime);
    assert!((twap_start_delay + 60_000) < trading_period_ms, EDelayNearTotalTrading);
    assert!(signed::magnitude(&twap_threshold) <= (MAX_TWAP_THRESHOLD as u128), EHighTwapThreshold);
    assert!(
        twap_initial_observation <= (18446744073709551615u128) * 1_000_000_000_000,
        ETwapInitialTooLarge,
    );

    // Create config parameters using the structured approach
    let trading_params = dao_config::new_trading_params(
        min_asset_amount,
        min_stable_amount,
        review_period_ms,
        trading_period_ms,
        amm_total_fee_bps, // conditional AMM fee
        amm_total_fee_bps, // spot AMM fee (same as conditional)
        0, // market_op_review_period_ms (0 = immediate, allows atomic market init)
        1000, // max_amm_swap_percent_bps (10% max swap per proposal)
        80, // conditional_liquidity_ratio_percent (80%, base 100 - enforced 1-99% range)
    );

    let twap_config = dao_config::new_twap_config(
        twap_start_delay,
        twap_step_max,
        twap_initial_observation,
        twap_threshold,
    );

    let governance_config = dao_config::new_governance_config(
        max_outcomes,
        20,
        500000, // proposal_creation_fee (0.5 of stable token, e.g., 0.5 USDC)
        1000000, // proposal_fee_per_outcome (1.0 of stable token per extra outcome)
        true,
        10,
        31_536_000_000,
        true,
        false, // show_proposal_details (default: false for security)
    );

    let metadata_config = dao_config::new_metadata_config(
        dao_name,
        url::new_unsafe(icon_url_string),
        description,
    );

    let dao_config = dao_config::new_dao_config(
        trading_params,
        twap_config,
        governance_config,
        metadata_config,
        dao_config::default_conditional_coin_config(),
        dao_config::default_quota_config(),
        dao_config::default_sponsorship_config(),
    );

    // --- Phase 1: Create all objects in memory (no sharing) ---

    // Create fee manager for this DAO
    let _dao_fee_manager_id = object::id(fee_manager); // Use factory fee manager for now

    // Extract conditional_liquidity_ratio_percent from trading_params
    let conditional_liquidity_ratio_percent = dao_config::conditional_liquidity_ratio_percent(&trading_params);

    // Create the unified spot pool with aggregator support enabled
    // This provides TWAP oracle, registry, and full aggregator features
    let spot_pool = unified_spot_pool::new_with_aggregator<AssetType, StableType>(
        amm_total_fee_bps, // Factory uses same fee for both conditional and spot
        option::none(), // No launch fee schedule by default (can be added via init specs)
        8000, // oracle_conditional_threshold_bps (80% threshold from trading params)
        conditional_liquidity_ratio_percent, // From DAO config!
        clock,
        ctx,
    );
    let spot_pool_id = object::id(&spot_pool);

    // Create the futarchy configuration
    let config = futarchy_config::new<AssetType, StableType>(
        dao_config,
    );

    // Create the account with PackageRegistry validation for security
    let mut account = futarchy_config::new_with_package_registry(registry, config, ctx);


    // Action registry removed - using statically-typed pattern

    // Initialize the default treasury vault using base vault module
    let auth = account::new_auth<FutarchyConfig, futarchy_config::ConfigWitness>(
        &account,
        registry,
        version::current(),
        futarchy_config::authenticate(&account, ctx),
    );
    vault::open<FutarchyConfig>(auth, &mut account, registry, std::string::utf8(b"treasury"), ctx);

    // Pre-approve common coin types for permissionless deposits
    // This enables anyone to send SUI, AssetType, or StableType to the DAO
    // (enables revenue/donations without governance proposals)
    let auth = account::new_auth<FutarchyConfig, futarchy_config::ConfigWitness>(
        &account,
        registry,
        version::current(),
        futarchy_config::authenticate(&account, ctx),
    );
    vault::approve_coin_type<FutarchyConfig, SUI>(auth, &mut account, registry, std::string::utf8(b"treasury"));

    let auth = account::new_auth<FutarchyConfig, futarchy_config::ConfigWitness>(
        &account,
        registry,
        version::current(),
        futarchy_config::authenticate(&account, ctx),
    );
    vault::approve_coin_type<FutarchyConfig, AssetType>(auth, &mut account, registry, std::string::utf8(b"treasury"));

    let auth = account::new_auth<FutarchyConfig, futarchy_config::ConfigWitness>(
        &account,
        registry,
        version::current(),
        futarchy_config::authenticate(&account, ctx),
    );
    vault::approve_coin_type<FutarchyConfig, StableType>(auth, &mut account, registry, std::string::utf8(b"treasury"));

    // Lock treasury cap and store coin metadata using Move framework's currency module
    // TreasuryCap is stored via currency::lock_cap for proper atomic borrowing
    // CoinMetadata is stored separately for metadata updates via intents
    let auth = account::new_auth<FutarchyConfig, futarchy_config::ConfigWitness>(
        &account,
        registry,
        version::current(),
        futarchy_config::authenticate(&account, ctx),
    );

    // Store TreasuryCap
    currency::lock_cap(
        auth,
        &mut account,
        registry,
        treasury_cap,
        option::none(), // No max supply limit for now
    );

    // Store CoinMetadata for DAO governance control over coin metadata
    account.add_managed_asset(
        registry,
        CoinMetadataKey<AssetType> {},
        coin_metadata,
        version::current(),
    );

    // Note: init_specs are NOT stored in Account
    // Frontend receives them from createDAOWithInitSpecs transaction
    // Frontend then constructs PTB to execute init_* functions before sharing

    // Get account ID before sharing
    let account_id = object::id_address(&account);

    // --- Phase 3: Final Atomic Sharing ---
    // All objects are shared at the end of the function. If any step above failed,
    // the transaction would abort and no objects would be created.
    transfer::public_share_object(account);
    unified_spot_pool::share(spot_pool);

    // --- Phase 4: Update Factory State and Emit Event ---

    // Update factory state
    factory.dao_count = factory.dao_count + 1;

    // Emit event
    event::emit(DAOCreated {
        account_id,
        dao_name,
        asset_type: get_type_string<AssetType>(),
        stable_type: get_type_string<StableType>(),
        creator: ctx.sender(),
        affiliate_id,
        timestamp: clock.timestamp_ms(),
    });
}

#[test_only]
/// Internal function to create a DAO for testing without Extensions
fun create_dao_internal_test<AssetType: drop, StableType: drop>(
    factory: &mut Factory,
    registry: &PackageRegistry,
    fee_manager: &mut FeeManager,
    payment: Coin<SUI>,
    min_asset_amount: u64,
    min_stable_amount: u64,
    dao_name: AsciiString,
    icon_url_string: AsciiString,
    review_period_ms: u64,
    trading_period_ms: u64,
    twap_start_delay: u64,
    twap_step_max: u64,
    twap_initial_observation: u128,
    twap_threshold: SignedU128,
    amm_total_fee_bps: u64,
    description: UTF8String,
    max_outcomes: u64,
    _agreement_lines: vector<UTF8String>,
    _agreement_difficulties: vector<u64>,
    treasury_cap: TreasuryCap<AssetType>,
    coin_metadata: CoinMetadata<AssetType>,
    init_specs: vector<InitActionSpecs>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Check factory is not permanently disabled
    assert!(!factory.permanently_disabled, EPermanentlyDisabled);

    // Check factory is active
    assert!(!factory.paused, EPaused);

    // Check if StableType is allowed
    let stable_type_name = type_name::with_defining_ids<StableType>();
    assert!(factory.allowed_stable_types.contains(&stable_type_name), EStableTypeNotAllowed);

    // Process payment
    fee::deposit_dao_creation_payment(fee_manager, payment, clock, ctx);

    let affiliate_id = b"".to_string();

    // Validate parameters
    assert!(twap_step_max >= TWAP_MINIMUM_WINDOW_CAP, ELowTwapWindowCap);
    assert!(review_period_ms <= MAX_REVIEW_TIME, ELongReviewTime);
    assert!(trading_period_ms <= MAX_TRADING_TIME, ELongTradingTime);
    assert!(twap_start_delay <= MAX_TWAP_START_DELAY, ELongTwapDelayTime);
    assert!((twap_start_delay + 60_000) < trading_period_ms, EDelayNearTotalTrading);
    assert!(signed::magnitude(&twap_threshold) <= (MAX_TWAP_THRESHOLD as u128), EHighTwapThreshold);
    assert!(
        twap_initial_observation <= (18446744073709551615u128) * 1_000_000_000_000,
        ETwapInitialTooLarge,
    );

    // Create config parameters using the structured approach
    let trading_params = dao_config::new_trading_params(
        min_asset_amount,
        min_stable_amount,
        review_period_ms,
        trading_period_ms,
        amm_total_fee_bps, // conditional AMM fee
        amm_total_fee_bps, // spot AMM fee (same as conditional)
        0, // market_op_review_period_ms (0 = immediate, allows atomic market init)
        1000, // max_amm_swap_percent_bps (10% max swap per proposal)
        80, // conditional_liquidity_ratio_percent (80%, base 100 - enforced 1-99% range)
    );

    let twap_config = dao_config::new_twap_config(
        twap_start_delay,
        twap_step_max,
        twap_initial_observation,
        twap_threshold,
    );

    let governance_config = dao_config::new_governance_config(
        max_outcomes,
        20,
        500000, // proposal_creation_fee (0.5 of stable token, e.g., 0.5 USDC)
        1000000, // proposal_fee_per_outcome (1.0 of stable token per extra outcome)
        true,
        10,
        31_536_000_000,
        true,
        false, // show_proposal_details (default: false for security)
    );

    let metadata_config = dao_config::new_metadata_config(
        dao_name,
        url::new_unsafe(icon_url_string),
        description,
    );

    let dao_config = dao_config::new_dao_config(
        trading_params,
        twap_config,
        governance_config,
        metadata_config,
        dao_config::default_conditional_coin_config(),
        dao_config::default_quota_config(),
        dao_config::default_sponsorship_config(),
    );

    // --- Phase 1: Create all objects in memory (no sharing) ---

    // Create fee manager for this DAO
    let _dao_fee_manager_id = object::id(fee_manager); // Use factory fee manager for now

    // Create the unified spot pool with aggregator support enabled
    let spot_pool = unified_spot_pool::new_with_aggregator<AssetType, StableType>(
        amm_total_fee_bps, // Factory uses same fee for both conditional and spot
        option::none(), // No launch fee schedule by default (can be added via init specs)
        8000, // oracle_conditional_threshold_bps (80% threshold)
        clock,
        ctx,
    );
    let spot_pool_id = object::id(&spot_pool);

    // Create the futarchy configuration (uses safe default: challenge enabled = true)
    let config = futarchy_config::new<AssetType, StableType>(
        dao_config,
    );

    // Create the account using test function
    let mut account = futarchy_config::new_account_test(config, registry, ctx);

    // Initialize the default treasury vault (test version)
    {
        use account_protocol::version_witness;
        let test_version = version_witness::new_for_testing(@account_protocol);
        let auth = account::new_auth<FutarchyConfig, futarchy_config::ConfigWitness>(
            &account,
            registry,
            test_version,
            futarchy_config::authenticate(&account, ctx),
        );
        vault::open<FutarchyConfig>(auth, &mut account, registry, std::string::utf8(b"treasury"), ctx);

        // Pre-approve common coin types for permissionless deposits
        let auth = account::new_auth<FutarchyConfig, futarchy_config::ConfigWitness>(
            &account,
            registry,
            test_version,
            futarchy_config::authenticate(&account, ctx),
        );
        vault::approve_coin_type<FutarchyConfig, SUI>(auth, &mut account, registry, std::string::utf8(b"treasury"));

        let auth = account::new_auth<FutarchyConfig, futarchy_config::ConfigWitness>(
            &account,
            registry,
            test_version,
            futarchy_config::authenticate(&account, ctx),
        );
        vault::approve_coin_type<FutarchyConfig, AssetType>(auth, &mut account, registry, std::string::utf8(b"treasury"));

        let auth = account::new_auth<FutarchyConfig, futarchy_config::ConfigWitness>(
            &account,
            registry,
            test_version,
            futarchy_config::authenticate(&account, ctx),
        );
        vault::approve_coin_type<FutarchyConfig, StableType>(auth, &mut account, registry, std::string::utf8(b"treasury"));
    };

    // Lock treasury cap and store coin metadata using Move framework's currency module
    // TreasuryCap is stored via currency::lock_cap for proper atomic borrowing
    // CoinMetadata is stored separately for metadata updates via intents
    let auth = account::new_auth<FutarchyConfig, futarchy_config::ConfigWitness>(
        &account,
        registry,
        version::current(),
        futarchy_config::authenticate(&account, ctx),
    );

    // Store TreasuryCap
    currency::lock_cap(
        auth,
        &mut account,
        registry,
        treasury_cap,
        option::none(), // No max supply limit for now
    );

    // Store CoinMetadata for DAO governance control over coin metadata
    account.add_managed_asset(
        registry,
        CoinMetadataKey<AssetType> {},
        coin_metadata,
        version::current(),
    );

    // Note: init_specs are NOT stored in Account
    // Frontend receives them from createDAOWithInitSpecs transaction
    // Frontend then constructs PTB to execute init_* functions before sharing

    // Get account ID before sharing
    let account_id = object::id_address(&account);

    // --- Phase 3: Final Atomic Sharing ---
    // All objects are shared at the end of the function. If any step above failed,
    // the transaction would abort and no objects would be created.
    transfer::public_share_object(account);
    unified_spot_pool::share(spot_pool);

    // --- Phase 4: Update Factory State and Emit Event ---

    // Update factory state
    factory.dao_count = factory.dao_count + 1;

    // Emit event
    event::emit(DAOCreated {
        account_id,
        dao_name,
        asset_type: get_type_string<AssetType>(),
        stable_type: get_type_string<StableType>(),
        creator: ctx.sender(),
        affiliate_id,
        timestamp: clock.timestamp_ms(),
    });
}

// === Init Actions Support ===

// Removed InitWitness - it belongs in init_actions module
// Removed create_dao_for_init - not needed, use create_dao_unshared

/// Create DAO and return it without sharing (for init actions)
///
/// BREAKING CHANGE: Removed `store` ability requirement from AssetType and StableType.
/// This enables One-Time Witness (OTW) compliant coin types, which can only have `drop`.
/// If you need to store coin types in global storage, wrap them in a struct with `store`.
///
/// Create an unshared DAO for init action execution (PUBLIC - callable from PTBs)
/// Returns unshared Account and SpotPool that can be used in PTBs
/// Allows optional treasury_cap and coin_metadata (pass option::none() to defer)
/// Must call finalize_and_share_dao() after executing init actions
public fun create_dao_unshared<AssetType: drop, StableType: drop>(
    factory: &mut Factory,
    registry: &PackageRegistry,
    fee_manager: &mut FeeManager,
    payment: Coin<SUI>,
    treasury_cap: Option<TreasuryCap<AssetType>>,
    coin_metadata: Option<CoinMetadata<AssetType>>,
    clock: &Clock,
    ctx: &mut TxContext,
): (Account, UnifiedSpotPool<AssetType, StableType>) {
    // Check factory is not permanently disabled
    assert!(!factory.permanently_disabled, EPermanentlyDisabled);

    // Check factory is active
    assert!(!factory.paused, EPaused);

    // Check if StableType is allowed
    let stable_type_name = type_name::with_defining_ids<StableType>();
    assert!(factory.allowed_stable_types.contains(&stable_type_name), EStableTypeNotAllowed);

    // Process payment
    fee::deposit_dao_creation_payment(fee_manager, payment, clock, ctx);

    // Use all default configs - init actions will set real values
    let trading_params = dao_config::default_trading_params();
    let twap_config = dao_config::default_twap_config();
    let governance_config = dao_config::default_governance_config();

    // Minimal metadata - init actions will update
    let metadata_config = dao_config::new_metadata_config(
        b"DAO".to_ascii_string(), // Default name (init actions will override)
        url::new_unsafe_from_bytes(b""), // Empty icon (init actions will override)
        b"".to_string(), // Empty description (init actions will override)
    );

    let dao_config = dao_config::new_dao_config(
        trading_params,
        twap_config,
        governance_config,
        metadata_config,
        dao_config::default_conditional_coin_config(),
        dao_config::default_quota_config(),
        dao_config::default_sponsorship_config(),
    );

    // Create the futarchy config with safe default
    let config = futarchy_config::new<AssetType, StableType>(
        dao_config,
    );

    // Create account with config
    let mut account = futarchy_config::new_with_package_registry(registry, config, ctx);

    // Extract conditional_liquidity_ratio_percent from trading_params
    let conditional_liquidity_ratio_percent = dao_config::conditional_liquidity_ratio_percent(&trading_params);

    // Create unified spot pool with aggregator support enabled
    let spot_pool = unified_spot_pool::new_with_aggregator<AssetType, StableType>(
        30, // 0.3% default fee (init actions can configure via governance)
        option::none(), // No launch fee schedule by default (can be added via init specs)
        8000, // oracle_conditional_threshold_bps (80% threshold)
        conditional_liquidity_ratio_percent, // From DAO config!
        clock,
        ctx,
    );

    // Lock treasury cap and store coin metadata (if provided)
    // TreasuryCap is stored via currency::lock_cap for proper atomic borrowing
    // CoinMetadata is stored separately for metadata updates via intents
    // For launchpad pre-create flow, these will be none and added later via init_actions

    // Validate caps if both are provided
    if (treasury_cap.is_some() && coin_metadata.is_some()) {
        coin_registry::validate_coin_set(
            option::borrow(&treasury_cap),
            option::borrow(&coin_metadata),
        );
    };

    if (treasury_cap.is_some()) {
        let auth = account::new_auth<FutarchyConfig, futarchy_config::ConfigWitness>(
            &account,
            registry,
            version::current(),
            futarchy_config::authenticate(&account, ctx),
        );
        currency::lock_cap(
            auth,
            &mut account,
            registry,
            treasury_cap.destroy_some(),
            option::none(), // max_supply
        );
    } else {
        treasury_cap.destroy_none();
    };

    // Store CoinMetadata for DAO governance control over coin metadata
    if (coin_metadata.is_some()) {
        account.add_managed_asset(
            registry,
            CoinMetadataKey<AssetType> {},
            coin_metadata.destroy_some(),
            version::current(),
        );
    } else {
        coin_metadata.destroy_none();
    };

    // Update factory state
    factory.dao_count = factory.dao_count + 1;

    // Emit event with default metadata (init actions will update)
    let account_id = object::id_address(&account);
    event::emit(DAOCreated {
        account_id,
        dao_name: b"DAO".to_ascii_string(),
        asset_type: get_type_string<AssetType>(),
        stable_type: get_type_string<StableType>(),
        creator: ctx.sender(),
        affiliate_id: b"".to_string(), // Unshared DAO creation uses empty string (set via init actions)
        timestamp: clock.timestamp_ms(),
    });

    (account, spot_pool)
}

/// Create DAO for launchpad completion - NO FEE CHARGED
/// Launchpad already collected its own fee when raise was created
/// This is public(package) so only launchpad module can call it
public(package) fun create_dao_unshared_for_launchpad<AssetType: drop, StableType: drop>(
    factory: &mut Factory,
    registry: &PackageRegistry,
    treasury_cap: Option<TreasuryCap<AssetType>>,
    coin_metadata: Option<CoinMetadata<AssetType>>,
    clock: &Clock,
    ctx: &mut TxContext,
): Account {
    // Check factory is not permanently disabled
    assert!(!factory.permanently_disabled, EPermanentlyDisabled);

    // Check factory is active
    assert!(!factory.paused, EPaused);

    // Check if StableType is allowed
    let stable_type_name = type_name::with_defining_ids<StableType>();
    assert!(factory.allowed_stable_types.contains(&stable_type_name), EStableTypeNotAllowed);

    // NO FEE PAYMENT - launchpad already collected fee

    // Use all default configs - init actions will set real values
    let trading_params = dao_config::default_trading_params();
    let twap_config = dao_config::default_twap_config();
    let governance_config = dao_config::default_governance_config();

    // Minimal metadata - init actions will update
    let metadata_config = dao_config::new_metadata_config(
        b"DAO".to_ascii_string(), // Default name (init actions will override)
        url::new_unsafe_from_bytes(b""), // Empty icon (init actions will override)
        b"".to_string(), // Empty description (init actions will override)
    );

    let dao_config = dao_config::new_dao_config(
        trading_params,
        twap_config,
        governance_config,
        metadata_config,
        dao_config::default_conditional_coin_config(),
        dao_config::default_quota_config(),
        dao_config::default_sponsorship_config(),
    );

    // Create the futarchy config with safe default
    let config = futarchy_config::new<AssetType, StableType>(
        dao_config,
    );

    // Create account with config
    let mut account = futarchy_config::new_with_package_registry(registry, config, ctx);

    // NOTE: Spot pool is NOT auto-created for launchpad DAOs
    // It will be created via init actions, allowing the DAO to own the LP tokens

    // Lock treasury cap and store coin metadata (if provided)
    // TreasuryCap is stored via currency::lock_cap for proper atomic borrowing
    // CoinMetadata is stored separately for metadata updates via intents
    // For launchpad pre-create flow, these will be none and added later via init_actions

    // Validate caps if both are provided
    if (treasury_cap.is_some() && coin_metadata.is_some()) {
        coin_registry::validate_coin_set(
            option::borrow(&treasury_cap),
            option::borrow(&coin_metadata),
        );
    };

    if (treasury_cap.is_some()) {
        let auth = account::new_auth<FutarchyConfig, futarchy_config::ConfigWitness>(
            &account,
            registry,
            version::current(),
            futarchy_config::authenticate(&account, ctx),
        );
        currency::lock_cap(
            auth,
            &mut account,
            registry,
            treasury_cap.destroy_some(),
            option::none(), // max_supply
        );
    } else {
        treasury_cap.destroy_none();
    };

    // Store CoinMetadata for DAO governance control over coin metadata
    if (coin_metadata.is_some()) {
        account.add_managed_asset(
            registry,
            CoinMetadataKey<AssetType> {},
            coin_metadata.destroy_some(),
            version::current(),
        );
    } else {
        coin_metadata.destroy_none();
    };

    // Update factory state
    factory.dao_count = factory.dao_count + 1;

    // Emit event with default metadata (init actions will update)
    let account_id = object::id_address(&account);
    event::emit(DAOCreated {
        account_id,
        dao_name: b"DAO".to_ascii_string(),
        asset_type: get_type_string<AssetType>(),
        stable_type: get_type_string<StableType>(),
        creator: ctx.sender(),
        affiliate_id: b"launchpad".to_string(), // Mark as launchpad-created DAO
        timestamp: clock.timestamp_ms(),
    });

    account
}

public fun finalize_and_share_dao<AssetType, StableType>(
    account: Account,
    spot_pool: UnifiedSpotPool<AssetType, StableType>,
) {
    account::share_account<FutarchyConfig>(account);
    unified_spot_pool::share(spot_pool);
}

// === Admin Functions ===

/// Toggle factory pause state (reversible)
public entry fun toggle_pause(factory: &mut Factory, cap: &FactoryOwnerCap) {
    assert!(object::id(cap) == factory.owner_cap_id, EBadWitness);
    factory.paused = !factory.paused;
}

/// Permanently disable the factory - THIS CANNOT BE REVERSED
/// Once called, no new DAOs can ever be created from this factory
/// Existing DAOs are unaffected and continue to operate normally
public entry fun disable_permanently(
    factory: &mut Factory,
    cap: &FactoryOwnerCap,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(cap) == factory.owner_cap_id, EBadWitness);

    // Idempotency check: prevent duplicate disable and event emission
    assert!(!factory.permanently_disabled, EAlreadyDisabled);

    factory.permanently_disabled = true;

    event::emit(FactoryPermanentlyDisabled {
        admin: ctx.sender(),
        dao_count_at_shutdown: factory.dao_count,
        timestamp: clock.timestamp_ms(),
    });
}

/// Add an allowed stable coin type
public entry fun add_allowed_stable_type<StableType>(
    factory: &mut Factory,
    owner_cap: &FactoryOwnerCap,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(owner_cap) == factory.owner_cap_id, EBadWitness);
    let type_name_val = type_name::with_defining_ids<StableType>();

    if (!factory.allowed_stable_types.contains(&type_name_val)) {
        factory.allowed_stable_types.insert(type_name_val);

        event::emit(StableCoinTypeAdded {
            type_str: get_type_string<StableType>(),
            admin: ctx.sender(),
            timestamp: clock.timestamp_ms(),
        });
    }
}

/// Remove an allowed stable coin type
public entry fun remove_allowed_stable_type<StableType>(
    factory: &mut Factory,
    owner_cap: &FactoryOwnerCap,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(owner_cap) == factory.owner_cap_id, EBadWitness);
    let type_name_val = type_name::with_defining_ids<StableType>();
    if (factory.allowed_stable_types.contains(&type_name_val)) {
        factory.allowed_stable_types.remove(&type_name_val);

        event::emit(StableCoinTypeRemoved {
            type_str: get_type_string<StableType>(),
            admin: ctx.sender(),
            timestamp: clock.timestamp_ms(),
        });
    }
}

/// Update launchpad fee configuration
/// All fees are in MIST (1 SUI = 1_000_000_000 MIST)
public entry fun update_launchpad_fees(
    factory: &mut Factory,
    owner_cap: &FactoryOwnerCap,
    new_bid_fee: u64,
    new_cranker_reward: u64,
    new_settlement_reward: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(owner_cap) == factory.owner_cap_id, EBadWitness);

    let old_bid_fee = factory.launchpad_bid_fee;
    let old_cranker_reward = factory.launchpad_cranker_reward;
    let old_settlement_reward = factory.launchpad_settlement_reward;

    factory.launchpad_bid_fee = new_bid_fee;
    factory.launchpad_cranker_reward = new_cranker_reward;
    factory.launchpad_settlement_reward = new_settlement_reward;

    event::emit(LaunchpadFeesUpdated {
        admin: ctx.sender(),
        old_bid_fee,
        new_bid_fee,
        old_cranker_reward,
        new_cranker_reward,
        old_settlement_reward,
        new_settlement_reward,
        timestamp: clock.timestamp_ms(),
    });
}

/// Burn the factory owner cap
public entry fun burn_factory_owner_cap(factory: &Factory, cap: FactoryOwnerCap) {
    // It is good practice to check ownership one last time before burning,
    // even though only the owner can call this.
    assert!(object::id(&cap) == factory.owner_cap_id, EBadWitness);
    let FactoryOwnerCap { id } = cap;
    id.delete();
}

// === Validator Functions ===

/// Approve DAO verification request
/// Validators can approve a DAO's verification and set their attestation URL
public entry fun approve_verification(
    _validator_cap: &ValidatorAdminCap,
    target_dao: &mut Account,
    registry: &PackageRegistry,
    verification_id: ID,
    level: u8,
    attestation_url: String,
    admin_review_text: String,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let dao_id = object::id(target_dao);

    // Get mutable config to update verification level and review text
    let config = futarchy_config::internal_config_mut(target_dao, registry, version::current());
    futarchy_config::set_verification_level(config, level);
    futarchy_config::set_admin_review_text(config, admin_review_text);

    // Get mutable state to update pending flag and URL
    let dao_state = futarchy_config::state_mut_from_account(target_dao, registry);
    futarchy_config::set_verification_pending(dao_state, false);
    futarchy_config::set_attestation_url(dao_state, attestation_url);

    // Emit event for transparency
    event::emit(VerificationApproved {
        dao_id,
        verification_id,
        level,
        attestation_url,
        admin_review_text,
        validator: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

/// Reject DAO verification request
/// Validators can reject a verification request with a reason
public entry fun reject_verification(
    _validator_cap: &ValidatorAdminCap,
    target_dao: &mut Account,
    registry: &PackageRegistry,
    verification_id: ID,
    reason: String,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let dao_id = object::id(target_dao);

    // Get mutable state to reset verification status and clear attestation URL
    let dao_state = futarchy_config::state_mut_from_account(target_dao, registry);
    futarchy_config::set_verification_pending(dao_state, false);
    futarchy_config::set_attestation_url(dao_state, b"".to_string());

    // Emit event for transparency
    event::emit(VerificationRejected {
        dao_id,
        verification_id,
        reason,
        validator: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

/// Set DAO quality/reputation score
/// Validators can assign scores to DAOs for reputation/filtering purposes
public entry fun set_dao_score(
    _validator_cap: &ValidatorAdminCap,
    target_dao: &mut Account,
    registry: &PackageRegistry,
    score: u64,
    reason: String,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let dao_id = object::id(target_dao);

    // Get the DAO's config using internal_config_mut
    let config = futarchy_config::internal_config_mut(target_dao, registry, version::current());
    futarchy_config::set_dao_score(config, score);

    // Emit event for transparency
    event::emit(DaoScoreSet {
        dao_id,
        score,
        reason,
        validator: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// === View Functions ===

/// Get DAO count
public fun dao_count(factory: &Factory): u64 {
    factory.dao_count
}

/// Check if factory is paused (reversible)
public fun is_paused(factory: &Factory): bool {
    factory.paused
}

/// Check if factory is permanently disabled (irreversible)
public fun is_permanently_disabled(factory: &Factory): bool {
    factory.permanently_disabled
}

/// Check if a stable type is allowed
public fun is_stable_type_allowed<StableType>(factory: &Factory): bool {
    let type_name_val = type_name::with_defining_ids<StableType>();
    factory.allowed_stable_types.contains(&type_name_val)
}

/// Get launchpad bid fee (what users pay per contribution)
public fun launchpad_bid_fee(factory: &Factory): u64 {
    factory.launchpad_bid_fee
}

/// Get launchpad cranker reward (what crankers earn per claim)
public fun launchpad_cranker_reward(factory: &Factory): u64 {
    factory.launchpad_cranker_reward
}

/// Get launchpad settlement reward (reward per cap processed during settlement)
public fun launchpad_settlement_reward(factory: &Factory): u64 {
    factory.launchpad_settlement_reward
}

/// Get the permanently disabled error code (for external modules)
public fun permanently_disabled_error(): u64 {
    EPermanentlyDisabled
}

/// Read CoinMetadata from Account
/// Fully public function for market creation to access coin metadata
public fun borrow_coin_metadata<CoinType>(
    account: &Account,
    registry: &PackageRegistry,
): &CoinMetadata<CoinType> {
    account.borrow_managed_asset<CoinMetadataKey<CoinType>, CoinMetadata<CoinType>>(
        registry,
        CoinMetadataKey<CoinType> {},
        version::current(),
    )
}

// === Private Functions ===

fun get_type_string<T>(): UTF8String {
    let type_name_obj = type_name::with_original_ids<T>();
    let type_str = type_name_obj.into_string().into_bytes();
    type_str.to_string()
}

// === Test Functions ===

#[test_only]
public fun create_factory(ctx: &mut TxContext) {
    let owner_cap = FactoryOwnerCap {
        id: object::new(ctx),
    };

    let factory = Factory {
        id: object::new(ctx),
        dao_count: 0,
        paused: false,
        permanently_disabled: false,
        owner_cap_id: object::id(&owner_cap),
        allowed_stable_types: vec_set::empty(),
        launchpad_bid_fee: constants::launchpad_bid_fee_per_contribution(),
        launchpad_cranker_reward: constants::launchpad_cranker_reward_per_claim(),
        launchpad_settlement_reward: constants::launchpad_reward_per_cap_processed(),
    };

    let validator_cap = ValidatorAdminCap {
        id: object::new(ctx),
    };

    transfer::share_object(factory);
    transfer::public_transfer(owner_cap, ctx.sender());
    transfer::public_transfer(validator_cap, ctx.sender());
}

#[test_only]
/// Create a DAO for testing without Extensions
public entry fun create_dao_test<AssetType: drop, StableType: drop>(
    factory: &mut Factory,
    registry: &package_registry::PackageRegistry,
    fee_manager: &mut FeeManager,
    payment: Coin<SUI>,
    min_asset_amount: u64,
    min_stable_amount: u64,
    dao_name: AsciiString,
    icon_url_string: AsciiString,
    review_period_ms: u64,
    trading_period_ms: u64,
    twap_start_delay: u64,
   twap_step_max: u64,
   twap_initial_observation: u128,
    twap_threshold_magnitude: u128,
    twap_threshold_negative: bool,
    amm_total_fee_bps: u64,
    description: UTF8String,
    max_outcomes: u64,
    _agreement_lines: vector<UTF8String>,
    _agreement_difficulties: vector<u64>,
    treasury_cap: TreasuryCap<AssetType>,
    coin_metadata: CoinMetadata<AssetType>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Validate caps at entry point
    coin_registry::validate_coin_set(&treasury_cap, &coin_metadata);

    // For testing, we bypass the Extensions requirement
    // by directly calling the test internal function
    let twap_threshold = signed::new(twap_threshold_magnitude, twap_threshold_negative);

    create_dao_internal_test<AssetType, StableType>(
        factory,
        registry,
        fee_manager,
        payment,
        min_asset_amount,
        min_stable_amount,
        dao_name,
        icon_url_string,
        review_period_ms,
        trading_period_ms,
        twap_start_delay,
        twap_step_max,
        twap_initial_observation,
        twap_threshold,
        amm_total_fee_bps,
        description,
        max_outcomes,
        _agreement_lines,
        _agreement_difficulties,
        treasury_cap,
        coin_metadata,
        vector::empty(),
        clock,
        ctx,
    );
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// PTB execution helpers for launchpad init intents.
///
/// The frontend composes a programmable transaction that:
/// 1. Calls `begin_execution` to receive the launchpad executable hot potato.
/// 2. Invokes the relevant `do_init_*` action functions in order (routing is handled client-side).
/// 3. Calls `finalize_execution` to confirm the intent and emit events.
///
/// This keeps execution logic flexible while guaranteeing on-chain sequencing with the
/// executable's action counter.
///
/// Pattern matches futarchy_governance::ptb_executor for consistency.
module futarchy_factory::launchpad_intent_executor;

use account_protocol::{
    account::{Self, Account},
    executable::{Self, Executable},
    intents,
    package_registry::PackageRegistry,
};
use account_actions::version;
use futarchy_core::futarchy_config::{Self as fc, FutarchyConfig};
use futarchy_factory::launchpad::{Self, Raise};
use futarchy_factory::launchpad_outcome::LaunchpadOutcome;
use std::string::{Self, String};
use sui::{clock::Clock, event, object, tx_context::TxContext};

// === Errors ===

// === Events ===
/// Event emitted when a launchpad init intent is executed
public struct LaunchpadIntentExecuted has copy, drop {
    raise_id: object::ID,
    account_id: object::ID,
    intent_key: String,
    timestamp: u64,
}

/// Begin execution for a successful raise by creating the launchpad executable.
/// - Verifies the raise succeeded.
/// - Executes the "launchpad_init" intent with outcome validation.
/// Returns the executable hot potato for the PTB to route to do_init_* functions.
public fun begin_execution<RaiseToken: drop, StableCoin: drop>(
    raise: &Raise<RaiseToken, StableCoin>,
    account: &mut Account,
    registry: &PackageRegistry,
    clock: &Clock,
    ctx: &mut TxContext,
): Executable<LaunchpadOutcome> {
    // Create executable from the existing "launchpad_init" intent
    let (outcome, executable) = account::create_executable<FutarchyConfig, LaunchpadOutcome, _>(
        account,
        registry,
        string::utf8(b"launchpad_init"),
        clock,
        version::current(),
        fc::witness(),
        ctx,
    );

    // Validate that the raise succeeded
    assert!(launchpad::is_outcome_approved(&outcome, raise), 0);

    executable
}

/// Finalize execution after all init actions have been processed.
/// Confirms the executable and emits the execution event.
/// Note: Cannot be `entry` because Executable<LaunchpadOutcome> is not a valid entry parameter type
public fun finalize_execution<RaiseToken: drop, StableCoin: drop>(
    raise: &Raise<RaiseToken, StableCoin>,
    account: &mut Account,
    executable: Executable<LaunchpadOutcome>,
    clock: &Clock,
) {
    let intent_key = intents::key(executable::intent(&executable));

    account::confirm_execution(account, executable);

    event::emit(LaunchpadIntentExecuted {
        raise_id: object::id(raise),
        account_id: object::id(account),
        intent_key,
        timestamp: clock.timestamp_ms(),
    });
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Outcome type for launchpad initialization intents
///
/// When a raise completes successfully, intents with LaunchpadOutcome
/// become approved and can be executed by keepers.
module futarchy_factory::launchpad_outcome;

use sui::object::ID;

/// Outcome type for launchpad initialization intents
/// Approval is determined by raise.state == STATE_SUCCESSFUL
public struct LaunchpadOutcome has copy, drop, store {
    raise_id: ID,
}

// === Constructors ===

public fun new(raise_id: ID): LaunchpadOutcome {
    LaunchpadOutcome { raise_id }
}

// === Getters ===

public fun raise_id(outcome: &LaunchpadOutcome): ID {
    outcome.raise_id
}

// Note: Validation function is_approved() is in launchpad.move to avoid circular dependency
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

module futarchy_factory::launchpad;

use account_actions::currency::{Self, CoinMetadataKey, CurrencyRules, CurrencyRulesKey};
use account_actions::init_actions;
use account_protocol::account::Account;
use account_protocol::intent_interface;
use account_protocol::intents;
use account_protocol::package_registry::PackageRegistry;
use futarchy_core::futarchy_config::{Self, FutarchyConfig};
use futarchy_core::version;
use futarchy_factory::factory;
use futarchy_factory::launchpad_outcome;
use futarchy_markets_core::fee;
use futarchy_markets_core::unified_spot_pool::{Self, UnifiedSpotPool};
use futarchy_one_shot_utils::constants;
use futarchy_one_shot_utils::math;
use account_actions::init_action_specs::{Self as action_specs, InitActionSpecs};
use std::option::{Self, Option};
use std::string::{Self, String};
use std::type_name;
use std::vector;
use sui::balance::{Self, Balance};
use sui::clock::Clock;
use sui::coin::{Self, Coin, CoinMetadata, TreasuryCap};
use sui::dynamic_field as df;
use sui::event;
use sui::object::{Self, UID, ID};
use sui::package::{Self, Publisher};
use sui::transfer as sui_transfer;
use sui::tx_context::TxContext;


// === Capabilities ===
public struct CreatorCap has key, store {
    id: UID,
    raise_id: ID,
}

// === Errors ===
const ERaiseNotActive: u64 = 1;
const EDeadlineNotReached: u64 = 2;
const EMinRaiseNotMet: u64 = 3;
const EMinRaiseAlreadyMet: u64 = 4;
const ENotAContributor: u64 = 6;
const EInvalidStateForAction: u64 = 7;
const EZeroContribution: u64 = 13;
const EStableTypeNotAllowed: u64 = 14;
const EInvalidActionData: u64 = 16;
const ESettlementAlreadyDone: u64 = 103;
const ECapChangeAfterDeadline: u64 = 105;
const ETooManyUniqueCaps: u64 = 109;
const ETooManyInitActions: u64 = 110;
const EDaoNotPreCreated: u64 = 111;
const EIntentsAlreadyLocked: u64 = 113;
const EResourcesNotFound: u64 = 114;
const EInvalidMaxRaise: u64 = 116;
const EAllowedCapsNotSorted: u64 = 121;
const EAllowedCapsEmpty: u64 = 122;
const EIntentsNotLocked: u64 = 123;
const ESupplyNotZero: u64 = 130;
const EInvalidCreatorCap: u64 = 132;
const EEarlyCompletionNotAllowed: u64 = 133;
const EInvalidCrankFee: u64 = 134;
const EBatchSizeTooLarge: u64 = 135;
const EEmptyBatch: u64 = 136;
const ENoProtocolFeesToSweep: u64 = 137;

// === Constants ===
const STATE_FUNDING: u8 = 0;
const STATE_SUCCESSFUL: u8 = 1;
const STATE_FAILED: u8 = 2;

const PERMISSIONLESS_COMPLETION_DELAY_MS: u64 = 24 * 60 * 60 * 1000;
const MAX_BATCH_SIZE: u64 = 100;
const UNLIMITED_CAP: u64 = 18446744073709551615;

public fun unlimited_cap(): u64 { UNLIMITED_CAP }

// === Structs ===
public struct LAUNCHPAD has drop {}

/// Hot potato for unshared DAO - MUST be consumed by finalize_and_share_dao
/// Enforces atomic init action execution before sharing
#[allow(lint(missing_key))]
public struct UnsharedDao<phantom RaiseToken, phantom StableCoin> {
    account: Account,
    // NOTE: spot_pool removed - will be created via init actions
}

public struct ContributorKey has copy, drop, store {
    contributor: address,
}

public struct Contribution has copy, drop, store {
    amount: u64,
    max_total_cap: u64,
}
public struct DaoAccountKey has copy, drop, store {}
public struct DaoQueueKey has copy, drop, store {}
public struct DaoPoolKey has copy, drop, store {}
/// Local key for storing CoinMetadata temporarily on Raise object
/// (different from currency::CoinMetadataKey which is used on Account)
public struct RaiseCoinMetadataKey has copy, drop, store {}
public struct Raise<phantom RaiseToken, phantom StableCoin> has key, store {
    id: UID,
    account_id: Option<ID>,  // Reference to the Account (set when dao created, used for JIT Intent creation)
    creator: address,
    affiliate_id: String,
    state: u8,

    min_raise_amount: u64,
    max_raise_amount: Option<u64>,
    start_time_ms: u64,
    deadline_ms: u64,
    allow_early_completion: bool,

    raise_token_vault: Balance<RaiseToken>,
    tokens_for_sale_amount: u64,
    stable_coin_vault: Balance<StableCoin>,
    description: String,

    // Two-outcome system (like proposals)
    success_specs: InitActionSpecs,  // Execute if raise succeeds
    failure_specs: InitActionSpecs,  // Execute if raise fails (return caps to creator)
    treasury_cap: Option<TreasuryCap<RaiseToken>>,
    coin_metadata: Option<CoinMetadata<RaiseToken>>,

    allowed_caps: vector<u64>,
    cap_sums: vector<u64>,

    settlement_done: bool,
    final_raise_amount: u64,

    dao_id: Option<ID>,
    intents_locked: bool,

    verification_level: u8,
    attestation_url: String,
    admin_review_text: String,

    crank_fee_vault: Balance<sui::sui::SUI>,
}

// === Events ===
public struct InitIntentStaged has copy, drop {
    raise_id: ID,
    staged_index: u64,
    action_count: u64,
}

public struct InitIntentRemoved has copy, drop {
    raise_id: ID,
    staged_index: u64,
}

public struct FailedRaiseCleanup has copy, drop {
    raise_id: ID,
    dao_id: ID,
    timestamp: u64,
}

public struct RaiseCreated has copy, drop {
    raise_id: ID,
    creator: address,
    affiliate_id: String,
    raise_token_type: String,
    stable_coin_type: String,
    min_raise_amount: u64,
    tokens_for_sale: u64,
    start_time_ms: u64,
    deadline_ms: u64,
    description: String,
    // Generic metadata (parallel vectors for indexing)
    // Common keys: website, twitter, discord, github, whitepaper, legal_docs, project_plan, team_info
    metadata_keys: vector<String>,
    metadata_values: vector<String>,
}

public struct ContributionAdded has copy, drop {
    raise_id: ID,
    contributor: address,
    amount: u64,
    max_total_cap: u64,
}

public struct SettlementFinalized has copy, drop {
    raise_id: ID,
    final_total: u64,
}

public struct RaiseSuccessful has copy, drop {
    raise_id: ID,
    total_raised: u64,
}

public struct RaiseFailed has copy, drop {
    raise_id: ID,
    total_raised: u64,
    min_raise_amount: u64,
}

public struct TokensClaimed has copy, drop {
    raise_id: ID,
    contributor: address,
    contribution_amount: u64,
    tokens_claimed: u64,
}

public struct RefundClaimed has copy, drop {
    raise_id: ID,
    contributor: address,
    refund_amount: u64,
}

public struct RaiseEndedEarly has copy, drop {
    raise_id: ID,
    total_raised: u64,
    original_deadline: u64,
    ended_at: u64,
}

public struct DustSwept has copy, drop {
    raise_id: ID,
    token_dust_amount: u64,
    stable_dust_amount: u64,
    token_recipient: address,
    stable_recipient: ID,
    timestamp: u64,
}

public struct TreasuryCapReturned has copy, drop {
    raise_id: ID,
    tokens_burned: u64,
    recipient: address,
    timestamp: u64,
}

public struct BatchClaimCompleted has copy, drop {
    raise_id: ID,
    cranker: address,
    attempted: u64,
    successful: u64,
    total_reward: u64,
}

public struct ProtocolFeesSwept has copy, drop {
    raise_id: ID,
    amount: u64,
    recipient: address,
    timestamp: u64,
}

public struct LaunchpadVerificationSet has copy, drop {
    raise_id: ID,
    level: u8,
    attestation_url: String,
    admin_review_text: String,
    validator: address,
    timestamp: u64,
}

// === Init ===
fun init(otw: LAUNCHPAD, ctx: &mut TxContext) {
    let publisher = package::claim(otw, ctx);
    sui_transfer::public_transfer(publisher, ctx.sender());
}

// === Public Functions ===

/// REMOVED: pre_create_dao_for_raise
///
/// This function was removed to fix ESharedNonNewObject error.
/// Sui requires objects to be shared in the same transaction they're created.
///
/// OLD FLOW (broken):
///   1. pre_create_dao_for_raise ‚Üí creates Account in TX1
///   2. complete_raise ‚Üí tries to share Account in TX2 ‚Üí FAILS with ESharedNonNewObject
///
/// NEW FLOW (fixed):
///   1. complete_raise ‚Üí creates Account + shares it in same TX ‚Üí SUCCESS
///   2. Frontend PTB ‚Üí manually executes init actions against shared Account
///
/// INIT ACTIONS PATTERN (Disclosure-Only):
///
/// InitActionSpecs serve as INVESTOR TRANSPARENCY - they show what will happen
/// during DAO initialization, but they are NOT auto-executed.
///
/// FLOW:
///   1. Creator stages InitActionSpecs (stored in Raise.staged_init_specs)
///   2. Investors see what actions will execute and decide to invest
///   3. complete_raise creates DAO and shares Account
///   4. Frontend PTB MANUALLY calls init functions (e.g., init_create_stream)
///      - Manual execution via PTB, NOT automatic dispatch
///      - The staged specs are for disclosure only
///
/// WHY: InitActionSpecs don't have a dispatcher. The action_type is a label
/// for transparency. Execution requires explicit PTB calls to init functions.
///
/// See: futarchy_actions/INIT_ACTION_STAGING_GUIDE.md
///
/// NOTE: DAO creation fee payment moved to complete_raise_internal.

/// Stage SUCCESS initialization actions (executed if raise succeeds)
/// These actions create pools, streams, etc. using the raised funds
public fun stage_success_intent<RaiseToken, StableCoin>(
    raise: &mut Raise<RaiseToken, StableCoin>,
    _registry: &PackageRegistry,
    creator_cap: &CreatorCap,
    spec: InitActionSpecs,
    _clock: &Clock,
    _ctx: &mut TxContext,
) {
    assert!(creator_cap.raise_id == object::id(raise), EInvalidCreatorCap);
    assert!(raise.state == STATE_FUNDING, EInvalidStateForAction);
    assert!(!raise.intents_locked, EIntentsAlreadyLocked);

    let action_count = action_specs::action_count(&spec);
    assert!(action_count > 0, EInvalidActionData);

    let current_count = action_specs::action_count(&raise.success_specs);
    assert!(current_count + action_count <= constants::launchpad_max_init_actions(), ETooManyInitActions);

    // Merge specs into success_specs
    let actions = action_specs::actions(&spec);
    let mut i = 0;
    while (i < vector::length(actions)) {
        let action = vector::borrow(actions, i);
        action_specs::add_action(
            &mut raise.success_specs,
            action_specs::action_type(action),
            *action_specs::action_data(action)
        );
        i = i + 1;
    };

    event::emit(InitIntentStaged {
        raise_id: object::id(raise),
        staged_index: 0,  // Success outcome
        action_count
    });
}

/// Stage FAILURE initialization actions (executed if raise fails)
/// These actions return TreasuryCap and metadata to the creator
public fun stage_failure_intent<RaiseToken, StableCoin>(
    raise: &mut Raise<RaiseToken, StableCoin>,
    _registry: &PackageRegistry,
    creator_cap: &CreatorCap,
    spec: InitActionSpecs,
    _clock: &Clock,
    _ctx: &mut TxContext,
) {
    assert!(creator_cap.raise_id == object::id(raise), EInvalidCreatorCap);
    assert!(raise.state == STATE_FUNDING, EInvalidStateForAction);
    assert!(!raise.intents_locked, EIntentsAlreadyLocked);

    let action_count = action_specs::action_count(&spec);
    assert!(action_count > 0, EInvalidActionData);

    let current_count = action_specs::action_count(&raise.failure_specs);
    assert!(current_count + action_count <= constants::launchpad_max_init_actions(), ETooManyInitActions);

    // Merge specs into failure_specs
    let actions = action_specs::actions(&spec);
    let mut i = 0;
    while (i < vector::length(actions)) {
        let action = vector::borrow(actions, i);
        action_specs::add_action(
            &mut raise.failure_specs,
            action_specs::action_type(action),
            *action_specs::action_data(action)
        );
        i = i + 1;
    };

    event::emit(InitIntentStaged {
        raise_id: object::id(raise),
        staged_index: 1,  // Failure outcome
        action_count
    });
}

/// Clear all success specs (allows re-staging from scratch)
public entry fun clear_success_specs<RaiseToken, StableCoin>(
    raise: &mut Raise<RaiseToken, StableCoin>,
    creator_cap: &CreatorCap,
    _ctx: &mut TxContext,
) {
    assert!(creator_cap.raise_id == object::id(raise), EInvalidCreatorCap);
    assert!(raise.state == STATE_FUNDING, EInvalidStateForAction);
    assert!(!raise.intents_locked, EIntentsAlreadyLocked);

    raise.success_specs = action_specs::new_init_specs();
    event::emit(InitIntentRemoved { raise_id: object::id(raise), staged_index: 0 });
}

/// Clear all failure specs (allows re-staging from scratch)
public entry fun clear_failure_specs<RaiseToken, StableCoin>(
    raise: &mut Raise<RaiseToken, StableCoin>,
    creator_cap: &CreatorCap,
    _ctx: &mut TxContext,
) {
    assert!(creator_cap.raise_id == object::id(raise), EInvalidCreatorCap);
    assert!(raise.state == STATE_FUNDING, EInvalidStateForAction);
    assert!(!raise.intents_locked, EIntentsAlreadyLocked);

    raise.failure_specs = action_specs::new_init_specs();
    event::emit(InitIntentRemoved { raise_id: object::id(raise), staged_index: 1 });
}

/// Lock intents - no more can be added after this
public entry fun lock_intents_and_start_raise<RaiseToken, StableCoin>(
    raise: &mut Raise<RaiseToken, StableCoin>,
    creator_cap: &CreatorCap,
    _ctx: &mut TxContext,
) {
    assert!(creator_cap.raise_id == object::id(raise), EInvalidCreatorCap);
    assert!(!raise.intents_locked, EInvalidStateForAction);
    raise.intents_locked = true;
}

/// Create a pro-rata raise with max cap levels
public fun create_raise<RaiseToken: drop, StableCoin: drop>(
    factory: &factory::Factory,
    fee_manager: &mut fee::FeeManager,
    treasury_cap: TreasuryCap<RaiseToken>,
    coin_metadata: CoinMetadata<RaiseToken>,
    affiliate_id: String,
    tokens_for_sale: u64,
    min_raise_amount: u64,
    max_raise_amount: Option<u64>,
    allowed_caps: vector<u64>,
    start_delay_ms: Option<u64>,
    allow_early_completion: bool,
    description: String,
    // Generic metadata (parallel vectors, emitted in event for indexing)
    metadata_keys: vector<String>,
    metadata_values: vector<String>,
    launchpad_fee: Coin<sui::sui::SUI>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Check factory is not permanently disabled
    assert!(!factory::is_permanently_disabled(factory), factory::permanently_disabled_error());

    // Collect launchpad creation fee
    fee::deposit_launchpad_creation_payment(fee_manager, launchpad_fee, clock, ctx);

    assert!(min_raise_amount > 0, EInvalidStateForAction);
    assert!(tokens_for_sale > 0, EInvalidStateForAction);
    assert!(affiliate_id.length() <= 64, EInvalidStateForAction);
    assert!(description.length() <= 1000, EInvalidStateForAction);
    assert!(coin::total_supply(&treasury_cap) == 0, ESupplyNotZero);
    assert!(factory::is_stable_type_allowed<StableCoin>(factory), EStableTypeNotAllowed);

    // Validate metadata vectors
    assert!(metadata_keys.length() == metadata_values.length(), EInvalidStateForAction);
    assert!(metadata_keys.length() <= 20, EInvalidStateForAction); // Max 20 metadata entries

    if (option::is_some(&max_raise_amount)) {
        assert!(*option::borrow(&max_raise_amount) >= min_raise_amount, EInvalidMaxRaise);
    };

    // Validate allowed_caps
    assert!(!vector::is_empty(&allowed_caps), EAllowedCapsEmpty);
    assert!(is_sorted_ascending(&allowed_caps), EAllowedCapsNotSorted);
    assert!(vector::length(&allowed_caps) <= 128, ETooManyUniqueCaps);

    // Enforce that the highest cap is UNLIMITED_CAP
    let last_cap = *vector::borrow(&allowed_caps, vector::length(&allowed_caps) - 1);
    assert!(last_cap == UNLIMITED_CAP, EInvalidStateForAction);

    init_raise<RaiseToken, StableCoin>(
        treasury_cap,
        coin_metadata,
        affiliate_id,
        tokens_for_sale,
        min_raise_amount,
        max_raise_amount,
        allowed_caps,
        start_delay_ms,
        allow_early_completion,
        description,
        metadata_keys,
        metadata_values,
        clock,
        ctx,
    );
}

/// Contribute with max_total_cap (use UNLIMITED_CAP to accept any raise amount)
public entry fun contribute<RaiseToken, StableCoin>(
    raise: &mut Raise<RaiseToken, StableCoin>,
    factory: &factory::Factory,
    payment: Coin<StableCoin>,
    max_total_cap: u64,
    crank_fee: Coin<sui::sui::SUI>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(raise.state == STATE_FUNDING, ERaiseNotActive);
    assert!(raise.intents_locked, EIntentsNotLocked); // Ensure specs are locked before accepting contributions
    assert!(clock.timestamp_ms() >= raise.start_time_ms, ERaiseNotActive);
    assert!(clock.timestamp_ms() < raise.deadline_ms, ERaiseNotActive);

    let amount = payment.value();
    assert!(amount > 0, EZeroContribution);

    // Collect bid fee (configured at factory level)
    let required_fee = factory::launchpad_bid_fee(factory);
    assert!(crank_fee.value() == required_fee, EInvalidCrankFee);
    raise.crank_fee_vault.join(crank_fee.into_balance());

    assert!(
        max_total_cap == UNLIMITED_CAP || is_cap_allowed(max_total_cap, &raise.allowed_caps),
        EInvalidStateForAction
    );

    let contributor = ctx.sender();
    let key = ContributorKey { contributor };

    let mut old_amount = 0u64;
    let mut old_cap = 0u64;
    if (df::exists_(&raise.id, key)) {
        let contrib: &mut Contribution = df::borrow_mut(&mut raise.id, key);

        assert!(
            contrib.max_total_cap == max_total_cap ||
            clock.timestamp_ms() < raise.deadline_ms - (24 * 60 * 60 * 1000),
            ECapChangeAfterDeadline
        );

        old_amount = contrib.amount;
        old_cap = contrib.max_total_cap;

        contrib.amount = contrib.amount + amount;
        contrib.max_total_cap = max_total_cap;
    } else {
        df::add(&mut raise.id, key, Contribution { amount, max_total_cap });
    };

    if (old_amount > 0) {
        let cap_count = vector::length(&raise.allowed_caps);
        let mut i = 0;
        while (i < cap_count) {
            let cap = *vector::borrow(&raise.allowed_caps, i);
            // If old max cap was at or below this cap level, subtract old contribution
            if (old_cap <= cap) {
                let sum = vector::borrow_mut(&mut raise.cap_sums, i);
                *sum = *sum - old_amount;
            };
            i = i + 1;
        };
    };

    let new_total = old_amount + amount;
    let cap_count = vector::length(&raise.allowed_caps);
    let mut i = 0;
    while (i < cap_count) {
        let cap = *vector::borrow(&raise.allowed_caps, i);
        // If contributor's max cap is at or below this cap level, they can participate
        if (max_total_cap <= cap) {
            let sum = vector::borrow_mut(&mut raise.cap_sums, i);
            *sum = *sum + new_total;
        };
        i = i + 1;
    };

    raise.stable_coin_vault.join(payment.into_balance());

    event::emit(ContributionAdded {
        raise_id: object::id(raise),
        contributor,
        amount,
        max_total_cap,
    });
}

/// Settle raise: O(C) algorithm where C ‚â§ 128
/// Finds max valid raise S where S <= cap C
/// cap_sums maintained incrementally during contribute()
public entry fun settle_raise<RaiseToken, StableCoin>(
    raise: &mut Raise<RaiseToken, StableCoin>,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    assert!(raise.state == STATE_FUNDING, EInvalidStateForAction);
    assert!(clock.timestamp_ms() >= raise.deadline_ms, EDeadlineNotReached);
    assert!(!raise.settlement_done, ESettlementAlreadyDone);

    let mut best_total = 0u64;
    let cap_count = vector::length(&raise.allowed_caps);
    let mut i = cap_count;
    while (i > 0) {
        i = i - 1;
        let cap = *vector::borrow(&raise.allowed_caps, i);
        let sum = *vector::borrow(&raise.cap_sums, i);
        if (sum <= cap && sum > best_total) {
            best_total = sum;
        };
    };

    let mut final_amount = best_total;

    // Don't abort if minimum not met - allow settlement to complete
    // State will be set to FAILED in finalize_and_share_dao if min not met
    // This allows failure_specs to be executed via Intent

    if (option::is_some(&raise.max_raise_amount)) {
        let max_raise = *option::borrow(&raise.max_raise_amount);
        if (final_amount > max_raise) {
            final_amount = max_raise;
        };
    };

    raise.final_raise_amount = final_amount;
    raise.settlement_done = true;

    event::emit(SettlementFinalized {
        raise_id: object::id(raise),
        final_total: final_amount,
    });
}

/// Allow creator to end raise early
public entry fun end_raise_early<RT, SC>(
    raise: &mut Raise<RT, SC>,
    creator_cap: &CreatorCap,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    assert!(creator_cap.raise_id == object::id(raise), EInvalidCreatorCap);
    assert!(raise.state == STATE_FUNDING, EInvalidStateForAction);
    assert!(clock.timestamp_ms() < raise.deadline_ms, EDeadlineNotReached);
    assert!(raise.allow_early_completion, EEarlyCompletionNotAllowed);
    assert!(raise.stable_coin_vault.value() >= raise.min_raise_amount, EMinRaiseNotMet);

    let original_deadline = raise.deadline_ms;
    raise.deadline_ms = clock.timestamp_ms();

    event::emit(RaiseEndedEarly {
        raise_id: object::id(raise),
        total_raised: raise.stable_coin_vault.value(),
        original_deadline,
        ended_at: clock.timestamp_ms(),
    });
}

/// Complete the raise and activate DAO (creator with optional final_raise_amount)
public entry fun complete_raise<RaiseToken: drop, StableCoin: drop>(
    raise: &mut Raise<RaiseToken, StableCoin>,
    creator_cap: &CreatorCap,
    final_raise_amount: u64,
    factory: &mut factory::Factory,
    registry: &PackageRegistry,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(creator_cap.raise_id == object::id(raise), EInvalidCreatorCap);
    assert!(raise.state == STATE_FUNDING, EInvalidStateForAction);
    assert!(clock.timestamp_ms() >= raise.deadline_ms, EDeadlineNotReached);
    assert!(raise.settlement_done, EInvalidStateForAction);

    // Validate final_raise_amount
    let total_raised = raise.stable_coin_vault.value();
    assert!(final_raise_amount >= raise.min_raise_amount, EMinRaiseNotMet);
    assert!(final_raise_amount <= total_raised, EInvalidStateForAction);
    if (option::is_some(&raise.max_raise_amount)) {
        let max = *option::borrow(&raise.max_raise_amount);
        assert!(final_raise_amount <= max, EInvalidStateForAction);
    };

    // Override the settlement's final_raise_amount with creator's choice
    raise.final_raise_amount = final_raise_amount;

    complete_raise_internal(raise, factory, registry, clock, ctx);
}

/// Permissionless completion after 24h delay (uses max automatically)
public entry fun complete_raise_permissionless<RaiseToken: drop, StableCoin: drop>(
    raise: &mut Raise<RaiseToken, StableCoin>,
    factory: &mut factory::Factory,
    registry: &PackageRegistry,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(raise.state == STATE_FUNDING, EInvalidStateForAction);
    assert!(clock.timestamp_ms() >= raise.deadline_ms, EDeadlineNotReached);
    assert!(raise.settlement_done, EInvalidStateForAction);

    let permissionless_open = raise.deadline_ms + PERMISSIONLESS_COMPLETION_DELAY_MS;
    assert!(clock.timestamp_ms() >= permissionless_open, EInvalidStateForAction);

    // Permissionless uses the total raised (max possible)
    let total_raised = raise.stable_coin_vault.value();
    let mut final_amount = total_raised;

    // But respect max_raise_amount if set
    if (option::is_some(&raise.max_raise_amount)) {
        let max = *option::borrow(&raise.max_raise_amount);
        if (final_amount > max) {
            final_amount = max;
        };
    };

    raise.final_raise_amount = final_amount;

    complete_raise_internal(raise, factory, registry, clock, ctx);
}

/// Create unshared DAO with built-in init actions - returns hot potato for custom init actions
/// PTB must call init_* functions on unshared DAO, then finalize_and_share_dao()
fun complete_raise_unshared<RaiseToken: drop, StableCoin: drop>(
    raise: &mut Raise<RaiseToken, StableCoin>,
    factory: &mut factory::Factory,
    registry: &PackageRegistry,
    clock: &Clock,
    ctx: &mut TxContext,
): UnsharedDao<RaiseToken, StableCoin> {
    assert!(raise.state == STATE_FUNDING, EInvalidStateForAction);
    assert!(raise.settlement_done, EInvalidStateForAction);

    let final_total = raise.final_raise_amount;
    // Don't assert minimum met - allow DAO creation for failed raises too
    // This enables failure_specs execution via Intent system
    let raise_succeeded = final_total >= raise.min_raise_amount;

    // No DAO creation fee - launchpad already collected fee when raise was created

    // Create NEW DAO (unshared)
    // Uses special launchpad function that doesn't charge DAO creation fee
    // NOTE: Spot pool is NOT auto-created - will be created via init actions
    let mut account = factory::create_dao_unshared_for_launchpad<RaiseToken, StableCoin>(
        factory,
        registry,
        option::none(), // treasury_cap - added below
        option::none(), // coin_metadata - added below
        clock,
        ctx,
    );

    // Store DAO ID for reference
    let account_id = object::id(&account);
    raise.dao_id = option::some(account_id);
    raise.account_id = option::some(account_id);  // For JIT Intent creation

    // Deposit treasury cap
    let treasury_cap = raise.treasury_cap.extract();

    if (raise_succeeded) {
        // SUCCESS: Lock the treasury cap (makes it inaccessible except through proposals)
        init_actions::init_lock_treasury_cap<FutarchyConfig, RaiseToken>(&mut account, registry, treasury_cap);
    } else {
        // FAILURE: Store as removable managed asset so failure_specs can remove and transfer it
        // Also create and store CurrencyRules (needed for removal)
        let rules = currency::new_currency_rules<RaiseToken>(
            option::none(), // no max_supply
            true,  // can_mint
            true,  // can_burn
            true,  // can_update_symbol
            true,  // can_update_name
            true,  // can_update_description
            true,  // can_update_icon
        );

        init_actions::init_store_data<FutarchyConfig, CurrencyRulesKey<RaiseToken>, CurrencyRules<RaiseToken>>(
            &mut account,
            registry,
            currency::currency_rules_key<RaiseToken>(),
            rules,
        );

        init_actions::init_store_object<FutarchyConfig, currency::TreasuryCapKey<RaiseToken>, TreasuryCap<RaiseToken>>(
            &mut account,
            registry,
            currency::treasury_cap_key<RaiseToken>(),
            treasury_cap,
        );
    };

    // Deposit metadata if exists (always - needed for both success and failure paths)
    if (raise.coin_metadata.is_some()) {
        let metadata: CoinMetadata<RaiseToken> = raise.coin_metadata.extract();
        // Store in Account using currency module's standard key
        init_actions::init_store_object<FutarchyConfig, CoinMetadataKey<RaiseToken>, CoinMetadata<RaiseToken>>(
            &mut account,
            registry,
            currency::coin_metadata_key<RaiseToken>(),
            metadata,
        );
    };

    // Conditional setup based on raise outcome
    if (raise_succeeded) {
        // === SUCCESS PATH ===
        // Set launchpad initial price
        assert!(raise.tokens_for_sale_amount > 0, EInvalidStateForAction);
        assert!(raise.final_raise_amount > 0, EInvalidStateForAction);

        let raise_price = math::mul_div_mixed(
            (raise.final_raise_amount as u128),
            constants::price_multiplier_scale(),
            (raise.tokens_for_sale_amount as u128),
        );

        let config = futarchy_config::internal_config_mut(&mut account, registry, version::current());
        futarchy_config::set_launchpad_initial_price(config, raise_price);

        // Inherit verification state from launchpad to DAO
        futarchy_config::set_verification_level(config, raise.verification_level);
        futarchy_config::set_admin_review_text(config, raise.admin_review_text);

        // Note: attestation_url is stored in the launchpad Raise object and can be queried from there
        // DaoState.attestation_url is used for verification request workflow, not for inherited state

        // Deposit raised funds to DAO treasury
        let raised_funds = coin::from_balance(raise.stable_coin_vault.split(raise.final_raise_amount), ctx);
        init_actions::init_vault_deposit<FutarchyConfig, StableCoin>(
            &mut account,
            registry,
            string::utf8(b"treasury"),
            raised_funds,
            ctx,
        );
    } else {
        // === FAILURE PATH ===
        // Don't set price - not applicable for failed raises
        // Don't deposit funds - they stay in raise.stable_coin_vault for contributor refunds via claim_refund()
        // Treasury cap and metadata are already deposited above so failure_specs can return them via Intent

        // Still inherit verification state
        let config = futarchy_config::internal_config_mut(&mut account, registry, version::current());
        futarchy_config::set_verification_level(config, raise.verification_level);
        futarchy_config::set_admin_review_text(config, raise.admin_review_text);
    };

    // Return unshared DAO as hot potato - PTB must execute init actions and finalize
    UnsharedDao<RaiseToken, StableCoin> {
        account,
    }
}

/// JIT Convert InitActionSpecs to Intents
/// Picks SUCCESS or FAILURE spec based on raise outcome
fun create_intents_from_specs<RaiseToken, StableCoin>(
    raise: &Raise<RaiseToken, StableCoin>,
    account: &mut Account,
    registry: &PackageRegistry,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Determine which spec to use based on raise result
    let specs_to_execute = if (raise.state == STATE_SUCCESSFUL) {
        &raise.success_specs
    } else {
        &raise.failure_specs
    };

    // Only create intent if there are actions to execute
    if (action_specs::action_count(specs_to_execute) == 0) {
        return
    };

    // Create LaunchpadOutcome for all intents
    let outcome = launchpad_outcome::new(object::id(raise));

    // Create Intent parameters (execute immediately, 30 day expiry)
    let params = intents::new_params(
        string::utf8(b"launchpad_init"),
        string::utf8(b"DAO initialization actions from launchpad raise"),
        vector[clock.timestamp_ms()],  // Execute immediately
        clock.timestamp_ms() + (30 * 24 * 60 * 60 * 1000),  // 30 days
        clock,
        ctx,
    );

    // Build intent from selected specs
    intent_interface::build_intent!(
        account,
        registry,
        params,
        outcome,
        string::utf8(b"launchpad_init"),
        version::current(),
        LaunchpadIntent {},
        ctx,
        |intent, iw| {
            // Copy all action specs to intent
            let actions = action_specs::actions(specs_to_execute);
            let mut action_idx = 0;
            while (action_idx < vector::length(actions)) {
                let action_spec = vector::borrow(actions, action_idx);
                let action_type = action_specs::action_type(action_spec);
                let action_data = action_specs::action_data(action_spec);

                // Add to intent (preserves type information!)
                intents::add_action_spec_with_typename(
                    intent,
                    action_type,
                    *action_data,  // Copy the bytes
                    copy iw  // Copy witness to avoid move in loop
                );

                action_idx = action_idx + 1;
            };
        }
    );
}

/// Intent witness for launchpad initialization intents
public struct LaunchpadIntent has copy, drop {}

/// Create a LaunchpadIntent witness (for PTB execution)
public fun launchpad_intent_witness(): LaunchpadIntent {
    LaunchpadIntent {}
}

/// Check if LaunchpadOutcome is approved for this raise
/// This is called by keepers to validate before executing intents
///
/// Note: State checking (success vs failure) happens during JIT Intent creation,
/// where the correct specs (success_specs or failure_specs) are selected.
/// This function only validates that the outcome belongs to this raise.
public fun is_outcome_approved<RaiseToken, StableCoin>(
    outcome: &launchpad_outcome::LaunchpadOutcome,
    raise: &Raise<RaiseToken, StableCoin>,
): bool {
    object::id(raise) == launchpad_outcome::raise_id(outcome)
    // State check removed - specs were already selected correctly during JIT conversion
}

/// Finalize and share the DAO after init actions complete
/// Consumes UnsharedDao hot potato, shares objects, marks raise successful
/// Also creates Intents from staged InitActionSpecs (JIT conversion)
public fun finalize_and_share_dao<RaiseToken: drop, StableCoin: drop>(
    raise: &mut Raise<RaiseToken, StableCoin>,
    unshared: UnsharedDao<RaiseToken, StableCoin>,
    registry: &PackageRegistry,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let UnsharedDao { mut account } = unshared;

    // CRITICAL: Set state BEFORE JIT conversion so it picks the right spec!
    // Determine if raise succeeded based on whether minimum was met
    let raise_succeeded = raise.final_raise_amount >= raise.min_raise_amount;
    raise.state = if (raise_succeeded) { STATE_SUCCESSFUL } else { STATE_FAILED };

    // JIT CONVERSION: Create Intents from staged InitActionSpecs
    // This happens BEFORE account is shared so we can add intents
    // Check if either success or failure specs have actions
    if (action_specs::action_count(&raise.success_specs) > 0 ||
        action_specs::action_count(&raise.failure_specs) > 0) {
        create_intents_from_specs<RaiseToken, StableCoin>(
            raise,
            &mut account,
            registry,
            clock,
            ctx,
        );
    };

    // Share DAO account
    // NOTE: Spot pool is created and shared via init actions, not here
    sui_transfer::public_share_object(account);

    // Emit appropriate event based on outcome
    if (raise_succeeded) {
        event::emit(RaiseSuccessful {
            raise_id: object::id(raise),
            total_raised: raise.final_raise_amount,
        });
    } else {
        event::emit(RaiseFailed {
            raise_id: object::id(raise),
            total_raised: raise.final_raise_amount,
            min_raise_amount: raise.min_raise_amount,
        });
    };
}

/// Public wrapper for complete_raise_unshared - for PTB init action execution
public fun begin_dao_creation<RaiseToken: drop, StableCoin: drop>(
    raise: &mut Raise<RaiseToken, StableCoin>,
    factory: &mut factory::Factory,
    registry: &PackageRegistry,
    clock: &Clock,
    ctx: &mut TxContext,
): UnsharedDao<RaiseToken, StableCoin> {
    complete_raise_unshared(raise, factory, registry, clock, ctx)
}

// === Init Action Wrappers ===
// These wrappers allow PTB execution of init actions on UnsharedDao
// by extracting the Account reference internally

/// Legacy function - backward compatibility for raises without init actions
fun complete_raise_internal<RaiseToken: drop, StableCoin: drop>(
    raise: &mut Raise<RaiseToken, StableCoin>,
    factory: &mut factory::Factory,
    registry: &PackageRegistry,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let unshared = complete_raise_unshared(raise, factory, registry, clock, ctx);
    finalize_and_share_dao(raise, unshared, registry, clock, ctx);
}

/// Claim tokens after successful raise
public entry fun claim_tokens<RaiseToken: drop, StableCoin: drop>(
    raise: &mut Raise<RaiseToken, StableCoin>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(raise.state == STATE_SUCCESSFUL, EInvalidStateForAction);

    let contributor = ctx.sender();
    let key = ContributorKey { contributor };
    assert!(df::exists_(&raise.id, key), ENotAContributor);

    let contrib: Contribution = df::remove(&mut raise.id, key);

    if (contrib.max_total_cap < raise.final_raise_amount) {
        let refund = coin::from_balance(raise.stable_coin_vault.split(contrib.amount), ctx);
        sui_transfer::public_transfer(refund, contributor);
        event::emit(RefundClaimed {
            raise_id: object::id(raise),
            contributor,
            refund_amount: contrib.amount,
        });
        return
    };

    let tokens_to_claim = math::mul_div_to_64(
        contrib.amount,
        raise.tokens_for_sale_amount,
        raise.final_raise_amount
    );

    let payment_amount = math::mul_div_to_64(
        tokens_to_claim,
        raise.final_raise_amount,
        raise.tokens_for_sale_amount
    );

    let tokens = coin::from_balance(raise.raise_token_vault.split(tokens_to_claim), ctx);
    sui_transfer::public_transfer(tokens, contributor);

    event::emit(TokensClaimed {
        raise_id: object::id(raise),
        contributor,
        contribution_amount: payment_amount,
        tokens_claimed: tokens_to_claim,
    });

    let refund_amount = contrib.amount - payment_amount;
    if (refund_amount > 0) {
        let refund = coin::from_balance(raise.stable_coin_vault.split(refund_amount), ctx);
        sui_transfer::public_transfer(refund, contributor);
        event::emit(RefundClaimed {
            raise_id: object::id(raise),
            contributor,
            refund_amount,
        });
    };
}

/// Batch claim tokens for multiple contributors (cranker earns reward per successful claim)
/// Gracefully skips already-claimed contributors instead of failing
public entry fun batch_claim_tokens_for<RaiseToken: drop, StableCoin: drop>(
    raise: &mut Raise<RaiseToken, StableCoin>,
    factory: &factory::Factory,
    contributors: vector<address>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let cranker_reward = factory::launchpad_cranker_reward(factory);
    assert!(raise.state == STATE_SUCCESSFUL, EInvalidStateForAction);

    let batch_size = vector::length(&contributors);
    assert!(batch_size > 0, EEmptyBatch);
    assert!(batch_size <= MAX_BATCH_SIZE, EBatchSizeTooLarge);

    let mut i = 0;
    let mut successful_claims = 0u64;
    // Accumulate crank rewards to send as one coin at the end
    let mut total_crank_reward = coin::zero<sui::sui::SUI>(ctx);

    while (i < batch_size) {
        let contributor = *vector::borrow(&contributors, i);
        let key = ContributorKey { contributor };

        // Skip if already claimed (graceful degradation)
        if (!df::exists_(&raise.id, key)) {
            i = i + 1;
            continue
        };

        let contrib: Contribution = df::remove(&mut raise.id, key);

        // Handle refund case (low price cap)
        if (contrib.max_total_cap < raise.final_raise_amount) {
            let refund = coin::from_balance(raise.stable_coin_vault.split(contrib.amount), ctx);
            sui_transfer::public_transfer(refund, contributor);

            // Accumulate cranker reward
            if (raise.crank_fee_vault.value() >= cranker_reward) {
                let reward = coin::from_balance(
                    raise.crank_fee_vault.split(cranker_reward),
                    ctx
                );
                total_crank_reward.join(reward);
                successful_claims = successful_claims + 1;
            };

            event::emit(RefundClaimed {
                raise_id: object::id(raise),
                contributor,
                refund_amount: contrib.amount,
            });

            i = i + 1;
            continue
        };

        // Normal token claim
        let tokens_to_claim = math::mul_div_to_64(
            contrib.amount,
            raise.tokens_for_sale_amount,
            raise.final_raise_amount
        );

        let payment_amount = math::mul_div_to_64(
            tokens_to_claim,
            raise.final_raise_amount,
            raise.tokens_for_sale_amount
        );

        let tokens = coin::from_balance(raise.raise_token_vault.split(tokens_to_claim), ctx);
        sui_transfer::public_transfer(tokens, contributor);

        // Accumulate cranker reward
        if (raise.crank_fee_vault.value() >= cranker_reward) {
            let reward = coin::from_balance(
                raise.crank_fee_vault.split(cranker_reward),
                ctx
            );
            total_crank_reward.join(reward);
            successful_claims = successful_claims + 1;
        };

        event::emit(TokensClaimed {
            raise_id: object::id(raise),
            contributor,
            contribution_amount: payment_amount,
            tokens_claimed: tokens_to_claim,
        });

        // Handle stable refund
        let refund_amount = contrib.amount - payment_amount;
        if (refund_amount > 0) {
            let refund = coin::from_balance(raise.stable_coin_vault.split(refund_amount), ctx);
            sui_transfer::public_transfer(refund, contributor);
            event::emit(RefundClaimed {
                raise_id: object::id(raise),
                contributor,
                refund_amount,
            });
        };

        i = i + 1;
    };

    // Send accumulated crank rewards to cranker
    if (total_crank_reward.value() > 0) {
        sui_transfer::public_transfer(total_crank_reward, ctx.sender());
    } else {
        total_crank_reward.destroy_zero();
    };

    // Emit batch completion event
    event::emit(BatchClaimCompleted {
        raise_id: object::id(raise),
        cranker: ctx.sender(),
        attempted: batch_size,
        successful: successful_claims,
        total_reward: successful_claims * cranker_reward,
    });
}

/// Claim refund for failed raise
public entry fun claim_refund<RaiseToken: drop, StableCoin: drop>(
    raise: &mut Raise<RaiseToken, StableCoin>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(clock.timestamp_ms() >= raise.deadline_ms, EDeadlineNotReached);

    // Check if raise failed
    if (raise.settlement_done) {
        assert!(raise.final_raise_amount < raise.min_raise_amount, EMinRaiseAlreadyMet);
    } else {
        assert!(raise.stable_coin_vault.value() < raise.min_raise_amount, EMinRaiseAlreadyMet);
    };

    if (raise.state == STATE_FUNDING) {
        raise.state = STATE_FAILED;
        event::emit(RaiseFailed {
            raise_id: object::id(raise),
            total_raised: raise.stable_coin_vault.value(),
            min_raise_amount: raise.min_raise_amount,
        });
    };

    assert!(raise.state == STATE_FAILED, EInvalidStateForAction);

    let contributor = ctx.sender();
    let key = ContributorKey { contributor };
    assert!(df::exists_(&raise.id, key), ENotAContributor);

    let contrib: Contribution = df::remove(&mut raise.id, key);

    let refund = coin::from_balance(raise.stable_coin_vault.split(contrib.amount), ctx);
    sui_transfer::public_transfer(refund, contributor);

    event::emit(RefundClaimed {
        raise_id: object::id(raise),
        contributor,
        refund_amount: contrib.amount,
    });
}

/// Batch claim refunds for failed raise (cranker earns reward per successful claim)
/// Gracefully skips already-claimed contributors instead of failing
public entry fun batch_claim_refund_for<RaiseToken: drop, StableCoin: drop>(
    raise: &mut Raise<RaiseToken, StableCoin>,
    factory: &factory::Factory,
    contributors: vector<address>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let cranker_reward = factory::launchpad_cranker_reward(factory);
    assert!(clock.timestamp_ms() >= raise.deadline_ms, EDeadlineNotReached);

    // Check if raise failed
    if (raise.settlement_done) {
        assert!(raise.final_raise_amount < raise.min_raise_amount, EMinRaiseAlreadyMet);
    } else {
        assert!(raise.stable_coin_vault.value() < raise.min_raise_amount, EMinRaiseAlreadyMet);
    };

    if (raise.state == STATE_FUNDING) {
        raise.state = STATE_FAILED;
        event::emit(RaiseFailed {
            raise_id: object::id(raise),
            total_raised: raise.stable_coin_vault.value(),
            min_raise_amount: raise.min_raise_amount,
        });
    };

    assert!(raise.state == STATE_FAILED, EInvalidStateForAction);

    let batch_size = vector::length(&contributors);
    assert!(batch_size > 0, EEmptyBatch);
    assert!(batch_size <= MAX_BATCH_SIZE, EBatchSizeTooLarge);

    let mut i = 0;
    let mut successful_claims = 0u64;

    while (i < batch_size) {
        let contributor = *vector::borrow(&contributors, i);
        let key = ContributorKey { contributor };

        // Skip if already claimed
        if (!df::exists_(&raise.id, key)) {
            i = i + 1;
            continue
        };

        let contrib: Contribution = df::remove(&mut raise.id, key);

        let refund = coin::from_balance(raise.stable_coin_vault.split(contrib.amount), ctx);
        sui_transfer::public_transfer(refund, contributor);

        // Pay cranker
        if (raise.crank_fee_vault.value() >= cranker_reward) {
            let reward = coin::from_balance(
                raise.crank_fee_vault.split(cranker_reward),
                ctx
            );
            sui_transfer::public_transfer(reward, ctx.sender());
            successful_claims = successful_claims + 1;
        };

        event::emit(RefundClaimed {
            raise_id: object::id(raise),
            contributor,
            refund_amount: contrib.amount,
        });

        i = i + 1;
    };

    event::emit(BatchClaimCompleted {
        raise_id: object::id(raise),
        cranker: ctx.sender(),
        attempted: batch_size,
        successful: successful_claims,
        total_reward: successful_claims * cranker_reward,
    });
}

/// Cleanup resources for a failed raise
public entry fun cleanup_failed_raise<RaiseToken: drop, StableCoin: drop>(
    raise: &mut Raise<RaiseToken, StableCoin>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(clock.timestamp_ms() >= raise.deadline_ms, EDeadlineNotReached);

    if (raise.settlement_done) {
        assert!(raise.final_raise_amount < raise.min_raise_amount, EMinRaiseAlreadyMet);
    } else {
        assert!(raise.stable_coin_vault.value() < raise.min_raise_amount, EMinRaiseAlreadyMet);
    };

    if (raise.state != STATE_FAILED) {
        raise.state = STATE_FAILED;
    };

    // Return treasury cap to creator
    if (raise.treasury_cap.is_some()) {
        let mut cap = raise.treasury_cap.extract();
        let bal = raise.raise_token_vault.value();
        if (bal > 0) {
            let tokens_to_burn = coin::from_balance(raise.raise_token_vault.split(bal), ctx);
            coin::burn(&mut cap, tokens_to_burn);
        };
        sui_transfer::public_transfer(cap, raise.creator);

        event::emit(TreasuryCapReturned {
            raise_id: object::id(raise),
            tokens_burned: bal,
            recipient: raise.creator,
            timestamp: clock.timestamp_ms(),
        });
    };

    // Clean up staged init specs (both success and failure specs)
    // NOTE: No pre-created DAO to clean up anymore - DAO is only created in complete_raise
    raise.success_specs = action_specs::new_init_specs();
    raise.failure_specs = action_specs::new_init_specs();

    // Get DAO ID for event before clearing
    let dao_id = if (raise.dao_id.is_some()) {
        *raise.dao_id.borrow()
    } else {
        object::id_from_address(@0x0)
    };

    // Clear DAO ID if set
    if (raise.dao_id.is_some()) {
        raise.dao_id = option::none();
    };

    event::emit(FailedRaiseCleanup {
        raise_id: object::id(raise),
        dao_id,
        timestamp: clock.timestamp_ms(),
    });

    if (df::exists_(&raise.id, RaiseCoinMetadataKey {})) {
        let metadata: CoinMetadata<RaiseToken> = df::remove(&mut raise.id, RaiseCoinMetadataKey {});
        sui_transfer::public_transfer(metadata, raise.creator);
    };
}

/// Sweep remaining dust after claim period
public entry fun sweep_dust<RaiseToken: drop, StableCoin: drop>(
    raise: &mut Raise<RaiseToken, StableCoin>,
    creator_cap: &CreatorCap,
    dao_account: &mut Account,
    registry: &PackageRegistry,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(raise.state == STATE_SUCCESSFUL, EInvalidStateForAction);
    assert!(creator_cap.raise_id == object::id(raise), EInvalidCreatorCap);
    assert!(raise.dao_id.is_some(), EDaoNotPreCreated);
    assert!(object::id(dao_account) == *raise.dao_id.borrow(), EInvalidStateForAction);

    assert!(
        clock.timestamp_ms() >= raise.deadline_ms + constants::launchpad_claim_period_ms(),
        EDeadlineNotReached,
    );

    let remaining_token_balance = raise.raise_token_vault.value();
    if (remaining_token_balance > 0) {
        let dust_tokens = coin::from_balance(raise.raise_token_vault.split(remaining_token_balance), ctx);
        sui_transfer::public_transfer(dust_tokens, raise.creator);
    };

    let remaining_stable_balance = raise.stable_coin_vault.value();
    if (remaining_stable_balance > 0) {
        let dust_stable = coin::from_balance(raise.stable_coin_vault.split(remaining_stable_balance), ctx);
        init_actions::init_vault_deposit<FutarchyConfig, StableCoin>(
            dao_account,
            registry,
            string::utf8(b"treasury"),
            dust_stable,
            ctx,
        );
    };

    event::emit(DustSwept {
        raise_id: object::id(raise),
        token_dust_amount: remaining_token_balance,
        stable_dust_amount: remaining_stable_balance,
        token_recipient: raise.creator,
        stable_recipient: object::id(dao_account),
        timestamp: clock.timestamp_ms(),
    });
}

/// Sweep remaining protocol fees after raise is settled (SUCCESS or FAILED)
/// Can be called by factory admin after all claims are processed
/// Difference between bid fee (0.1 SUI) and cranker rewards (0.05 SUI per claim) goes to protocol
public entry fun sweep_protocol_fees<RaiseToken, StableCoin>(
    raise: &mut Raise<RaiseToken, StableCoin>,
    _owner_cap: &factory::FactoryOwnerCap,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Only holder of FactoryOwnerCap can call this (verified by Sui runtime)

    // Can only sweep after raise is settled (either SUCCESS or FAILED)
    assert!(
        raise.state == STATE_SUCCESSFUL || raise.state == STATE_FAILED,
        EInvalidStateForAction
    );

    // Must have some fees to sweep
    let remaining_fees = raise.crank_fee_vault.value();
    assert!(remaining_fees > 0, ENoProtocolFeesToSweep);

    // Extract all remaining fees
    let protocol_fees = coin::from_balance(
        raise.crank_fee_vault.split(remaining_fees),
        ctx
    );

    // Send to factory admin
    sui_transfer::public_transfer(protocol_fees, ctx.sender());

    event::emit(ProtocolFeesSwept {
        raise_id: object::id(raise),
        amount: remaining_fees,
        recipient: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

fun init_raise<RaiseToken: drop, StableCoin: drop>(
    mut treasury_cap: TreasuryCap<RaiseToken>,
    coin_metadata: CoinMetadata<RaiseToken>,
    affiliate_id: String,
    tokens_for_sale: u64,
    min_raise_amount: u64,
    max_raise_amount: Option<u64>,
    allowed_caps: vector<u64>,
    start_delay_ms: Option<u64>,
    allow_early_completion: bool,
    description: String,
    metadata_keys: vector<String>,
    metadata_values: vector<String>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Validate coin set (supply must be zero, types must match)
    futarchy_one_shot_utils::coin_registry::validate_coin_set(&treasury_cap, &coin_metadata);

    let minted_tokens = coin::mint(&mut treasury_cap, tokens_for_sale, ctx);

    // Calculate start_time: creation_time + delay (if delay provided, otherwise start immediately)
    let current_time = clock.timestamp_ms();
    let start_time = if (option::is_some(&start_delay_ms)) {
        current_time + *option::borrow(&start_delay_ms)
    } else {
        current_time
    };

    // Deadline is start_time + duration
    let deadline = start_time + constants::launchpad_duration_ms();

    let mut raise = Raise<RaiseToken, StableCoin> {
        id: object::new(ctx),
        account_id: option::none(),  // Set when DAO account is created
        creator: ctx.sender(),
        affiliate_id,
        state: STATE_FUNDING,
        min_raise_amount,
        max_raise_amount,
        start_time_ms: start_time,
        deadline_ms: deadline,
        allow_early_completion,
        raise_token_vault: minted_tokens.into_balance(),
        tokens_for_sale_amount: tokens_for_sale,
        stable_coin_vault: balance::zero(),
        description,
        success_specs: action_specs::new_init_specs(),
        failure_specs: action_specs::new_init_specs(),
        treasury_cap: option::some(treasury_cap),
        coin_metadata: option::some(coin_metadata),
        allowed_caps,
        cap_sums: vector::empty(),
        settlement_done: false,
        final_raise_amount: 0,
        dao_id: option::none(),
        intents_locked: false,
        verification_level: 0,
        attestation_url: string::utf8(b""),
        admin_review_text: string::utf8(b""),
        crank_fee_vault: balance::zero(),
    };

    let cap_count = vector::length(&raise.allowed_caps);
    let mut i = 0;
    while (i < cap_count) {
        vector::push_back(&mut raise.cap_sums, 0);
        i = i + 1;
    };

    let raise_id = object::id(&raise);

    event::emit(RaiseCreated {
        raise_id,
        creator: raise.creator,
        affiliate_id: raise.affiliate_id,
        raise_token_type: string::from_ascii(type_name::with_defining_ids<RaiseToken>().into_string()),
        stable_coin_type: string::from_ascii(type_name::with_defining_ids<StableCoin>().into_string()),
        min_raise_amount,
        tokens_for_sale,
        start_time_ms: raise.start_time_ms,
        deadline_ms: raise.deadline_ms,
        description: raise.description,
        metadata_keys,
        metadata_values,
    });

    let creator_cap = CreatorCap {
        id: object::new(ctx),
        raise_id,
    };
    sui_transfer::public_transfer(creator_cap, raise.creator);

    sui_transfer::public_share_object(raise);
}

// === Helper Functions ===

fun is_sorted_ascending(v: &vector<u64>): bool {
    let len = vector::length(v);
    if (len <= 1) return true;

    let mut i = 0;
    while (i < len - 1) {
        if (*vector::borrow(v, i) >= *vector::borrow(v, i + 1)) {
            return false
        };
        i = i + 1;
    };
    true
}

fun is_cap_allowed(cap: u64, allowed_caps: &vector<u64>): bool {
    let len = vector::length(allowed_caps);
    let mut left = 0;
    let mut right = len;

    while (left < right) {
        let mid = left + (right - left) / 2;
        let mid_val = *vector::borrow(allowed_caps, mid);

        if (mid_val == cap) {
            return true
        } else if (mid_val < cap) {
            left = mid + 1;
        } else {
            right = mid;
        };
    };
    false
}

// === View Functions ===

public fun total_raised<RT, SC>(r: &Raise<RT, SC>): u64 {
    r.stable_coin_vault.value()
}

public fun state<RT, SC>(r: &Raise<RT, SC>): u8 { r.state }

public fun start_time<RT, SC>(r: &Raise<RT, SC>): u64 { r.start_time_ms }

public fun deadline<RT, SC>(r: &Raise<RT, SC>): u64 { r.deadline_ms }

public fun description<RT, SC>(r: &Raise<RT, SC>): &String { &r.description }

public fun contribution_of<RT, SC>(r: &Raise<RT, SC>, addr: address): u64 {
    let key = ContributorKey { contributor: addr };
    if (df::exists_(&r.id, key)) {
        let contrib: &Contribution = df::borrow(&r.id, key);
        contrib.amount
    } else {
        0
    }
}

public fun settlement_done<RT, SC>(r: &Raise<RT, SC>): bool { r.settlement_done }

public fun final_raise_amount<RT, SC>(r: &Raise<RT, SC>): u64 { r.final_raise_amount }

public fun allowed_caps<RT, SC>(r: &Raise<RT, SC>): &vector<u64> { &r.allowed_caps }

public fun cap_sums<RT, SC>(r: &Raise<RT, SC>): &vector<u64> { &r.cap_sums }

public fun verification_level<RT, SC>(r: &Raise<RT, SC>): u8 {
    r.verification_level
}

public fun attestation_url<RT, SC>(r: &Raise<RT, SC>): &String {
    &r.attestation_url
}

public fun admin_review_text<RT, SC>(r: &Raise<RT, SC>): &String {
    &r.admin_review_text
}

// === Admin Functions ===

public fun set_launchpad_verification<RT, SC>(
    raise: &mut Raise<RT, SC>,
    _validator_cap: &factory::ValidatorAdminCap,
    level: u8,
    attestation_url: String,
    review_text: String,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    raise.verification_level = level;
    raise.attestation_url = attestation_url;
    raise.admin_review_text = review_text;

    event::emit(LaunchpadVerificationSet {
        raise_id: object::id(raise),
        level,
        attestation_url,
        admin_review_text: review_text,
        validator: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// === Test Functions ===

#[test_only]
/// Test version of complete_raise that doesn't share objects (which fails in test environment)
/// Instead, it transfers them to the sender for testing
public fun complete_raise_test<RaiseToken: drop, StableCoin: drop>(
    raise: &mut Raise<RaiseToken, StableCoin>,
    creator_cap: &CreatorCap,
    final_raise_amount: u64,
    registry: &PackageRegistry,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(creator_cap.raise_id == object::id(raise), EInvalidCreatorCap);
    assert!(raise.state == STATE_FUNDING, EInvalidStateForAction);
    assert!(clock.timestamp_ms() >= raise.deadline_ms, EDeadlineNotReached);
    assert!(raise.settlement_done, EInvalidStateForAction);
    assert!(raise.dao_id.is_some(), EDaoNotPreCreated);

    // Validate final_raise_amount
    let total_raised = raise.stable_coin_vault.value();
    assert!(final_raise_amount >= raise.min_raise_amount, EMinRaiseNotMet);
    assert!(final_raise_amount <= total_raised, EInvalidStateForAction);
    if (option::is_some(&raise.max_raise_amount)) {
        let max = *option::borrow(&raise.max_raise_amount);
        assert!(final_raise_amount <= max, EInvalidStateForAction);
    };

    // Override the settlement's final_raise_amount with creator's choice
    raise.final_raise_amount = final_raise_amount;

    // No DAO creation fee - launchpad already collected it

    let final_total = raise.final_raise_amount;
    assert!(final_total >= raise.min_raise_amount, EMinRaiseNotMet);
    assert!(final_total > 0, EMinRaiseNotMet);

    let mut account: Account = df::remove(&mut raise.id, DaoAccountKey {});
    let mut spot_pool: UnifiedSpotPool<RaiseToken, StableCoin> = df::remove(&mut raise.id, DaoPoolKey {});

    // Deposit treasury cap
    let treasury_cap = raise.treasury_cap.extract();
    init_actions::init_lock_treasury_cap<FutarchyConfig, RaiseToken>(&mut account, registry, treasury_cap);

    // Deposit metadata if exists
    if (df::exists_(&raise.id, RaiseCoinMetadataKey {})) {
        let metadata: CoinMetadata<RaiseToken> = df::remove(&mut raise.id, RaiseCoinMetadataKey {});
        // Store in Account using currency module's standard key
        init_actions::init_store_object<FutarchyConfig, CoinMetadataKey<RaiseToken>, CoinMetadata<RaiseToken>>(
            &mut account,
            registry,
            currency::coin_metadata_key<RaiseToken>(),
            metadata,
        );
    };

    // Set launchpad initial price
    assert!(raise.tokens_for_sale_amount > 0, EInvalidStateForAction);
    assert!(raise.final_raise_amount > 0, EInvalidStateForAction);

    let raise_price = math::mul_div_mixed(
        (raise.final_raise_amount as u128),
        constants::price_multiplier_scale(),
        (raise.tokens_for_sale_amount as u128),
    );

    let config = futarchy_config::internal_config_mut(&mut account, registry, version::current());
    futarchy_config::set_launchpad_initial_price(config, raise_price);

    // Inherit verification state from launchpad to DAO
    futarchy_config::set_verification_level(config, raise.verification_level);
    futarchy_config::set_admin_review_text(config, raise.admin_review_text);

    // Note: attestation_url is stored in the launchpad Raise object and can be queried from there
    // DaoState.attestation_url is used for verification request workflow, not for inherited state

    // Deposit raised funds to DAO treasury
    let raised_funds = coin::from_balance(raise.stable_coin_vault.split(raise.final_raise_amount), ctx);
    init_actions::init_vault_deposit<FutarchyConfig, StableCoin>(
        &mut account,
        registry,
        string::utf8(b"treasury"),
        raised_funds,
        ctx,
    );

    raise.state = STATE_SUCCESSFUL;

    // In test environment, transfer objects to sender instead of sharing
    // This avoids the test framework limitation with share_object
    sui_transfer::public_transfer(account, ctx.sender());
    sui_transfer::public_transfer(spot_pool, ctx.sender());

    event::emit(RaiseSuccessful {
        raise_id: object::id(raise),
        total_raised: raise.final_raise_amount,
    });
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Handles the complete lifecycle of proposals from queue activation to intent execution
module futarchy_governance::proposal_lifecycle;

use account_actions::vault;
use account_protocol::account::{Self, Account};
use account_protocol::executable::{Self, Executable};
use account_protocol::intents::{Self, Intent};
use account_protocol::package_registry::{Self, PackageRegistry};
use futarchy_core::futarchy_config::{Self, FutarchyConfig, FutarchyOutcome};
use futarchy_core::version;
use futarchy_governance_actions::governance_intents;
use futarchy_markets_primitives::coin_escrow;
use futarchy_markets_primitives::conditional_amm;
use futarchy_markets_primitives::market_state::{Self, MarketState};
use futarchy_markets_core::proposal::{Self, Proposal};
use futarchy_markets_core::quantum_lp_manager;
use futarchy_markets_core::unified_spot_pool::{Self, UnifiedSpotPool};
use futarchy_one_shot_utils::strategy;
use account_actions::init_action_specs::InitActionSpecs;
use futarchy_types::signed::{Self as signed};
use std::option;
use std::string::String;
use std::type_name;
use std::vector;
use sui::balance::{Self, Balance};
use sui::clock::{Self, Clock};
use sui::coin::{Self, Coin};
use sui::event;
use sui::object;

// === Errors ===
const EProposalNotActive: u64 = 1;
const EMarketNotFinalized: u64 = 2;
const EProposalNotApproved: u64 = 3;
const ENoIntentKey: u64 = 4;
const EInvalidWinningOutcome: u64 = 5;
const EIntentExpiryTooLong: u64 = 6;
const EProposalCreationBlocked: u64 = 7; // Pool launch fee decay in progress

// === Constants ===
const OUTCOME_ACCEPTED: u64 = 0;
const OUTCOME_REJECTED: u64 = 1;

// === Events ===

/// Emitted when a proposal is activated from the queue
public struct ProposalActivated has copy, drop {
    proposal_id: ID,
    dao_id: ID,
    has_intent_spec: bool,
    timestamp: u64,
}

/// Emitted when a proposal's market is finalized
public struct ProposalMarketFinalized has copy, drop {
    proposal_id: ID,
    dao_id: ID,
    winning_outcome: u64,
    approved: bool,
    timestamp: u64,
}

/// Emitted when a proposal's intent is executed
public struct ProposalIntentExecuted has copy, drop {
    proposal_id: ID,
    dao_id: ID,
    intent_key: String,
    timestamp: u64,
}

/// Create a ProposalIntentExecuted event
public(package) fun new_proposal_intent_executed(
    proposal_id: ID,
    dao_id: ID,
    intent_key: String,
    timestamp: u64,
): ProposalIntentExecuted {
    ProposalIntentExecuted {
        proposal_id,
        dao_id,
        intent_key,
        timestamp,
    }
}

/// Emitted when the next proposal is reserved (locked) into PREMARKET
public struct ProposalReserved has copy, drop {
    queued_proposal_id: ID,
    premarket_proposal_id: ID,
    dao_id: ID,
    timestamp: u64,
}

// === Public Functions ===

/// Finalizes a proposal's market and determines the winning outcome
/// This should be called after trading has ended and TWAP prices are calculated
public fun finalize_proposal_market<AssetType, StableType>(
    account: &mut Account,
    registry: &package_registry::PackageRegistry,
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut futarchy_markets_primitives::coin_escrow::TokenEscrow<AssetType, StableType>,
    market_state: &mut MarketState,
    spot_pool: &mut UnifiedSpotPool<AssetType, StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    finalize_proposal_market_internal(
        account,
        registry,
        proposal,
        escrow,
        market_state,
        spot_pool,
        false,
        clock,
        ctx,
    );
}

/// Internal implementation shared by both finalization functions
fun finalize_proposal_market_internal<AssetType, StableType>(
    account: &mut Account,
    registry: &PackageRegistry,
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut futarchy_markets_primitives::coin_escrow::TokenEscrow<AssetType, StableType>,
    market_state: &mut MarketState,
    spot_pool: &mut UnifiedSpotPool<AssetType, StableType>,
    _is_early_resolution: bool,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Calculate winning outcome and get TWAPs in single computation
    let (winning_outcome, twap_prices) = calculate_winning_outcome_with_twaps(
        proposal,
        escrow,
        clock,
    );

    // Store the final TWAPs for third-party access
    proposal::set_twap_prices(proposal, twap_prices);

    // Set the winning outcome on the proposal
    proposal::set_winning_outcome(proposal, winning_outcome);

    // Finalize the market state
    market_state::finalize(market_state, winning_outcome, clock);

    // Return quantum-split liquidity back to the spot pool
    quantum_lp_manager::auto_redeem_on_proposal_end(
        winning_outcome,
        spot_pool,
        escrow,
        market_state,
        clock,
        ctx,
    );

    // CRITICAL FIX (Issue 3): Extract and clear escrow ID from spot pool
    // This clears the active escrow flag so has_active_escrow() returns false
    let _escrow_id = unified_spot_pool::extract_active_escrow(spot_pool);

    // Spot TWAP continues running throughout proposal (no backfill needed)
    // Auto-arbitrage keeps spot and conditional prices synced

    // Crank: Transition TRANSITIONING bucket to WITHDRAW_ONLY
    // This allows LPs who marked for withdrawal to claim their coins
    futarchy_markets_operations::liquidity_interact::crank_recombine_and_transition<
        AssetType,
        StableType,
    >(spot_pool);

    // NEW: Cancel losing outcome intents in the hot path using a scoped witness.
    // This ensures per-proposal isolation and prevents cross-proposal cancellation
    let num_outcomes = proposal::get_num_outcomes(proposal);
    let mut i = 0u64;
    while (i < num_outcomes) {
        if (i != winning_outcome) {
            // Mint a scoped cancel witness for this specific proposal/outcome
            let mut cw_opt = proposal::make_cancel_witness(proposal, i);
            if (option::is_some(&cw_opt)) {
                let _cw = option::extract(&mut cw_opt);
                // No additional work required: make_cancel_witness removes the spec
                // and resets the action count for this outcome in the new InitActionSpecs model.
            };
            // Properly destroy the empty option
            option::destroy_none(cw_opt);
        };
        i = i + 1;
    };

    // --- BEGIN OUTCOME CREATOR FEE REFUNDS & REWARDS ---
    // Economic model per user requirement:
    // - Outcome 0 wins: DAO keeps all fees (reject/no action taken)
    // - Outcomes 1-N win:
    //   1. Refund ALL creators of outcomes 1-N (collaborative model)
    //   2. Pay bonus reward to winning outcome creator (configurable)
    //
    // Game Theory Rationale:
    // - Eliminates fee-stealing attacks (both proposer and mutator get refunded)
    // - No incentive to hedge by creating trivial mutations
    // - Makes mutations collaborative rather than adversarial
    // - Original proposer always protected if any action is taken
    // - Encourages healthy debate without perverse incentives
    // - Winning creator gets bonus to incentivize quality
    if (winning_outcome > 0) {
        let config: &FutarchyConfig = account::config(account);
        let num_outcomes = proposal::get_num_outcomes(proposal);

        // 1. Refund fees to ALL creators of outcomes 1-N from proposal's fee escrow
        // SECURITY: Use per-proposal escrow instead of global protocol revenue
        // This ensures each proposal's fees are properly tracked and refunded
        //
        // NOTE: Outcomes structure:
        // - Outcome 0: "Reject"/"No" - typically the proposal creator (no refund if this wins)
        // - Outcomes 1+: "Accept"/"Yes" variants - initially proposal creator, may be mutated
        //
        // Refund logic: Loop through outcomes 1-N (NOT outcome 0)
        // - If ANY action outcome wins (1+), ALL outcome creators get their fees back
        // - This includes the original proposal creator (who created outcome 1 initially)
        // - So proposal creator gets refunded if any action is taken, even if their specific outcome loses
        let fee_escrow_balance = proposal::take_fee_escrow(proposal);
        let mut fee_escrow_coin = coin::from_balance(fee_escrow_balance, ctx);

        let mut i = 1u64; // Start at 1: skip outcome 0 (reject/no action)
        while (i < num_outcomes) {
            let creator_fee = proposal::get_outcome_creator_fee(proposal, i);
            if (creator_fee > 0 && fee_escrow_coin.value() >= creator_fee) {
                let creator = proposal::get_outcome_creator(proposal, i);
                let refund_coin = coin::split(&mut fee_escrow_coin, creator_fee, ctx);
                // Transfer refund to outcome creator
                transfer::public_transfer(refund_coin, creator);
            };
            i = i + 1;
        };

        // Any remaining escrow gets destroyed (no refund for outcome 0 creator/proposer if outcome 0 wins)
        // Note: In StableType, not SUI, so cannot deposit to SUI-denominated protocol revenue
        if (fee_escrow_coin.value() > 0) {
            transfer::public_transfer(fee_escrow_coin, @0x0); // Burn by sending to null address
        } else {
            fee_escrow_coin.destroy_zero();
        };

        // 2. Pay bonus reward to WINNING outcome creator (if configured)
        // Note: Reward is paid in StableType from DAO's "stable" vault
        // DAOs can set this to 0 to disable, or any amount to incentivize quality outcomes
        //
        // IMPORTANT: Skip reward if ANY of these conditions are true:
        // - Proposal used admin quota (got free/discounted proposal creation)
        // - Proposal was EXPLICITLY sponsored (team member called sponsor function)
        //
        // Distinction between sponsorship and DAO policy:
        // ‚úÖ DAO default threshold = 0% ‚Üí NOT sponsored ‚Üí Winner GETS reward
        //    (This is just DAO policy, not subsidizing a specific proposal)
        // ‚ùå Team calls sponsor_proposal() ‚Üí IS sponsored ‚Üí Winner NO reward
        //    (This is explicit subsidy via threshold adjustment for a specific proposal)
        //
        // Rationale: Rewards incentivize quality external proposals.
        // If proposal already received DAO support (free fees OR easier pass criteria via sponsorship),
        // paying additional rewards would be double-dipping from DAO treasury.
        let win_reward = futarchy_config::outcome_win_reward(config);
        let used_quota = proposal::get_used_quota(proposal);
        let was_sponsored = proposal::is_sponsored(proposal); // Only true if sponsor_proposal*() was called

        if (win_reward > 0 && !used_quota && !was_sponsored) {
            let winner = proposal::get_outcome_creator(proposal, winning_outcome);

            // Access DAO's "stable" vault to check balance and withdraw reward
            let vault_name = b"stable".to_string();
            let dao_address = account.addr();

            // Check if vault exists
            if (vault::has_vault(account, vault_name)) {
                // First check balance (read-only)
                let dao_vault = vault::borrow_vault(account, registry, vault_name);

                // Check if the vault has StableType balance
                if (vault::coin_type_exists<StableType>(dao_vault)) {
                    let available_balance = vault::coin_type_value<StableType>(dao_vault);

                    // Only pay if vault has funds - take minimum of reward and available balance
                    if (available_balance > 0) {
                        let actual_reward_amount = if (available_balance >= win_reward) {
                            win_reward
                        } else {
                            available_balance
                        };

                        // Withdraw from vault using permissionless withdrawal
                        // (same pattern used for dissolution - no Auth required)
                        let reward_coin = vault::withdraw_permissionless<FutarchyConfig, StableType>(
                            account,
                            registry,
                            dao_address,
                            vault_name,
                            actual_reward_amount,
                            ctx,
                        );

                        transfer::public_transfer(reward_coin, winner);
                    };
                };
            };
        };
    };
    // If outcome 0 wins, DAO keeps all fees - no refunds or rewards
    // --- END OUTCOME CREATOR FEE REFUNDS & REWARDS ---

    // Emit finalization event
    event::emit(ProposalMarketFinalized {
        proposal_id: proposal::get_id(proposal),
        dao_id: proposal::get_dao_id(proposal),
        winning_outcome,
        approved: winning_outcome == OUTCOME_ACCEPTED,
        timestamp: clock.timestamp_ms(),
    });
}


// === Proposal State Transitions with Quantum Split ===

/// Advances proposal state and handles quantum liquidity operations
/// Call this periodically to transition proposals through their lifecycle
///
/// CRITICAL: Respects withdraw_only_mode flag to prevent auto-reinvestment
/// If previous proposal has withdraw_only_mode=true, its liquidity will NOT be quantum-split
public entry fun advance_proposal_state<AssetType, StableType>(
    account: &mut Account,
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut futarchy_markets_primitives::coin_escrow::TokenEscrow<AssetType, StableType>,
    spot_pool: &mut UnifiedSpotPool<AssetType, StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
): bool {
    // Try to advance the proposal state
    let state_changed = proposal::advance_state(proposal, escrow, clock, ctx);

    // If state just changed to TRADING, store escrow and perform quantum split
    if (state_changed && proposal::is_live(proposal)) {
        // CRITICAL: Store escrow ID in spot pool FIRST (before quantum split)
        // This enables has_active_escrow() to return true, which routes LPs to TRANSITIONING bucket
        // All futarchy pools have full features (TWAP, escrow tracking, etc.)
        let escrow_id = object::id(escrow);
        unified_spot_pool::store_active_escrow(spot_pool, escrow_id);

        // CRITICAL: Check withdraw_only_mode flag before quantum split
        // If liquidity provider wants to withdraw after this proposal ends,
        // we should NOT quantum-split their liquidity for trading
        if (!proposal::is_withdraw_only(proposal)) {
            // Get conditional liquidity ratio from DAO config
            let config = account::config(account);
            let conditional_liquidity_ratio_percent = futarchy_config::conditional_liquidity_ratio_percent(
                config,
            );

            // CRITICAL: Mark liquidity as moving to proposal in spot pool's aggregator config
            // This stores the conditional_liquidity_ratio_percent for oracle logic
            unified_spot_pool::mark_liquidity_to_proposal(
                spot_pool,
                conditional_liquidity_ratio_percent,
                clock,
            );

            // Perform quantum split: move liquidity from spot to conditional markets
            quantum_lp_manager::auto_quantum_split_on_proposal_start(
                spot_pool,
                escrow,
                conditional_liquidity_ratio_percent,
                clock,
                ctx,
            );
        };
        // If withdraw_only_mode = true, skip quantum split but still track escrow
        // Liquidity will be returned to provider when proposal finalizes
    };

    state_changed
}

/// Entry function to finalize a proposal with quantum liquidity recombination
/// This is THE proper way to finalize proposals that use DAO spot pool liquidity
/// Determines winner via TWAP and returns quantum-split liquidity back to spot pool
public entry fun finalize_proposal_with_spot_pool<AssetType, StableType>(
    account: &mut Account,
    registry: &PackageRegistry,
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut futarchy_markets_primitives::coin_escrow::TokenEscrow<AssetType, StableType>,
    spot_pool: &mut UnifiedSpotPool<AssetType, StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Calculate winning outcome and get TWAPs in single computation
    let (winning_outcome, twap_prices) = calculate_winning_outcome_with_twaps(
        proposal,
        escrow,
        clock,
    );

    // Store the final TWAPs for third-party access
    proposal::set_twap_prices(proposal, twap_prices);

    // Set the winning outcome on the proposal
    proposal::set_winning_outcome(proposal, winning_outcome);

    // Get mutable reference to market_state from escrow and finalize it
    {
        let market_state = coin_escrow::get_market_state_mut(escrow);
        market_state::end_trading(market_state, clock); // Must end trading before finalizing
        market_state::finalize(market_state, winning_outcome, clock);
    }; // Borrow ends here

    // Return quantum-split liquidity back to the spot pool
    // This function extracts market_state from escrow internally to avoid borrow conflicts
    futarchy_markets_core::quantum_lp_manager::auto_redeem_on_proposal_end_from_escrow(
        winning_outcome,
        spot_pool,
        escrow,
        clock,
        ctx,
    );

    // CRITICAL FIX (Issue 3): Extract and clear escrow ID from spot pool
    // All futarchy pools have full features, so this always succeeds
    let _escrow_id = unified_spot_pool::extract_active_escrow(spot_pool);

    // Crank: Transition TRANSITIONING bucket to WITHDRAW_ONLY
    futarchy_markets_operations::liquidity_interact::crank_recombine_and_transition<
        AssetType,
        StableType,
    >(spot_pool);

    // Cancel losing outcome intents
    let num_outcomes = proposal::get_num_outcomes(proposal);
    let mut i = 0u64;
    while (i < num_outcomes) {
        if (i != winning_outcome) {
            let mut cw_opt = proposal::make_cancel_witness(proposal, i);
            if (option::is_some(&cw_opt)) {
                let _cw = option::extract(&mut cw_opt);
            };
            option::destroy_none(cw_opt);
        };
        i = i + 1;
    };

    // Update proposal state to FINALIZED (state 3)
    proposal::set_state(proposal, 3);

    // Emit finalization event
    event::emit(ProposalMarketFinalized {
        proposal_id: proposal::get_id(proposal),
        dao_id: proposal::get_dao_id(proposal),
        winning_outcome,
        approved: winning_outcome == OUTCOME_ACCEPTED,
        timestamp: clock.timestamp_ms(),
    });
}

/// Entry function to execute proposal actions after finalization
/// Executes the staged InitActionSpecs if the Accept outcome won
public entry fun execute_proposal_actions<AssetType, StableType>(
    account: &mut Account,
    registry: &PackageRegistry,
    proposal: &mut Proposal<AssetType, StableType>,
    market_state: &MarketState,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Verify proposal can be executed
    assert!(can_execute_proposal(proposal, market_state), EProposalNotApproved);

    // Extract IDs before mutable borrow
    let proposal_id = proposal::get_id(proposal);
    let dao_id = proposal::get_dao_id(proposal);
    let market_state_id = proposal::market_state_id(proposal);

    // Build intent key hint
    let mut key = b"execution_".to_string();
    key.append(proposal_id.id_to_address().to_string());
    key.append(b"_".to_string());
    key.append(clock.timestamp_ms().to_string());

    // Begin execution - creates Executable hot potato
    let (executable, intent_key) = governance_intents::execute_proposal_intent(
        account,
        registry,
        proposal,
        market_state,
        OUTCOME_ACCEPTED, // 0 = Accept
        futarchy_config::new_futarchy_outcome_full(
            key,
            option::some(proposal_id),
            option::some(market_state_id),
            true,
            clock.timestamp_ms(),
        ),
        clock,
        ctx,
    );

    // Confirm execution (finalize)
    account::confirm_execution(account, executable);

    // Emit event
    event::emit(new_proposal_intent_executed(
        proposal_id,
        dao_id,
        intent_key,
        clock.timestamp_ms(),
    ));
}

// === Helper Functions ===

/// Checks if a proposal can be executed
public fun can_execute_proposal<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    market: &MarketState,
): bool {
    // Market must be finalized
    if (!market_state::is_finalized(market)) {
        return false
    };

    // Proposal must have been approved (YES outcome)
    let winning_outcome = market_state::get_winning_outcome(market);
    if (winning_outcome != OUTCOME_ACCEPTED) {
        return false
    };

    // InitActionSpecs are now stored directly in proposals (no separate intent key system)
    // No additional check needed - if proposal is finalized with ACCEPTED outcome, it can execute
    true
}

/// Calculates the winning outcome and returns TWAP prices to avoid double computation
/// Returns (outcome, twap_prices) where outcome is OUTCOME_ACCEPTED or OUTCOME_REJECTED
/// IMPORTANT: Uses effective threshold which accounts for sponsorship reduction
public fun calculate_winning_outcome_with_twaps<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut futarchy_markets_primitives::coin_escrow::TokenEscrow<AssetType, StableType>,
    clock: &Clock,
): (u64, vector<u128>) {
    // Get TWAP prices from all pools (only computed once now)
    let twap_prices = proposal::get_twaps_for_proposal(proposal, escrow, clock);

    // For a simple YES/NO proposal, compare the YES TWAP to the threshold
    let winning_outcome = if (twap_prices.length() >= 2) {
        let yes_twap = *twap_prices.borrow(OUTCOME_ACCEPTED);

        // CRITICAL: Use effective threshold which accounts for sponsorship reduction
        // If proposal is sponsored, this returns (base_threshold - sponsor_reduction)
        // making it easier for the proposal to pass
        let threshold = proposal::get_effective_twap_threshold(proposal);
        let yes_signed = signed::from_u128(yes_twap);

        // If YES TWAP exceeds threshold, YES wins
        if (signed::compare(&yes_signed, &threshold) == signed::ordering_greater()) {
            OUTCOME_ACCEPTED
        } else {
            OUTCOME_REJECTED
        }
    } else {
        // Default to NO if we can't determine
        OUTCOME_REJECTED
    };

    (winning_outcome, twap_prices)
}

// === Helper Functions for PTB Execution ===

public fun is_passed<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): bool {
    use futarchy_markets_core::proposal as proposal_mod;
    proposal_mod::is_finalized(proposal) && proposal_mod::get_winning_outcome(proposal) == OUTCOME_ACCEPTED
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Proposal sponsorship module - allows team members with quota to sponsor proposals
/// Sponsorship reduces the TWAP threshold, making proposals easier to pass
module futarchy_governance::proposal_sponsorship;

use account_protocol::account::{Self, Account};
use futarchy_core::futarchy_config::{Self, FutarchyConfig};
use futarchy_core::proposal_quota_registry::{Self, ProposalQuotaRegistry};
use futarchy_core::dao_config;
use futarchy_markets_core::proposal::{Self, Proposal};
use futarchy_types::signed;
use std::string::String;
use sui::clock::Clock;
use sui::event;

// === Errors ===
const ESponsorshipNotEnabled: u64 = 1;
const EAlreadySponsored: u64 = 2;
const ENoSponsorQuota: u64 = 3;
const EInvalidProposalState: u64 = 4;
const EDaoMismatch: u64 = 6;
const ETwapDelayPassed: u64 = 7;

// === Constants ===
const STATE_PREMARKET: u8 = 0;
const STATE_REVIEW: u8 = 1;
const STATE_TRADING: u8 = 2;
const STATE_FINALIZED: u8 = 3;

// === Events ===

public struct ProposalSponsored has copy, drop {
    proposal_id: ID,
    dao_id: ID,
    sponsor: address,
    threshold_reduction_magnitude: u128,
    threshold_reduction_is_negative: bool,
    timestamp: u64,
}

public struct SponsorshipRefunded has copy, drop {
    proposal_id: ID,
    dao_id: ID,
    sponsor: address,
    reason: String,
    timestamp: u64,
}

// === Public Entry Functions ===

/// Sponsor a proposal using quota to apply the DAO's configured threshold
/// This makes the proposal easier to pass by applying the DAO's sponsored_threshold
///
/// Requirements:
/// - Sponsorship must be enabled in DAO config
/// - Sponsor must have available sponsor quota
/// - Proposal must not be finalized
/// - Proposal must not already be sponsored
public entry fun sponsor_proposal<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    account: &Account,
    quota_registry: &mut ProposalQuotaRegistry,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let sponsor = ctx.sender();
    let dao_id = proposal::get_dao_id(proposal);
    let proposal_id = proposal::get_id(proposal);

    // Validation 0: Verify DAO consistency (prevent quota bypass attack)
    // All three objects must belong to the same DAO
    let account_dao_id = object::id(account);
    let registry_dao_id = proposal_quota_registry::dao_id(quota_registry);
    assert!(dao_id == account_dao_id, EDaoMismatch);
    assert!(dao_id == registry_dao_id, EDaoMismatch);

    // Get DAO config and sponsorship settings
    let config = account::config(account);
    let dao_cfg = futarchy_config::dao_config(config);
    let sponsor_config = dao_config::sponsorship_config(dao_cfg);

    // Validation 1: Check sponsorship is enabled
    assert!(dao_config::sponsorship_enabled(sponsor_config), ESponsorshipNotEnabled);

    // Validation 2: Check proposal not already sponsored
    assert!(!proposal::is_sponsored(proposal), EAlreadySponsored);

    // Validation 3: Check proposal is not finalized
    let state = proposal::get_state(proposal);
    assert!(state != STATE_FINALIZED, EInvalidProposalState);

    // Validation 4: Check sponsor has available quota
    let (has_quota, remaining) = proposal_quota_registry::check_sponsor_quota_available(
        quota_registry,
        dao_id,
        sponsor,
        clock,
    );
    assert!(has_quota, ENoSponsorQuota);

    // Validation 5: Check sponsorship timing - cannot sponsor after TWAP delay if in trading period
    // This prevents manipulation after TWAP starts recording prices
    validate_sponsorship_timing(proposal, clock);

    // Get sponsored threshold from config
    let sponsored_threshold = dao_config::sponsored_threshold(sponsor_config);

    // Apply sponsorship to proposal
    proposal::set_sponsorship(proposal, sponsor, sponsored_threshold);

    // Use sponsor quota
    proposal_quota_registry::use_sponsor_quota(
        quota_registry,
        dao_id,
        sponsor,
        proposal_id,
        clock,
    );

    // Emit event
    event::emit(ProposalSponsored {
        proposal_id,
        dao_id,
        sponsor,
        threshold_reduction_magnitude: signed::magnitude(&sponsored_threshold),
        threshold_reduction_is_negative: signed::is_negative(&sponsored_threshold),
        timestamp: clock.timestamp_ms(),
    });
}

/// Sponsor a proposal to zero threshold (FREE - no quota cost)
/// Any team member can use this to set proposal threshold to 0%
///
/// Requirements:
/// - Sponsorship must be enabled in DAO config
/// - Sponsor must be a team member (have any entry in quota registry)
/// - Proposal must not be finalized
/// - Proposal must not already be sponsored
public entry fun sponsor_proposal_to_zero<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    account: &Account,
    quota_registry: &ProposalQuotaRegistry,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let sponsor = ctx.sender();
    let dao_id = proposal::get_dao_id(proposal);
    let proposal_id = proposal::get_id(proposal);

    // Validation 0: Verify DAO consistency (prevent quota bypass attack)
    let account_dao_id = object::id(account);
    let registry_dao_id = proposal_quota_registry::dao_id(quota_registry);
    assert!(dao_id == account_dao_id, EDaoMismatch);
    assert!(dao_id == registry_dao_id, EDaoMismatch);

    // Get DAO config and sponsorship settings
    let config = account::config(account);
    let dao_cfg = futarchy_config::dao_config(config);
    let sponsor_config = dao_config::sponsorship_config(dao_cfg);

    // Validation 1: Check sponsorship is enabled
    assert!(dao_config::sponsorship_enabled(sponsor_config), ESponsorshipNotEnabled);

    // Validation 2: Check proposal not already sponsored
    assert!(!proposal::is_sponsored(proposal), EAlreadySponsored);

    // Validation 3: Check proposal is not finalized
    let state = proposal::get_state(proposal);
    assert!(state != STATE_FINALIZED, EInvalidProposalState);

    // Validation 4: Check sponsor is a team member (has any quota entry)
    assert!(proposal_quota_registry::has_quota(quota_registry, sponsor), ENoSponsorQuota);

    // Validation 5: Check sponsorship timing - cannot sponsor after TWAP delay if in trading period
    // This prevents manipulation after TWAP starts recording prices
    validate_sponsorship_timing(proposal, clock);

    // Set threshold to zero
    let zero_threshold = futarchy_types::signed::from_u64(0);

    // Apply sponsorship to proposal
    proposal::set_sponsorship(proposal, sponsor, zero_threshold);

    // NO quota usage - this is free for team members

    // Emit event
    event::emit(ProposalSponsored {
        proposal_id,
        dao_id,
        sponsor,
        threshold_reduction_magnitude: signed::magnitude(&zero_threshold),
        threshold_reduction_is_negative: signed::is_negative(&zero_threshold),
        timestamp: clock.timestamp_ms(),
    });
}

// === Package Functions ===

/// Refund sponsorship quota when a proposal is evicted or cancelled
/// This is called by proposal lifecycle management
public(package) fun refund_sponsorship_on_eviction<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    quota_registry: &mut ProposalQuotaRegistry,
    reason: String,
    clock: &Clock,
) {
    // Only refund if proposal is sponsored
    if (!proposal::is_sponsored(proposal)) {
        return
    };

    let dao_id = proposal::get_dao_id(proposal);
    let proposal_id = proposal::get_id(proposal);
    let sponsor_opt = proposal::get_sponsored_by(proposal);

    if (sponsor_opt.is_some()) {
        let sponsor = *sponsor_opt.borrow();

        // Refund quota
        proposal_quota_registry::refund_sponsor_quota(
            quota_registry,
            dao_id,
            sponsor,
            proposal_id,
            clock,
        );

        // Clear sponsorship from proposal
        proposal::clear_sponsorship(proposal);

        // Emit refund event
        event::emit(SponsorshipRefunded {
            proposal_id,
            dao_id,
            sponsor,
            reason,
            timestamp: clock.timestamp_ms(),
        });
    };
}

// NOTE: The refund_sponsorship_on_eviction() function above handles refunds for ALL proposal evictions
// This includes PREMARKET proposals (queue evictions) since sponsorship is now allowed at any time before FINALIZED
// Queue managers should call this function when evicting proposals to ensure sponsor quota is properly refunded

// === Internal Helper Functions ===

/// Validates that sponsorship is being applied before the TWAP delay has passed in trading period
/// This prevents sponsors from manipulating the threshold after price discovery has begun
///
/// SAFETY: Sponsorship is allowed:
/// - Anytime in PREMARKET or REVIEW states (before trading begins)
/// - During TRADING state, but ONLY before (trading_start + twap_start_delay)
///
/// After the TWAP delay period, the TWAP oracle begins recording prices, so the threshold
/// must be locked to prevent manipulation
fun validate_sponsorship_timing<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    clock: &Clock,
) {
    let state = proposal::get_state(proposal);

    // PREMARKET and REVIEW states - always allowed
    if (state == STATE_PREMARKET || state == STATE_REVIEW) {
        return
    };

    // TRADING state - check if TWAP delay has passed
    if (state == STATE_TRADING) {
        let twap_start_time = calculate_twap_start_time(proposal);
        let current_time = clock.timestamp_ms();

        // Cannot sponsor after TWAP has started recording prices
        assert!(current_time < twap_start_time, ETwapDelayPassed);
    };

    // FINALIZED state is already blocked by earlier validation
}

/// Calculate when TWAP starts recording prices for a proposal
/// Returns: timestamp_ms when TWAP begins
fun calculate_twap_start_time<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>
): u64 {
    let market_init_time = proposal::get_market_initialized_at(proposal);
    let review_period = proposal::get_review_period_ms(proposal);
    let twap_delay = proposal::get_twap_start_delay(proposal);

    // trading_start + twap_delay = when TWAP actually starts
    market_init_time + review_period + twap_delay
}

// === View Functions ===

/// Check if a user can sponsor a proposal
/// Returns (can_sponsor, reason)
public fun can_sponsor_proposal<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    account: &Account,
    quota_registry: &ProposalQuotaRegistry,
    potential_sponsor: address,
    clock: &Clock,
): (bool, String) {
    use std::string;

    let dao_id = proposal::get_dao_id(proposal);

    // Get DAO config and sponsorship settings
    let config = account::config(account);
    let dao_cfg = futarchy_config::dao_config(config);
    let sponsor_config = dao_config::sponsorship_config(dao_cfg);

    // Check 1: Sponsorship enabled
    if (!dao_config::sponsorship_enabled(sponsor_config)) {
        return (false, string::utf8(b"Sponsorship not enabled"))
    };

    // Check 2: Not already sponsored (cheaper check - do this before state check)
    if (proposal::is_sponsored(proposal)) {
        return (false, string::utf8(b"Proposal already sponsored"))
    };

    // Check 3: Valid state (not finalized)
    let state = proposal::get_state(proposal);
    if (state == STATE_FINALIZED) {
        return (false, string::utf8(b"Proposal already finalized"))
    };

    // Check 4: Timing - cannot sponsor after TWAP delay in trading period
    if (state == STATE_TRADING) {
        let twap_start_time = calculate_twap_start_time(proposal);
        let current_time = clock.timestamp_ms();

        if (current_time >= twap_start_time) {
            return (false, string::utf8(b"TWAP delay has passed"))
        };
    };

    // Check 5: Has quota
    let (has_quota, _remaining) = proposal_quota_registry::check_sponsor_quota_available(
        quota_registry,
        dao_id,
        potential_sponsor,
        clock,
    );
    if (!has_quota) {
        return (false, string::utf8(b"No sponsor quota available"))
    };

    (true, string::utf8(b""))
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// PTB execution helpers for Futarchy proposals.
///
/// The frontend composes a programmable transaction that:
/// 1. Calls `begin_execution` to receive the governance executable hot potato.
/// 2. Invokes the relevant `do_*` action functions in order (routing is handled client-side).
/// 3. Calls `finalize_execution` to confirm the intent, perform cleanup, and emit events.
///
/// This keeps execution logic flexible while guaranteeing on-chain sequencing with the
/// executable's action counter.
module futarchy_governance::ptb_executor;

use account_protocol::{
    account::{Self, Account},
    executable::{Self, Executable},
    intents,
    package_registry::PackageRegistry,
};
use futarchy_governance_actions::intent_janitor;
use futarchy_core::{
    futarchy_config::{Self, FutarchyConfig, FutarchyOutcome},
};
use futarchy_governance::proposal_lifecycle;
use futarchy_governance_actions::governance_intents;
use futarchy_markets_core::proposal::{Self, Proposal};
use futarchy_markets_primitives::market_state::{Self, MarketState};
use std::option;
use std::string::String;
use sui::{clock::Clock, coin::Coin, event, object::ID, tx_context::TxContext};

// === Errors ===
const EMarketNotFinalized: u64 = 0;
const EProposalNotApproved: u64 = 1;
const EIntentMissing: u64 = 2;

// YES/ACCEPTED outcome index used across governance flow.
const OUTCOME_ACCEPTED: u64 = 0;

// === Events ===
/// Event emitted when a proposal intent is executed
public struct ProposalIntentExecuted has copy, drop {
    proposal_id: ID,
    dao_id: ID,
    intent_key: String,
    timestamp: u64,
}

/// Begin execution for an approved proposal by creating the governance executable.
/// - Verifies market finalization and approval.
/// - Synthesizes the intent from the stored InitActionSpecs.
/// Returns the executable hot potato and intent key for cleanup.
public fun begin_execution<AssetType, StableType>(
    account: &mut Account,
    registry: &PackageRegistry,
    proposal: &mut Proposal<AssetType, StableType>,
    market: &MarketState,
    clock: &Clock,
    ctx: &mut TxContext,
): (Executable<FutarchyOutcome>, String) {
    assert!(market_state::is_finalized(market), EMarketNotFinalized);

    let winning_outcome = market_state::get_winning_outcome(market);
    assert!(winning_outcome == OUTCOME_ACCEPTED, EProposalNotApproved);
    assert!(
        proposal::has_intent_spec(proposal, winning_outcome),
        EIntentMissing
    );

    let outcome = futarchy_config::new_futarchy_outcome_full(
        build_intent_key_hint(proposal, clock),
        option::some(proposal::get_id(proposal)),
        option::some(proposal::market_state_id(proposal)),
        true,
        clock.timestamp_ms(),
    );

    governance_intents::execute_proposal_intent(
        account,
        registry,
        proposal,
        market,
        winning_outcome,
        outcome,
        clock,
        ctx,
    )
}

/// Finalize execution after all actions have been processed.
/// Confirms the executable, performs janitorial cleanup, and emits the execution event.
/// Note: Cannot be `entry` because Executable<FutarchyOutcome> is not a valid entry parameter type
public fun finalize_execution<AssetType, StableType>(
    account: &mut Account,
    registry: &PackageRegistry,
    proposal: &mut Proposal<AssetType, StableType>,
    executable: Executable<FutarchyOutcome>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let intent_key = intents::key(account_protocol::executable::intent(&executable));

    account::confirm_execution(account, executable);

    intent_janitor::cleanup_all_expired_intents(account, registry, clock, ctx);

    event::emit(ProposalIntentExecuted {
        proposal_id: proposal::get_id(proposal),
        dao_id: proposal::get_dao_id(proposal),
        intent_key,
        timestamp: clock.timestamp_ms(),
    });
}

/// Build a human-readable hint for the temporary outcome metadata.
fun build_intent_key_hint<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    clock: &Clock,
): String {
    let mut key = b"ptb_execution_".to_string();
    let proposal_id = proposal::get_id(proposal);
    key.append(proposal_id.id_to_address().to_string());
    key.append(b"_".to_string());
    key.append(clock.timestamp_ms().to_string());
    key
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Generic per-outcome escrow for proposal deposits
///
/// === Security Model ===
/// - Each outcome has its own isolated escrow + receipt
/// - Receipt stored as dynamic field keyed by outcome index (primary defense)
/// - Only winning outcome can access its escrow
/// - State-locked: deposits only after outcomes finalized (STATE ‚â• REVIEW)
/// - Outcome count verification (defense-in-depth, detects proposal mutation)
///
/// === Design ===
/// - ProposalEscrow: Shared object holding funds/objects
/// - EscrowReceipt: Stored in proposal's dynamic fields per outcome (no drop ability)
/// - OutcomeEscrowKey: Dynamic field key tying receipt to specific outcome
///
/// === Flow ===
/// 1. Proposal reaches REVIEW state (outcomes locked)
/// 2. Create escrow for specific outcome ‚Üí receipt
/// 3. Store receipt in proposal's dynamic field with outcome key
/// 4. When outcome wins, retrieve receipt and withdraw
/// 5. Losing outcomes can't access winning outcome's escrow (keying prevents theft)

module futarchy_governance::proposal_escrow;

use std::option::{Self, Option};
use sui::balance::{Self, Balance};
use sui::bag::{Self, Bag};
use sui::clock::Clock;
use sui::coin::{Self, Coin};
use sui::dynamic_field;
use sui::event;
use sui::object::{Self, UID, ID};
use sui::tx_context::TxContext;

// === Errors ===
const EInvalidReceipt: u64 = 1;
const ENotEmpty: u64 = 2;
const EInsufficientBalance: u64 = 3;
const EObjectNotFound: u64 = 4;
const EInvalidProposal: u64 = 5;
const EAlreadyWithdrawn: u64 = 6;
const EProposalNotReady: u64 = 7;
const EOutcomeCountMismatch: u64 = 8;
const EMarketNotInitialized: u64 = 9;
const EInvalidOutcome: u64 = 10;

// Proposal state constants (must match proposal.move)
const STATE_PREMARKET: u8 = 0;
const STATE_REVIEW: u8 = 1;
const STATE_TRADING: u8 = 2;
const STATE_FINALIZED: u8 = 3;

// === Structs ===

/// Key for storing escrow receipt in proposal's dynamic fields
/// Each outcome has its own receipt - prevents cross-outcome theft
public struct OutcomeEscrowKey has copy, drop, store {
    outcome_index: u64,
}

/// Generic escrow holding either coins or objects for a SPECIFIC outcome
public struct ProposalEscrow<phantom AssetType> has key {
    id: UID,
    proposal_id: ID,
    outcome_index: u64,  // Which outcome owns this escrow
    locked_outcome_count: u64,  // Outcome count when created (prevent mutation)
    /// Fungible balance (for coins)
    balance: Balance<AssetType>,
    /// Object storage (for NFTs, LP tokens, etc.)
    objects: Bag,
    /// Track if primary balance has been withdrawn
    balance_withdrawn: bool,
    created_at: u64,
}

/// Receipt proving deposit into escrow - grants withdrawal authority
/// Stored in proposal's dynamic field keyed by outcome
public struct EscrowReceipt<phantom AssetType> has store {
    escrow_id: ID,
    proposal_id: ID,
    outcome_index: u64,  // Which outcome owns this
    locked_outcome_count: u64,  // Verify outcome count hasn't changed (defense-in-depth)
    /// Amount deposited at creation (for coins)
    initial_coin_amount: u64,
    /// Object IDs deposited (for objects)
    object_ids: vector<ID>,
}


// === Events ===

public struct OutcomeEscrowCreated has copy, drop {
    escrow_id: ID,
    proposal_id: ID,
    outcome_index: u64,
    coin_amount: u64,
    object_count: u64,
    created_at: u64,
}

public struct FundsWithdrawn has copy, drop {
    escrow_id: ID,
    proposal_id: ID,
    outcome_index: u64,
    amount: u64,
    withdrawn_at: u64,
}

public struct ObjectWithdrawn has copy, drop {
    escrow_id: ID,
    proposal_id: ID,
    outcome_index: u64,
    object_id: ID,
    withdrawn_at: u64,
}

public struct EscrowDestroyed has copy, drop {
    escrow_id: ID,
    proposal_id: ID,
    outcome_index: u64,
}

// === Constructor Functions ===

/// Create escrow for specific outcome with state verification
/// SECURITY: Only works if proposal state ‚â• REVIEW (outcomes locked)
/// Returns (escrow, receipt) - caller must store receipt in proposal
public fun create_for_outcome_with_coin<AssetType, StableType>(
    proposal: &futarchy_markets_core::proposal::Proposal<AssetType, StableType>,
    outcome_index: u64,
    deposit: Coin<AssetType>,
    clock: &Clock,
    ctx: &mut TxContext,
): (ProposalEscrow<AssetType>, EscrowReceipt<AssetType>) {
    // SECURITY: Verify proposal is ready (outcomes finalized)
    let state = futarchy_markets_core::proposal::state(proposal);
    assert!(state >= STATE_REVIEW, EProposalNotReady);

    // SECURITY: Verify outcome index is valid
    let outcome_count = futarchy_markets_core::proposal::outcome_count(proposal);
    assert!(outcome_index < outcome_count, EInvalidOutcome);

    // Lock outcome count at escrow creation time
    let locked_outcome_count = outcome_count;

    let coin_amount = deposit.value();
    let id = object::new(ctx);
    let escrow_id = object::uid_to_inner(&id);
    let proposal_id = object::id(proposal);
    let created_at = clock.timestamp_ms();

    let escrow = ProposalEscrow {
        id,
        proposal_id,
        outcome_index,
        locked_outcome_count,
        balance: deposit.into_balance(),
        objects: bag::new(ctx),
        balance_withdrawn: false,
        created_at,
    };

    let receipt = EscrowReceipt {
        escrow_id,
        proposal_id,
        outcome_index,
        locked_outcome_count,
        initial_coin_amount: coin_amount,
        object_ids: vector::empty(),
    };

    event::emit(OutcomeEscrowCreated {
        escrow_id,
        proposal_id,
        outcome_index,
        coin_amount,
        object_count: 0,
        created_at,
    });

    (escrow, receipt)
}

/// Create escrow with object deposit for specific outcome
public fun create_for_outcome_with_object<AssetType, StableType, T: key + store>(
    proposal: &futarchy_markets_core::proposal::Proposal<AssetType, StableType>,
    outcome_index: u64,
    object: T,
    clock: &Clock,
    ctx: &mut TxContext,
): (ProposalEscrow<AssetType>, EscrowReceipt<AssetType>) {
    // SECURITY: Verify proposal is ready
    let state = futarchy_markets_core::proposal::state(proposal);
    assert!(state >= STATE_REVIEW, EProposalNotReady);

    let outcome_count = futarchy_markets_core::proposal::outcome_count(proposal);
    assert!(outcome_index < outcome_count, EInvalidOutcome);

    let locked_outcome_count = outcome_count;
    let id = object::new(ctx);
    let escrow_id = object::uid_to_inner(&id);
    let proposal_id = object::id(proposal);
    let created_at = clock.timestamp_ms();

    let mut objects = bag::new(ctx);
    let object_id = object::id(&object);
    bag::add(&mut objects, object_id, object);

    let escrow = ProposalEscrow<AssetType> {
        id,
        proposal_id,
        outcome_index,
        locked_outcome_count,
        balance: balance::zero<AssetType>(),
        objects,
        balance_withdrawn: false,
        created_at,
    };

    let mut object_ids = vector::empty();
    object_ids.push_back(object_id);

    let receipt = EscrowReceipt {
        escrow_id,
        proposal_id,
        outcome_index,
        locked_outcome_count,
        initial_coin_amount: 0,
        object_ids,
    };

    event::emit(OutcomeEscrowCreated {
        escrow_id,
        proposal_id,
        outcome_index,
        coin_amount: 0,
        object_count: 1,
        created_at,
    });

    (escrow, receipt)
}

// === Receipt Management (Generic Pattern) ===

/// Store escrow receipt in proposal's dynamic fields
/// SECURITY: Keyed by outcome index - prevents cross-outcome access
public fun store_receipt_in_proposal<AssetType, StableType>(
    proposal: &mut futarchy_markets_core::proposal::Proposal<AssetType, StableType>,
    outcome_index: u64,
    receipt: EscrowReceipt<AssetType>,
) {
    // Verify outcome index matches receipt
    assert!(receipt.outcome_index == outcome_index, EInvalidOutcome);

    let key = OutcomeEscrowKey { outcome_index };
    dynamic_field::add(
        futarchy_markets_core::proposal::borrow_uid_mut(proposal),
        key,
        receipt
    );
}

/// Retrieve escrow receipt from proposal for specific outcome
/// SECURITY: Only returns receipt if outcome index matches
public fun get_receipt_from_proposal<AssetType, StableType>(
    proposal: &futarchy_markets_core::proposal::Proposal<AssetType, StableType>,
    outcome_index: u64,
): &EscrowReceipt<AssetType> {
    let key = OutcomeEscrowKey { outcome_index };
    dynamic_field::borrow(
        futarchy_markets_core::proposal::borrow_uid(proposal),
        key
    )
}

/// Remove escrow receipt from proposal (for winning outcome execution)
/// Package-private to prevent external code from stealing receipts
public(package) fun remove_receipt_from_proposal<AssetType, StableType>(
    proposal: &mut futarchy_markets_core::proposal::Proposal<AssetType, StableType>,
    outcome_index: u64,
): EscrowReceipt<AssetType> {
    let key = OutcomeEscrowKey { outcome_index };
    dynamic_field::remove(
        futarchy_markets_core::proposal::borrow_uid_mut(proposal),
        key
    )
}

/// Check if outcome has escrow receipt
public fun has_escrow_receipt<AssetType, StableType>(
    proposal: &futarchy_markets_core::proposal::Proposal<AssetType, StableType>,
    outcome_index: u64,
): bool {
    let key = OutcomeEscrowKey { outcome_index };
    dynamic_field::exists_<OutcomeEscrowKey>(
        futarchy_markets_core::proposal::borrow_uid(proposal),
        key
    )
}

// === Withdrawal Functions ===

/// Withdraw partial amount using receipt
/// SECURITY: Verifies outcome count hasn't changed since creation
public fun withdraw_partial<AssetType, StableType>(
    escrow: &mut ProposalEscrow<AssetType>,
    proposal: &futarchy_markets_core::proposal::Proposal<AssetType, StableType>,
    receipt: &EscrowReceipt<AssetType>,
    amount: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<AssetType> {
    // Verify receipt matches escrow
    assert!(object::id(escrow) == receipt.escrow_id, EInvalidReceipt);
    assert!(escrow.proposal_id == receipt.proposal_id, EInvalidProposal);
    assert!(escrow.outcome_index == receipt.outcome_index, EInvalidReceipt);
    assert!(!escrow.balance_withdrawn, EAlreadyWithdrawn);

    // SECURITY: Verify outcome count hasn't changed (mutation protection)
    let current_outcome_count = futarchy_markets_core::proposal::outcome_count(proposal);
    assert!(
        current_outcome_count == escrow.locked_outcome_count,
        EOutcomeCountMismatch
    );
    assert!(
        current_outcome_count == receipt.locked_outcome_count,
        EOutcomeCountMismatch
    );

    // Verify sufficient balance
    assert!(escrow.balance.value() >= amount, EInsufficientBalance);

    let withdrawn = escrow.balance.split(amount);

    event::emit(FundsWithdrawn {
        escrow_id: receipt.escrow_id,
        proposal_id: receipt.proposal_id,
        outcome_index: receipt.outcome_index,
        amount,
        withdrawn_at: clock.timestamp_ms(),
    });

    coin::from_balance(withdrawn, ctx)
}

/// Withdraw all coins using receipt (consumes receipt)
public fun withdraw_all_coins<AssetType, StableType>(
    escrow: &mut ProposalEscrow<AssetType>,
    proposal: &futarchy_markets_core::proposal::Proposal<AssetType, StableType>,
    receipt: EscrowReceipt<AssetType>,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<AssetType> {
    // Verify receipt
    assert!(object::id(escrow) == receipt.escrow_id, EInvalidReceipt);
    assert!(escrow.proposal_id == receipt.proposal_id, EInvalidProposal);
    assert!(escrow.outcome_index == receipt.outcome_index, EInvalidReceipt);
    assert!(!escrow.balance_withdrawn, EAlreadyWithdrawn);

    // SECURITY: Verify outcome count
    let current_outcome_count = futarchy_markets_core::proposal::outcome_count(proposal);
    assert!(
        current_outcome_count == escrow.locked_outcome_count,
        EOutcomeCountMismatch
    );
    assert!(
        current_outcome_count == receipt.locked_outcome_count,
        EOutcomeCountMismatch
    );

    let amount = escrow.balance.value();
    let withdrawn = escrow.balance.withdraw_all();

    // Mark as withdrawn
    escrow.balance_withdrawn = true;

    event::emit(FundsWithdrawn {
        escrow_id: receipt.escrow_id,
        proposal_id: receipt.proposal_id,
        outcome_index: receipt.outcome_index,
        amount,
        withdrawn_at: clock.timestamp_ms(),
    });

    // Consume receipt (no drop ability, so must destructure)
    let EscrowReceipt {
        escrow_id: _,
        proposal_id: _,
        outcome_index: _,
        locked_outcome_count: _,
        initial_coin_amount: _,
        object_ids: _
    } = receipt;

    coin::from_balance(withdrawn, ctx)
}

/// Withdraw specific object using receipt
public fun withdraw_object<AssetType, StableType, T: key + store>(
    escrow: &mut ProposalEscrow<AssetType>,
    proposal: &futarchy_markets_core::proposal::Proposal<AssetType, StableType>,
    receipt: &EscrowReceipt<AssetType>,
    object_id: ID,
    clock: &Clock,
    _ctx: &mut TxContext,
): T {
    // Verify receipt
    assert!(object::id(escrow) == receipt.escrow_id, EInvalidReceipt);
    assert!(escrow.proposal_id == receipt.proposal_id, EInvalidProposal);
    assert!(escrow.outcome_index == receipt.outcome_index, EInvalidReceipt);

    // SECURITY: Verify outcome count
    let current_outcome_count = futarchy_markets_core::proposal::outcome_count(proposal);
    assert!(
        current_outcome_count == escrow.locked_outcome_count,
        EOutcomeCountMismatch
    );

    // Verify object was deposited
    assert!(receipt.object_ids.contains(&object_id), EObjectNotFound);

    // Remove object directly from bag
    let object: T = bag::remove(&mut escrow.objects, object_id);

    event::emit(ObjectWithdrawn {
        escrow_id: receipt.escrow_id,
        proposal_id: receipt.proposal_id,
        outcome_index: receipt.outcome_index,
        object_id,
        withdrawn_at: clock.timestamp_ms(),
    });

    object
}

// === Cleanup Functions ===

/// Destroy empty escrow
public fun destroy_empty<AssetType>(escrow: ProposalEscrow<AssetType>) {
    let ProposalEscrow {
        id,
        proposal_id,
        outcome_index,
        locked_outcome_count: _,
        balance,
        objects,
        balance_withdrawn: _,
        created_at: _,
    } = escrow;

    assert!(balance.value() == 0, ENotEmpty);
    assert!(objects.is_empty(), ENotEmpty);

    balance.destroy_zero();
    objects.destroy_empty();

    event::emit(EscrowDestroyed {
        escrow_id: object::uid_to_inner(&id),
        proposal_id,
        outcome_index,
    });

    object::delete(id);
}

// === Getters ===

public fun escrow_outcome_index<AssetType>(escrow: &ProposalEscrow<AssetType>): u64 {
    escrow.outcome_index
}

public fun escrow_locked_outcome_count<AssetType>(escrow: &ProposalEscrow<AssetType>): u64 {
    escrow.locked_outcome_count
}

public fun receipt_outcome_index<AssetType>(receipt: &EscrowReceipt<AssetType>): u64 {
    receipt.outcome_index
}

public fun receipt_escrow_id<AssetType>(receipt: &EscrowReceipt<AssetType>): ID {
    receipt.escrow_id
}

public fun receipt_initial_coin_amount<AssetType>(receipt: &EscrowReceipt<AssetType>): u64 {
    receipt.initial_coin_amount
}

public fun balance<AssetType>(escrow: &ProposalEscrow<AssetType>): u64 {
    escrow.balance.value()
}

public fun is_empty<AssetType>(escrow: &ProposalEscrow<AssetType>): bool {
    escrow.balance.value() == 0 && escrow.objects.is_empty()
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Unified package registry governance actions
/// Manages both package whitelisting AND action type declarations in a single system
module futarchy_governance_actions::package_registry_actions;

use std::string::String;
use sui::bcs::{Self, BCS};
use account_protocol::{
    package_registry::PackageRegistry,
    account::{Self, Account},
    bcs_validation,
    executable::{Self, Executable},
    intents,
    version_witness::VersionWitness,
    action_validation,
    package_registry,
    deps,
};

// === Action Type Markers ===

public struct AddPackage has drop {}
public struct RemovePackage has drop {}
public struct UpdatePackageVersion has drop {}
public struct UpdatePackageMetadata has drop {}
public struct PauseAccountCreation has drop {}
public struct UnpauseAccountCreation has drop {}

// === Action Structs ===

public struct AddPackageAction has store, drop {
    name: String,
    addr: address,
    version: u64,
    action_types: vector<String>,  // Action types as strings (e.g., "package_name::ActionType")
    category: String,
    description: String,
}

public struct RemovePackageAction has store, drop {
    name: String,
}

public struct UpdatePackageVersionAction has store, drop {
    name: String,
    addr: address,
    version: u64,
}

public struct UpdatePackageMetadataAction has store, drop {
    name: String,
    new_action_types: vector<String>,
    new_category: String,
    new_description: String,
}

public struct PauseAccountCreationAction has store, drop {
    // No fields needed - this action just sets a flag
}

public struct UnpauseAccountCreationAction has store, drop {
    // No fields needed - this action just sets a flag
}

// === Marker Functions ===

public fun add_package_marker(): AddPackage { AddPackage {} }
public fun remove_package_marker(): RemovePackage { RemovePackage {} }
public fun update_package_version_marker(): UpdatePackageVersion { UpdatePackageVersion {} }
public fun update_package_metadata_marker(): UpdatePackageMetadata { UpdatePackageMetadata {} }
public fun pause_account_creation_marker(): PauseAccountCreation { PauseAccountCreation {} }
public fun unpause_account_creation_marker(): UnpauseAccountCreation { UnpauseAccountCreation {} }

// === Errors ===

const EUnsupportedActionVersion: u64 = 1;
const EUnauthorized: u64 = 2;

// === Public Constructors ===

public fun new_add_package(
    name: String,
    addr: address,
    version: u64,
    action_types: vector<String>,
    category: String,
    description: String,
): AddPackageAction {
    AddPackageAction { name, addr, version, action_types, category, description }
}

public fun new_remove_package(name: String): RemovePackageAction {
    RemovePackageAction { name }
}

public fun new_update_package_version(
    name: String,
    addr: address,
    version: u64,
): UpdatePackageVersionAction {
    UpdatePackageVersionAction { name, addr, version }
}

public fun new_update_package_metadata(
    name: String,
    new_action_types: vector<String>,
    new_category: String,
    new_description: String,
): UpdatePackageMetadataAction {
    UpdatePackageMetadataAction { name, new_action_types, new_category, new_description }
}

public fun new_pause_account_creation(): PauseAccountCreationAction {
    PauseAccountCreationAction {}
}

public fun new_unpause_account_creation(): UnpauseAccountCreationAction {
    UnpauseAccountCreationAction {}
}

// === Execution Functions ===
//
// ARCHITECTURE NOTE:
// These functions use Move's type-system based authorization instead of explicit capability checks.
// The &mut PackageRegistry parameter provides proof of authorization - only the registry owner
// can obtain this mutable reference. This is enforced by Move's linear type system.
//
// This approach is:
// - More idiomatic (follows sui::coin, sui::token patterns)
// - Simpler (fewer parameters, clearer intent)
// - Type-safe (impossible to bypass authorization)
// - Solves borrow checker conflicts (no need to borrow PackageAdminCap from account)

public fun do_add_package<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    version_witness: VersionWitness,
    witness: IW,
    registry: &mut PackageRegistry,
) {
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));
    action_validation::assert_action_type<AddPackage>(spec);

    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    let action_data = intents::action_spec_data(spec);
    let mut reader = bcs::new(*action_data);

    let name = bcs::peel_vec_u8(&mut reader).to_string();
    let addr = bcs::peel_address(&mut reader);
    let version = bcs::peel_u64(&mut reader);

    // Deserialize action type strings
    let action_types_count = bcs::peel_vec_length(&mut reader);
    let mut action_types = vector::empty();
    let mut i = 0;
    while (i < action_types_count) {
        action_types.push_back(bcs::peel_vec_u8(&mut reader).to_string());
        i = i + 1;
    };

    let category = bcs::peel_vec_u8(&mut reader).to_string();
    let description = bcs::peel_vec_u8(&mut reader).to_string();

    bcs_validation::validate_all_bytes_consumed(reader);

    // Verify package dependencies for security
    // This checks both account-specific deps and the global PackageRegistry whitelist
    account.deps().check(version_witness, registry);

    // Authorization is enforced by Move's type system:
    // Only the registry owner can obtain &mut PackageRegistry
    // No need to borrow PackageAdminCap - the mutable registry reference is sufficient proof
    package_registry::add_package(
        registry,
        name,
        addr,
        version,
        action_types,
        category,
        description,
    );

    executable::increment_action_idx(executable);
}

public fun do_remove_package<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    version_witness: VersionWitness,
    witness: IW,
    registry: &mut PackageRegistry,
) {
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));
    action_validation::assert_action_type<RemovePackage>(spec);

    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    let action_data = intents::action_spec_data(spec);
    let mut reader = bcs::new(*action_data);
    let name = bcs::peel_vec_u8(&mut reader).to_string();

    bcs_validation::validate_all_bytes_consumed(reader);

    // Verify package dependencies for security
    account.deps().check(version_witness, registry);

    // Authorization enforced by type system (&mut PackageRegistry)
    package_registry::remove_package(registry, name);

    executable::increment_action_idx(executable);
}

public fun do_update_package_version<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    version_witness: VersionWitness,
    witness: IW,
    registry: &mut PackageRegistry,
) {
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));
    action_validation::assert_action_type<UpdatePackageVersion>(spec);

    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    let action_data = intents::action_spec_data(spec);
    let mut reader = bcs::new(*action_data);

    let name = bcs::peel_vec_u8(&mut reader).to_string();
    let addr = bcs::peel_address(&mut reader);
    let version = bcs::peel_u64(&mut reader);

    bcs_validation::validate_all_bytes_consumed(reader);

    // Verify package dependencies for security
    account.deps().check(version_witness, registry);

    // Authorization enforced by type system (&mut PackageRegistry)
    package_registry::update_package_version(registry, name, addr, version);

    executable::increment_action_idx(executable);
}

public fun do_update_package_metadata<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    version_witness: VersionWitness,
    witness: IW,
    registry: &mut PackageRegistry,
) {
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));
    action_validation::assert_action_type<UpdatePackageMetadata>(spec);

    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    let action_data = intents::action_spec_data(spec);
    let mut reader = bcs::new(*action_data);

    let name = bcs::peel_vec_u8(&mut reader).to_string();

    // Deserialize action type strings
    let action_types_count = bcs::peel_vec_length(&mut reader);
    let mut action_types = vector::empty();
    let mut i = 0;
    while (i < action_types_count) {
        action_types.push_back(bcs::peel_vec_u8(&mut reader).to_string());
        i = i + 1;
    };

    let category = bcs::peel_vec_u8(&mut reader).to_string();
    let description = bcs::peel_vec_u8(&mut reader).to_string();

    bcs_validation::validate_all_bytes_consumed(reader);

    // Verify package dependencies for security
    account.deps().check(version_witness, registry);

    // Authorization enforced by type system (&mut PackageRegistry)
    // action_types are already Strings
    package_registry::update_package_metadata(
        registry,
        name,
        action_types,
        category,
        description,
    );

    executable::increment_action_idx(executable);
}

public fun do_pause_account_creation<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    version_witness: VersionWitness,
    _witness: IW,
    registry: &mut PackageRegistry,
) {
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));
    action_validation::assert_action_type<PauseAccountCreation>(spec);

    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    let action_data = intents::action_spec_data(spec);
    let reader = bcs::new(*action_data);

    // No data to deserialize - pause action has no parameters
    bcs_validation::validate_all_bytes_consumed(reader);

    // Increment action index
    executable::increment_action_idx(executable);

    // Verify the account has the PackageAdminCap (proves authorization)
    // The cap must be locked in the account first using access_control::lock_cap()
    assert!(
        account::has_managed_asset(account, b"protocol:package_admin_cap".to_string()),
        EUnauthorized
    );

    // Verify deps compatibility
    deps::check(account::deps(account), version_witness, registry);

    // Pause account creation (authorization already verified above)
    package_registry::pause_account_creation_authorized(registry);
}

public fun do_unpause_account_creation<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    version_witness: VersionWitness,
    _witness: IW,
    registry: &mut PackageRegistry,
) {
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));
    action_validation::assert_action_type<UnpauseAccountCreation>(spec);

    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    let action_data = intents::action_spec_data(spec);
    let reader = bcs::new(*action_data);

    // No data to deserialize - unpause action has no parameters
    bcs_validation::validate_all_bytes_consumed(reader);

    // Increment action index
    executable::increment_action_idx(executable);

    // Verify the account has the PackageAdminCap (proves authorization)
    // The cap must be locked in the account first using access_control::lock_cap()
    assert!(
        account::has_managed_asset(account, b"protocol:package_admin_cap".to_string()),
        EUnauthorized
    );

    // Verify deps compatibility
    deps::check(account::deps(account), version_witness, registry);

    // Unpause account creation (authorization already verified above)
    package_registry::unpause_account_creation_authorized(registry);
}

// === Garbage Collection ===

public fun delete_package_registry_action(expired: &mut account_protocol::intents::Expired) {
    let action_spec = account_protocol::intents::remove_action_spec(expired);
    let _ = action_spec;
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Governance module for creating and executing intents from approved proposals
/// This module provides a simplified interface for governance operations
module futarchy_governance_actions::governance_intents;

// === Imports ===
use std::string::{Self, String};
use std::option::{Self, Option};
use std::vector;
use sui::{
    clock::Clock,
    tx_context::TxContext,
    object,
};
use account_protocol::{
    account::{Self, Account},
    executable::{Self, Executable},
    intents::{Self, Intent, Params},
    intent_interface,
    package_registry::PackageRegistry,
};
use account_actions::init_action_specs::{Self, InitActionSpecs};
use futarchy_core::version;
use futarchy_core::{
    futarchy_config::{Self, FutarchyConfig},
};
use futarchy_governance_actions::intent_janitor;
use futarchy_markets_core::proposal::{Self, Proposal};
use futarchy_markets_primitives::market_state::MarketState;

// === Aliases ===
use fun intent_interface::build_intent as Account.build_intent;

// === Witness ===
/// Single witness for governance intents
public struct GovernanceWitness has copy, drop {}

/// Get the governance witness
public fun witness(): GovernanceWitness {
    GovernanceWitness {}
}

// === Execution Functions ===

/// Execute a governance intent from an approved proposal
/// This creates an Intent just-in-time from the stored IntentSpec blueprint
/// and immediately converts it to an executable for execution
/// Returns both the executable and the intent key for cleanup
public fun execute_proposal_intent<AssetType, StableType, Outcome: store + drop + copy>(
    account: &mut Account,
    registry: &PackageRegistry,
    proposal: &mut Proposal<AssetType, StableType>,
    _market: &MarketState,
    outcome_index: u64,
    outcome: Outcome,
    clock: &Clock,
    ctx: &mut TxContext
): (Executable<Outcome>, String) {
    // Get the intent spec from the proposal for the specified outcome
    let mut intent_spec_opt = proposal::take_intent_spec_for_outcome(proposal, outcome_index);

    // Extract the intent spec - if no spec exists, this indicates no action was defined for this outcome
    assert!(option::is_some(&intent_spec_opt), 4); // EIntentNotFound
    let intent_spec = option::extract(&mut intent_spec_opt);
    option::destroy_none(intent_spec_opt);

    // Create and store Intent temporarily, then immediately create Executable
    let intent_key = create_and_store_intent_from_spec(
        account,
        registry,
        intent_spec,
        outcome,
        clock,
        ctx
    );

    // Now create the executable from the stored intent
    let (_outcome, executable) = account::create_executable<FutarchyConfig, Outcome, GovernanceWitness>(
        account,
        registry,
        intent_key,
        clock,
        version::current(),
        GovernanceWitness{},
        ctx,
    );

    (executable, intent_key)
}

// === Helper Functions ===

/// Create and store an Intent from an InitActionSpecs blueprint
/// Returns the intent key for immediate execution
public fun create_and_store_intent_from_spec<Outcome: store + drop + copy>(
    account: &mut Account,
    registry: &PackageRegistry,
    spec: InitActionSpecs,
    outcome: Outcome,
    clock: &Clock,
    ctx: &mut TxContext
): String {
    // Generate a guaranteed-unique key using Sui's native ID generation
    // This ensures uniqueness even when multiple proposals execute in the same block
    let intent_key = ctx.fresh_object_address().to_string();

    // Create intent parameters with immediate execution
    let params = intents::new_params(
        intent_key,
        b"Just-in-time Proposal Execution".to_string(),
        vector[clock.timestamp_ms()], // Execute immediately
        clock.timestamp_ms() + 3_600_000, // 1 hour expiry
        clock,
        ctx
    );

    // Create the intent using the account module
    let mut intent = account::create_intent(
        account,
        registry,
        params,
        outcome,
        b"ProposalExecution".to_string(),
        version::current(),
        witness(),
        ctx
    );

    // Add all actions from the spec to the intent
    let actions = init_action_specs::actions(&spec);
    let mut i = 0;
    let len = vector::length(actions);
    while (i < len) {
        let action = vector::borrow(actions, i);
        // CRITICAL: Preserve the action_type from the stored InitActionSpec!
        let action_type = init_action_specs::action_type(action);
        let action_data = init_action_specs::action_data(action);

        // Add the action to the intent using add_action_spec_with_typename
        // This preserves the TypeName from the stored spec instead of deriving it from witness
        intents::add_action_spec_with_typename(
            &mut intent,
            action_type,  // Use the actual stored action type, not witness type!
            *action_data,
            witness()
        );
        i = i + 1;
    };

    // Store the intent in the account
    let key_copy = intent_key;
    let expiration_time = clock.timestamp_ms() + 3_600_000; // Same as above
    account::insert_intent(account, registry, intent, version::current(), witness());

    // Register the intent with the janitor for tracking and cleanup
    intent_janitor::register_intent(account, registry, intent_key, expiration_time, ctx);

    key_copy
}// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Public cleanup functions for expired intents
/// Sui's storage rebate system naturally incentivizes cleanup -
/// cleaners get the storage deposit back when deleting objects
module futarchy_governance_actions::intent_janitor;

use account_protocol::account::{Self, Account};
use account_protocol::intents::{Self, Expired};
use account_protocol::package_registry::PackageRegistry;
use futarchy_actions::config_actions;
use futarchy_core::futarchy_config::{Self, FutarchyConfig, FutarchyOutcome};
use futarchy_core::version;
use std::string::{Self as string, String};
use sui::clock::Clock;
use sui::event;
use sui::table::{Self, Table};

// === Constants ===

/// Maximum intents that can be cleaned in one call to prevent gas exhaustion
const MAX_CLEANUP_PER_CALL: u64 = 20;

// === Errors ===

const ENoExpiredIntents: u64 = 1;
const ECleanupLimitExceeded: u64 = 2;

// === Types ===

/// Index for tracking created intents to enable cleanup
public struct IntentIndex has store {
    /// Vector of all intent keys that have been created
    keys: vector<String>,
    /// Map from intent key to expiration time for quick lookup
    expiration_times: Table<String, u64>,
    /// Current scan position for round-robin cleanup
    scan_position: u64,
}

/// Key for storing the intent index in managed data
public struct IntentIndexKey has copy, drop, store {}

// === Events ===

/// Emitted when intents are cleaned
public struct IntentsCleaned has copy, drop {
    dao_id: ID,
    cleaner: address,
    count: u64,
    timestamp: u64,
}

/// Emitted when maintenance is needed
public struct MaintenanceNeeded has copy, drop {
    dao_id: ID,
    expired_count: u64,
    timestamp: u64,
}

// === Public Functions ===

/// Clean up expired FutarchyOutcome intents
/// Sui's storage rebate naturally rewards cleaners
public fun cleanup_expired_futarchy_intents(
    account: &mut Account,
    registry: &PackageRegistry,
    max_to_clean: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(max_to_clean <= MAX_CLEANUP_PER_CALL, ECleanupLimitExceeded);

    let mut cleaned = 0u64;
    let dao_id = object::id(account);
    let cleaner = ctx.sender();

    // Try to clean up to max_to_clean intents
    while (cleaned < max_to_clean) {
        // Find next expired intent
        let mut intent_key_opt = find_next_expired_intent(account, registry, clock, ctx);
        if (intent_key_opt.is_none()) {
            break // No more expired intents
        };

        let intent_key = intent_key_opt.extract();

        // Try to delete it as FutarchyOutcome type
        if (try_delete_expired_futarchy_intent(account, registry, intent_key, clock, ctx)) {
            cleaned = cleaned + 1;
        } else {};
    };

    assert!(cleaned > 0, ENoExpiredIntents);

    // Emit event
    event::emit(IntentsCleaned {
        dao_id,
        cleaner,
        count: cleaned,
        timestamp: clock.timestamp_ms(),
    });
}

/// Clean up ALL expired intents during normal operations (no reward)
/// Called automatically during proposal finalization and execution
public fun cleanup_all_expired_intents(
    account: &mut Account,
    registry: &PackageRegistry,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Keep cleaning until no more expired intents are found
    loop {
        let mut intent_key_opt = find_next_expired_intent(account, registry, clock, ctx);
        if (intent_key_opt.is_none()) {
            break
        };

        let intent_key = intent_key_opt.extract();

        // Try to delete it - continue even if this specific one fails
        // (might be wrong type or other issue)
        try_delete_expired_futarchy_intent(account, registry, intent_key, clock, ctx);
    };
}

/// Clean up expired intents with a limit (for bounded operations)
/// Called automatically during proposal finalization and execution
public(package) fun cleanup_expired_intents_automatic(
    account: &mut Account,
    registry: &PackageRegistry,
    max_to_clean: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let mut cleaned = 0u64;

    while (cleaned < max_to_clean) {
        let mut intent_key_opt = find_next_expired_intent(account, registry, clock, ctx);
        if (intent_key_opt.is_none()) {
            break
        };

        let intent_key = intent_key_opt.extract();

        if (try_delete_expired_futarchy_intent(account, registry, intent_key, clock, ctx)) {
            cleaned = cleaned + 1;
        };
    };
}

/// Check if maintenance is needed and emit event if so
public fun check_maintenance_needed(account: &Account, registry: &PackageRegistry, clock: &Clock) {
    let expired_count = count_expired_intents(account, registry, clock);

    if (expired_count > 10) {
        event::emit(MaintenanceNeeded {
            dao_id: object::id(account),
            expired_count,
            timestamp: clock.timestamp_ms(),
        });
    }
}

// === Internal Functions ===

/// Get or initialize the intent index
fun get_or_init_intent_index(
    account: &mut Account,
    registry: &PackageRegistry,
    ctx: &mut TxContext,
): &mut IntentIndex {
    // Initialize if doesn't exist
    if (!account::has_managed_data(account, IntentIndexKey {})) {
        let index = IntentIndex {
            keys: vector::empty(),
            expiration_times: table::new(ctx),
            scan_position: 0,
        };
        account::add_managed_data(
            account,
            registry,
            IntentIndexKey {},
            index,
            version::current(),
        );
    };

    account::borrow_managed_data_mut(
        account,
        registry,
        IntentIndexKey {},
        version::current(),
    )
}

/// Add an intent to the index when it's created
public(package) fun register_intent(
    account: &mut Account,
    registry: &PackageRegistry,
    key: String,
    expiration_time: u64,
    ctx: &mut TxContext,
) {
    let index = get_or_init_intent_index(account, registry, ctx);
    vector::push_back(&mut index.keys, key);
    table::add(&mut index.expiration_times, key, expiration_time);
}

/// Find the next expired intent key
fun find_next_expired_intent(
    account: &mut Account,
    registry: &PackageRegistry,
    clock: &Clock,
    ctx: &mut TxContext,
): Option<String> {
    // Get the index
    let index = get_or_init_intent_index(account, registry, ctx);

    let current_time = clock.timestamp_ms();
    let keys = &index.keys;
    let expiration_times = &index.expiration_times;
    let len = vector::length(keys);

    if (len == 0) {
        return option::none()
    };

    // Start from last scan position for round-robin
    let mut checked = 0;
    let mut pos = index.scan_position;

    while (checked < len) {
        if (pos >= len) {
            pos = 0; // Wrap around
        };

        let key = vector::borrow(keys, pos);

        // Check if this intent is expired
        if (table::contains(expiration_times, *key)) {
            let expiry = *table::borrow(expiration_times, *key);
            if (current_time >= expiry) {
                // Update scan position for next call
                index.scan_position = pos + 1;
                return option::some(*key)
            }
        };

        pos = pos + 1;
        checked = checked + 1;
    };

    option::none()
}

/// Try to delete an expired FutarchyOutcome intent
fun try_delete_expired_futarchy_intent(
    account: &mut Account,
    registry: &PackageRegistry,
    key: String,
    clock: &Clock,
    ctx: &mut TxContext,
): bool {
    // Check if intent exists and is expired
    let intents_store = account::intents(account);
    if (!intents::contains(intents_store, key)) {
        return false
    };

    let key_for_index = key;
    let expired = account::delete_expired_intent<FutarchyOutcome>(
        account,
        key,
        clock,
        ctx,
    );
    destroy_expired(expired);

    remove_from_index(account, registry, key_for_index, ctx);

    true
}

/// Destroy an expired intent after removing all actions
fun destroy_expired(expired: Expired) {
    // For now, we can't generically remove actions from Expired
    // This would require knowing all possible action types
    // Instead, we'll just destroy it if it's already empty
    // or abort if it has actions (shouldn't happen with FutarchyOutcome)

    // Destroy the expired intent (will abort if not empty)
    intents::destroy_empty_expired(expired);
}

/// Count expired intents
fun count_expired_intents(account: &Account, registry: &PackageRegistry, clock: &Clock): u64 {
    // Check if index exists
    if (!account::has_managed_data(account, IntentIndexKey {})) {
        return 0
    };

    let index: &IntentIndex = account::borrow_managed_data(
        account,
        registry,
        IntentIndexKey {},
        version::current(),
    );

    let current_time = clock.timestamp_ms();
    let mut count = 0u64;
    let keys = &index.keys;
    let expiration_times = &index.expiration_times;
    let len = vector::length(keys);

    let mut i = 0;
    while (i < len && i < 100) {
        // Limit scan to prevent gas exhaustion
        let key = vector::borrow(keys, i);
        if (table::contains(expiration_times, *key)) {
            let expiry = *table::borrow(expiration_times, *key);
            if (current_time >= expiry) {
                count = count + 1;
            }
        };
        i = i + 1;
    };

    count
}

/// Remove an intent from the index after deletion
fun remove_from_index(account: &mut Account, registry: &PackageRegistry, key: String, ctx: &mut TxContext) {
    let index = get_or_init_intent_index(account, registry, ctx);

    // Remove from expiration times table
    if (table::contains(&index.expiration_times, key)) {
        table::remove(&mut index.expiration_times, key);
    };

    // Remove from keys vector (expensive but necessary)
    let keys = &mut index.keys;
    let len = vector::length(keys);
    let mut i = 0;

    while (i < len) {
        if (*vector::borrow(keys, i) == key) {
            vector::swap_remove(keys, i);

            // Adjust scan position if needed
            if (index.scan_position > i) {
                index.scan_position = index.scan_position - 1;
            };
            break
        };
        i = i + 1;
    };
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Protocol admin actions for managing the futarchy protocol through its own DAO (dogfooding).
/// This module allows the protocol's owner DAO and its security council to control:
/// - Factory admin functions (FactoryOwnerCap)
/// - Fee management (FeeAdminCap) 
/// - Validator functions (ValidatorAdminCap)
module futarchy_governance_actions::protocol_admin_actions;

// === Imports ===
use std::{
    string::{String as UTF8String, String},
    type_name::{Self, TypeName},
};
use sui::{
    bcs::{Self, BCS},
    clock::Clock,
    coin::{Self, Coin},
    event,
    object::{Self, ID},
    sui::SUI,
    vec_set::VecSet,
};
use account_protocol::{
    account::{Self, Account},
    bcs_validation,
    executable::{Self, Executable},
    intents,
    package_registry::PackageRegistry,
    version_witness::VersionWitness,
};
use futarchy_core::futarchy_config::{Self, FutarchyConfig};
use futarchy_factory::{
    factory::{Self, Factory, FactoryOwnerCap, ValidatorAdminCap},
};
use futarchy_markets_core::{
    fee::{Self, FeeManager, FeeAdminCap},
};
// futarchy_dao dependency removed - use ConfigWitness instead
use account_protocol::action_validation;

// === Action Type Markers ===

/// Add coin fee configuration
public struct AddCoinFeeConfig has drop {}
/// Add stable type
public struct AddStableType has drop {}
/// Add verification level
public struct AddVerificationLevel has drop {}
/// Apply pending coin fees
public struct ApplyPendingCoinFees has drop {}
/// Disable factory permanently
public struct DisableFactoryPermanently has drop {}
/// Remove stable type
public struct RemoveStableType has drop {}
/// Remove verification level
public struct RemoveVerificationLevel has drop {}
/// Set factory paused state
public struct SetFactoryPaused has drop {}
/// Update coin creation fee
public struct UpdateCoinCreationFee has drop {}
/// Update coin proposal fee
public struct UpdateCoinProposalFee has drop {}
/// Update DAO creation fee
public struct UpdateDaoCreationFee has drop {}
/// Update proposal fee
public struct UpdateProposalFee has drop {}
/// Update verification fee
public struct UpdateVerificationFee has drop {}
/// Withdraw fees to treasury
public struct WithdrawFeesToTreasury has drop {}

// === Marker Functions ===

public fun set_factory_paused_marker(): SetFactoryPaused { SetFactoryPaused {} }
public fun add_stable_type_marker(): AddStableType { AddStableType {} }
public fun remove_stable_type_marker(): RemoveStableType { RemoveStableType {} }
public fun update_dao_creation_fee_marker(): UpdateDaoCreationFee { UpdateDaoCreationFee {} }
public fun update_proposal_fee_marker(): UpdateProposalFee { UpdateProposalFee {} }
public fun update_verification_fee_marker(): UpdateVerificationFee { UpdateVerificationFee {} }
public fun withdraw_fees_to_treasury_marker(): WithdrawFeesToTreasury { WithdrawFeesToTreasury {} }
public fun add_verification_level_marker(): AddVerificationLevel { AddVerificationLevel {} }
public fun remove_verification_level_marker(): RemoveVerificationLevel { RemoveVerificationLevel {} }
public fun add_coin_fee_config_marker(): AddCoinFeeConfig { AddCoinFeeConfig {} }
public fun update_coin_creation_fee_marker(): UpdateCoinCreationFee { UpdateCoinCreationFee {} }
public fun update_coin_proposal_fee_marker(): UpdateCoinProposalFee { UpdateCoinProposalFee {} }
public fun apply_pending_coin_fees_marker(): ApplyPendingCoinFees { ApplyPendingCoinFees {} }
public fun disable_factory_permanently_marker(): DisableFactoryPermanently { DisableFactoryPermanently {} }

// === Errors ===
const EInvalidAdminCap: u64 = 1;
const ECapNotFound: u64 = 2;
const EInvalidFeeAmount: u64 = 3;
const EUnsupportedActionVersion: u64 = 4;

// === Events ===

// === Action Structs ===

// Factory Admin Actions

/// Pause or unpause the factory
public struct SetFactoryPausedAction has store, drop {
    paused: bool,
}

/// Permanently disable the factory - CANNOT BE REVERSED
public struct DisableFactoryPermanentlyAction has store, drop {
    // No fields needed - this is a one-way operation
}

/// Add a stable coin type to the factory whitelist
public struct AddStableTypeAction has store, drop {
    stable_type: TypeName,
}

/// Remove a stable coin type from the factory whitelist
public struct RemoveStableTypeAction has store, drop {
    stable_type: TypeName,
}

// Fee Admin Actions

/// Update the DAO creation fee
public struct UpdateDaoCreationFeeAction has store, drop {
    new_fee: u64,
}

/// Update the proposal creation fee per outcome
public struct UpdateProposalFeeAction has store, drop {
    new_fee_per_outcome: u64,
}

/// Update verification fee for a specific level
public struct UpdateVerificationFeeAction has store, drop {
    level: u8,
    new_fee: u64,
}

/// Add a new verification level with fee
public struct AddVerificationLevelAction has store, drop {
    level: u8,
    fee: u64,
}

/// Remove a verification level
public struct RemoveVerificationLevelAction has store, drop {
    level: u8,
}

/// Withdraw accumulated fees to treasury
public struct WithdrawFeesToTreasuryAction has store, drop {
    amount: u64,
}

// Coin-specific fee actions

/// Add a new coin type with fee configuration
public struct AddCoinFeeConfigAction has store, drop {
    coin_type: TypeName,
    decimals: u8,
    dao_creation_fee: u64,
    proposal_fee_per_outcome: u64,
}

/// Update creation fee for a specific coin type (with 6-month delay)
public struct UpdateCoinCreationFeeAction has store, drop {
    coin_type: TypeName,
    new_fee: u64,
}

/// Update proposal fee for a specific coin type (with 6-month delay)
public struct UpdateCoinProposalFeeAction has store, drop {
    coin_type: TypeName,
    new_fee_per_outcome: u64,
}

// === Public Functions ===

// Factory Actions

public fun new_set_factory_paused(paused: bool): SetFactoryPausedAction {
    SetFactoryPausedAction { paused }
}

public fun new_disable_factory_permanently(): DisableFactoryPermanentlyAction {
    DisableFactoryPermanentlyAction {}
}

public fun new_add_stable_type(stable_type: TypeName): AddStableTypeAction {
    AddStableTypeAction { stable_type }
}

public fun new_remove_stable_type(stable_type: TypeName): RemoveStableTypeAction {
    RemoveStableTypeAction { stable_type }
}

// Fee Actions

public fun new_update_dao_creation_fee(new_fee: u64): UpdateDaoCreationFeeAction {
    UpdateDaoCreationFeeAction { new_fee }
}

public fun new_update_proposal_fee(new_fee_per_outcome: u64): UpdateProposalFeeAction {
    UpdateProposalFeeAction { new_fee_per_outcome }
}

public fun new_update_verification_fee(level: u8, new_fee: u64): UpdateVerificationFeeAction {
    UpdateVerificationFeeAction { level, new_fee }
}

public fun new_add_verification_level(level: u8, fee: u64): AddVerificationLevelAction {
    AddVerificationLevelAction { level, fee }
}

public fun new_remove_verification_level(level: u8): RemoveVerificationLevelAction {
    RemoveVerificationLevelAction { level }
}

public fun new_withdraw_fees_to_treasury(amount: u64): WithdrawFeesToTreasuryAction {
    WithdrawFeesToTreasuryAction { amount }
}

// Coin-specific fee constructors

public fun new_add_coin_fee_config(
    coin_type: TypeName,
    decimals: u8,
    dao_creation_fee: u64,
    proposal_fee_per_outcome: u64,
): AddCoinFeeConfigAction {
    AddCoinFeeConfigAction {
        coin_type,
        decimals,
        dao_creation_fee,
        proposal_fee_per_outcome,
    }
}

public fun new_update_coin_creation_fee(
    coin_type: TypeName,
    new_fee: u64,
): UpdateCoinCreationFeeAction {
    UpdateCoinCreationFeeAction { coin_type, new_fee }
}

public fun new_update_coin_proposal_fee(
    coin_type: TypeName,
    new_fee_per_outcome: u64,
): UpdateCoinProposalFeeAction {
    UpdateCoinProposalFeeAction { coin_type, new_fee_per_outcome }
}

public fun new_apply_pending_coin_fees(
    coin_type: TypeName,
): ApplyPendingCoinFeesAction {
    ApplyPendingCoinFeesAction { coin_type }
}

// === Execution Functions ===

/// Execute factory pause/unpause action
public fun do_set_factory_paused<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version: VersionWitness,
    witness: IW,
    factory: &mut Factory,
    ctx: &mut TxContext,
) {
    // Get spec and validate type BEFORE deserialization
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));
    action_validation::assert_action_type<SetFactoryPaused>(spec);

    // Deserialize the action data
    let action_data = intents::action_spec_data(spec);
    let mut bcs = bcs::new(*action_data);
    let paused = bcs::peel_bool(&mut bcs);
    bcs_validation::validate_all_bytes_consumed(bcs);
    let action = SetFactoryPausedAction { paused };

    // Increment action index
    executable::increment_action_idx(executable);

    let _ = ctx;
    
    let cap = account::borrow_managed_asset<String, FactoryOwnerCap>(
        account,
        registry, b"protocol:factory_owner_cap".to_string(),
        version
    );
    
    // Toggle pause state if action says to pause and factory is unpaused, or vice versa
    if ((action.paused && !factory::is_paused(factory)) ||
        (!action.paused && factory::is_paused(factory))) {
        factory::toggle_pause(factory, cap);
    }
}

/// Execute permanent factory disable action - THIS CANNOT BE REVERSED
public fun do_disable_factory_permanently<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version: VersionWitness,
    witness: IW,
    factory: &mut Factory,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Get spec and validate type BEFORE deserialization
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));
    action_validation::assert_action_type<DisableFactoryPermanently>(spec);

    // Check version
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Validate action_data is empty (no fields)
    let action_data = intents::action_spec_data(spec);
    let bcs = bcs::new(*action_data);
    bcs_validation::validate_all_bytes_consumed(bcs);

    // No deserialization needed - action has no fields
    let _action = DisableFactoryPermanentlyAction {};

    // Increment action index
    executable::increment_action_idx(executable);

    let _ = witness;

    let cap = account::borrow_managed_asset<String, FactoryOwnerCap>(
        account,
        registry, b"protocol:factory_owner_cap".to_string(),
        version
    );

    // Permanently disable the factory - THIS CANNOT BE UNDONE
    factory::disable_permanently(factory, cap, clock, ctx);
}

/// Execute add stable type action
public fun do_add_stable_type<Outcome: store, IW: drop, StableType>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version: VersionWitness,
    witness: IW,
    factory: &mut Factory,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Get spec and validate type BEFORE deserialization
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));
    action_validation::assert_action_type<AddStableType>(spec);

    // Check version
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Validate action_data is empty (type comes from generic parameter)
    let action_data = intents::action_spec_data(spec);
    let bcs = bcs::new(*action_data);
    bcs_validation::validate_all_bytes_consumed(bcs);

    // Create action with generic type
    let stable_type = type_name::get<StableType>();
    let action = AddStableTypeAction { stable_type };

    // Increment action index
    executable::increment_action_idx(executable);
    
    let cap = account::borrow_managed_asset<String, FactoryOwnerCap>(
        account,
        registry, b"protocol:factory_owner_cap".to_string(),
        version
    );
    
    factory::add_allowed_stable_type<StableType>(factory, cap, clock, ctx);
}

/// Execute remove stable type action
public fun do_remove_stable_type<Outcome: store, IW: drop, StableType>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version: VersionWitness,
    witness: IW,
    factory: &mut Factory,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Get spec and validate type BEFORE deserialization
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));
    action_validation::assert_action_type<RemoveStableType>(spec);

    // Check version
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Validate action_data is empty (type comes from generic parameter)
    let action_data = intents::action_spec_data(spec);
    let bcs = bcs::new(*action_data);
    bcs_validation::validate_all_bytes_consumed(bcs);

    // Create action with generic type
    let stable_type = type_name::get<StableType>();
    let action = RemoveStableTypeAction { stable_type };

    // Increment action index
    executable::increment_action_idx(executable);
    
    let cap = account::borrow_managed_asset<String, FactoryOwnerCap>(
        account,
        registry, b"protocol:factory_owner_cap".to_string(),
        version
    );
    
    factory::remove_allowed_stable_type<StableType>(factory, cap, clock, ctx);
}

/// Execute update DAO creation fee action
public fun do_update_dao_creation_fee<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version: VersionWitness,
    witness: IW,
    fee_manager: &mut FeeManager,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Get spec and validate type BEFORE deserialization
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));
    action_validation::assert_action_type<UpdateDaoCreationFee>(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Deserialize the action data
    let action_data = intents::action_spec_data(spec);
    let mut bcs = bcs::new(*action_data);
    let new_fee = bcs::peel_u64(&mut bcs);
    bcs_validation::validate_all_bytes_consumed(bcs);
    let action = UpdateDaoCreationFeeAction { new_fee };

    // Increment action index
    executable::increment_action_idx(executable);
    
    let cap = account::borrow_managed_asset<String, FeeAdminCap>(
        account,
        registry, b"protocol:fee_admin_cap".to_string(),
        version
    );
    
    fee::update_dao_creation_fee(fee_manager, cap, action.new_fee, clock, ctx);
}

/// Execute update proposal fee action
public fun do_update_proposal_fee<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version: VersionWitness,
    witness: IW,
    fee_manager: &mut FeeManager,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Get spec and validate type BEFORE deserialization
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));
    action_validation::assert_action_type<UpdateProposalFee>(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Deserialize the action data
    let action_data = intents::action_spec_data(spec);
    let mut bcs = bcs::new(*action_data);
    let new_fee_per_outcome = bcs::peel_u64(&mut bcs);
    bcs_validation::validate_all_bytes_consumed(bcs);
    let action = UpdateProposalFeeAction { new_fee_per_outcome };

    // Increment action index
    executable::increment_action_idx(executable);

    let cap = account::borrow_managed_asset<String, FeeAdminCap>(
        account,
        registry, b"protocol:fee_admin_cap".to_string(),
        version
    );

    fee::update_proposal_creation_fee(
        fee_manager,
        cap,
        action.new_fee_per_outcome,
        clock,
        ctx
    );
}

/// Execute update verification fee action
public fun do_update_verification_fee<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version: VersionWitness,
    witness: IW,
    fee_manager: &mut FeeManager,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Get spec and validate type BEFORE deserialization
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));
    action_validation::assert_action_type<UpdateVerificationFee>(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Deserialize the action data
    let action_data = intents::action_spec_data(spec);
    let mut bcs = bcs::new(*action_data);
    let level = bcs::peel_u8(&mut bcs);
    let new_fee = bcs::peel_u64(&mut bcs);
    bcs_validation::validate_all_bytes_consumed(bcs);
    let action = UpdateVerificationFeeAction { level, new_fee };

    // Increment action index
    executable::increment_action_idx(executable);
    
    let cap = account::borrow_managed_asset<String, FeeAdminCap>(
        account,
        registry, b"protocol:fee_admin_cap".to_string(),
        version
    );
    
    fee::update_verification_fee(
        fee_manager,
        cap,
        action.level,
        action.new_fee,
        clock,
        ctx
    );
}

/// Execute add verification level action
public fun do_add_verification_level<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version: VersionWitness,
    witness: IW,
    fee_manager: &mut FeeManager,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Get spec and validate type BEFORE deserialization
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));
    action_validation::assert_action_type<AddVerificationLevel>(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Deserialize the action data
    let action_data = intents::action_spec_data(spec);
    let mut bcs = bcs::new(*action_data);
    let level = bcs::peel_u8(&mut bcs);
    let fee = bcs::peel_u64(&mut bcs);
    bcs_validation::validate_all_bytes_consumed(bcs);
    let action = AddVerificationLevelAction { level, fee };

    // Increment action index
    executable::increment_action_idx(executable);
    
    let cap = account::borrow_managed_asset<String, FeeAdminCap>(
        account,
        registry, b"protocol:fee_admin_cap".to_string(),
        version
    );
    
    fee::add_verification_level(fee_manager, cap, action.level, action.fee, clock, ctx);
}

/// Execute remove verification level action
public fun do_remove_verification_level<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version: VersionWitness,
    witness: IW,
    fee_manager: &mut FeeManager,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Get spec and validate type BEFORE deserialization
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));
    action_validation::assert_action_type<RemoveVerificationLevel>(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Deserialize the action data
    let action_data = intents::action_spec_data(spec);
    let mut bcs = bcs::new(*action_data);
    let level = bcs::peel_u8(&mut bcs);
    bcs_validation::validate_all_bytes_consumed(bcs);
    let action = RemoveVerificationLevelAction { level };

    // Increment action index
    executable::increment_action_idx(executable);

    let cap = account::borrow_managed_asset<String, FeeAdminCap>(
        account,
        registry, b"protocol:fee_admin_cap".to_string(),
        version
    );

    fee::remove_verification_level(fee_manager, cap, action.level, clock, ctx);
}

/// Execute withdraw fees to treasury action
public fun do_withdraw_fees_to_treasury<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version: VersionWitness,
    witness: IW,
    fee_manager: &mut FeeManager,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Get spec and validate type BEFORE deserialization
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));
    action_validation::assert_action_type<WithdrawFeesToTreasury>(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Deserialize the action data
    let action_data = intents::action_spec_data(spec);
    let mut bcs = bcs::new(*action_data);
    let amount = bcs::peel_u64(&mut bcs);
    bcs_validation::validate_all_bytes_consumed(bcs);
    let action = WithdrawFeesToTreasuryAction { amount };

    // Increment action index
    executable::increment_action_idx(executable);
    
    let cap = account::borrow_managed_asset<String, FeeAdminCap>(
        account,
        registry, b"protocol:fee_admin_cap".to_string(),
        version
    );
    
    // Withdraw all fees from the fee manager
    fee::withdraw_all_fees(fee_manager, cap, clock, ctx);
    // Note: The withdraw_all_fees function transfers directly to sender
    // In a proper implementation, we would need a function that returns the coin
    // for deposit into the DAO treasury
}

// Coin-specific fee execution functions

/// Execute action to add a coin fee configuration
public fun do_add_coin_fee_config<Outcome: store, IW: drop, StableType>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version: VersionWitness,
    witness: IW,
    fee_manager: &mut FeeManager,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Get spec and validate type BEFORE deserialization
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));
    action_validation::assert_action_type<AddCoinFeeConfig>(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Deserialize the action data
    let action_data = intents::action_spec_data(spec);
    let mut bcs = bcs::new(*action_data);
    let decimals = bcs::peel_u8(&mut bcs);
    let dao_creation_fee = bcs::peel_u64(&mut bcs);
    let proposal_fee_per_outcome = bcs::peel_u64(&mut bcs);
    bcs_validation::validate_all_bytes_consumed(bcs);
    let action = AddCoinFeeConfigAction {
        coin_type: type_name::get<StableType>(),
        decimals,
        dao_creation_fee,
        proposal_fee_per_outcome,
    };

    // Increment action index
    executable::increment_action_idx(executable);

    let cap = account::borrow_managed_asset<String, FeeAdminCap>(
        account,
        registry, b"protocol:fee_admin_cap".to_string(),
        version
    );

    fee::add_coin_fee_config(
        fee_manager,
        cap,
        action.coin_type,
        action.decimals,
        action.dao_creation_fee,
        action.proposal_fee_per_outcome,
        clock,
        ctx
    );
}

/// Execute action to update coin creation fee
public fun do_update_coin_creation_fee<Outcome: store, IW: drop, StableType>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version: VersionWitness,
    witness: IW,
    fee_manager: &mut FeeManager,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Get spec and validate type BEFORE deserialization
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));
    action_validation::assert_action_type<UpdateCoinCreationFee>(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Deserialize the action data
    let action_data = intents::action_spec_data(spec);
    let mut bcs = bcs::new(*action_data);
    let new_fee = bcs::peel_u64(&mut bcs);
    bcs_validation::validate_all_bytes_consumed(bcs);
    let action = UpdateCoinCreationFeeAction { coin_type: type_name::get<StableType>(), new_fee };

    // Increment action index
    executable::increment_action_idx(executable);
    
    let cap = account::borrow_managed_asset<String, FeeAdminCap>(
        account,
        registry, b"protocol:fee_admin_cap".to_string(),
        version
    );
    
    fee::update_coin_creation_fee(
        fee_manager,
        cap,
        action.coin_type,
        action.new_fee,
        clock,
        ctx
    );
}

/// Execute action to update coin proposal fee
public fun do_update_coin_proposal_fee<Outcome: store, IW: drop, StableType>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version: VersionWitness,
    witness: IW,
    fee_manager: &mut FeeManager,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Get spec and validate type BEFORE deserialization
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));
    action_validation::assert_action_type<UpdateCoinProposalFee>(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Deserialize the action data
    let action_data = intents::action_spec_data(spec);
    let mut bcs = bcs::new(*action_data);
    let new_fee_per_outcome = bcs::peel_u64(&mut bcs);
    bcs_validation::validate_all_bytes_consumed(bcs);
    let action = UpdateCoinProposalFeeAction { coin_type: type_name::get<StableType>(), new_fee_per_outcome };

    // Increment action index
    executable::increment_action_idx(executable);
    
    let cap = account::borrow_managed_asset<String, FeeAdminCap>(
        account,
        registry, b"protocol:fee_admin_cap".to_string(),
        version
    );
    
    fee::update_coin_proposal_fee(
        fee_manager,
        cap,
        action.coin_type,
        action.new_fee_per_outcome,
        clock,
        ctx
    );
}

/// Action to apply pending coin fee configuration after delay
public struct ApplyPendingCoinFeesAction has store, drop {
    coin_type: TypeName,
}

/// Execute action to apply pending coin fees after delay
public fun do_apply_pending_coin_fees<Outcome: store, IW: drop, StableType>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version: VersionWitness,
    witness: IW,
    fee_manager: &mut FeeManager,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Get spec and validate type BEFORE deserialization
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));
    action_validation::assert_action_type<ApplyPendingCoinFees>(spec);

    // Check version
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Validate action_data is empty (type comes from generic parameter)
    let action_data = intents::action_spec_data(spec);
    let bcs = bcs::new(*action_data);
    bcs_validation::validate_all_bytes_consumed(bcs);

    // This action has no parameters
    let action = ApplyPendingCoinFeesAction { coin_type: type_name::get<StableType>() };

    // Increment action index
    executable::increment_action_idx(executable);
    let _ = account;
    let _ = version;
    let _ = ctx;
    
    // No admin cap needed - anyone can apply pending fees after delay
    fee::apply_pending_coin_fees(
        fee_manager,
        action.coin_type,
        clock
    );
}

// === Garbage Collection ===

/// Delete protocol admin action from expired intent
public fun delete_protocol_admin_action(expired: &mut account_protocol::intents::Expired) {
    let action_spec = account_protocol::intents::remove_action_spec(expired);
    let _ = action_spec;
}// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// DAO Dissolution and Redemption System
///
/// Enables terminated DAOs to distribute assets proportionally to token holders
/// without transferring assets out of the Account.
///
/// Flow:
/// 1. DAO passes proposal to create DissolutionCapability (with time delay)
/// 2. After unlock time, anyone can redeem asset tokens for pro-rata vault balances
/// 3. Redemption burns asset tokens and withdraws proportionally from vaults
///
/// Safety:
/// - Capability is immutable once created
/// - Time-locked to allow auctions/settlements
/// - Only works on TERMINATED DAOs
/// - Pro-rata calculation prevents draining
/// - Each redemption is atomic and proportional

module futarchy_actions::dissolution_actions;

use account_actions::currency;
use account_actions::vault;
use account_protocol::account::{Self, Account};
use account_protocol::bcs_validation;
use account_protocol::executable::{Self, Executable};
use account_protocol::intents;
use account_protocol::action_validation;
use account_protocol::package_registry::PackageRegistry;
use account_protocol::version_witness::VersionWitness;
use futarchy_core::futarchy_config::{Self, FutarchyConfig};
use futarchy_core::version;
use std::string::String;
use std::type_name;
use sui::bcs;
use sui::clock::Clock;
use sui::coin::Coin;
use sui::event;
use sui::object::{Self, ID, UID};
use sui::transfer;

// === Errors ===

const ENotTerminated: u64 = 0;
const EWrongAccount: u64 = 1;
const ETooEarly: u64 = 2;
const ECapabilityAlreadyExists: u64 = 3;
const EInvalidUnlockDelay: u64 = 4;
const EZeroSupply: u64 = 5;
const EWrongAssetType: u64 = 6;

// === Action Type Markers ===

public struct CreateDissolutionCapability has drop {}

// === Marker Functions ===

public fun create_dissolution_capability_marker(): CreateDissolutionCapability { CreateDissolutionCapability {} }

// === Structs ===

/// Shared capability proving a DAO is dissolved and ready for redemption
/// Created via governance proposal, becomes active after time delay
public struct DissolutionCapability has key {
    id: UID,
    /// Address of the dissolved DAO Account
    dao_address: address,
    /// When the capability was created (for audit trail)
    created_at_ms: u64,
    /// When redemption becomes available (time-locked)
    unlock_at_ms: u64,
    /// Total asset supply at dissolution (for pro-rata calculation)
    /// Captured from TreasuryCap.total_supply() at creation
    total_asset_supply: u64,
}

// === Events ===

/// Emitted when a dissolution capability is created
public struct DissolutionCapabilityCreated has copy, drop {
    capability_id: ID,
    dao_address: address,
    created_at_ms: u64,
    unlock_at_ms: u64,
    total_asset_supply: u64,
}

/// Emitted when a user redeems tokens
public struct Redemption has copy, drop {
    capability_id: ID,
    user: address,
    asset_amount_burned: u64,
    coin_type_redeemed: String,
    coin_amount_received: u64,
    vault_name: String,
}

// === Public Functions ===

/// Permissionless creation of dissolution capability
/// Anyone can call this after DAO is terminated
/// Reads dissolution parameters from DAO config (set during termination)
///
/// SAFETY:
/// - Only works on terminated DAOs
/// - Validates AssetType matches DAO's configured asset
/// - Parameters come from DAO governance decision (can't be manipulated)
/// - Creates immutable capability with time lock
/// - Can only be called once (prevents multiple capability creation)
public fun create_capability_if_terminated<AssetType>(
    account: &mut Account,
    registry: &PackageRegistry,
    ctx: &mut TxContext,
) {
    // Extract all data we need and validate
    let (unlock_at_ms, terminated_at_ms) = {
        let dao_state = futarchy_config::state_mut_from_account(account, registry);

        // Verify DAO is terminated
        assert!(
            futarchy_config::operational_state(dao_state) == futarchy_config::state_terminated(),
            ENotTerminated
        );

        // Check that capability hasn't been created yet (prevent duplicate creation)
        assert!(
            !futarchy_config::dissolution_capability_created(dao_state),
            ECapabilityAlreadyExists
        );

        // Get dissolution unlock time from config (set during termination)
        let unlock_time_option = futarchy_config::dissolution_unlock_time(dao_state);
        assert!(unlock_time_option.is_some(), ENotTerminated); // Should have been set during termination

        let unlock_ms = *unlock_time_option.borrow();
        let terminated_ms = *futarchy_config::terminated_at(dao_state).borrow();

        // Mark that capability has been created (prevents future calls)
        futarchy_config::mark_dissolution_capability_created(dao_state);

        (unlock_ms, terminated_ms)
    }; // dao_state borrow dropped here

    // CRITICAL: Validate AssetType matches DAO's configured asset type
    // This prevents attackers from creating capabilities with arbitrary token types
    let config = account::config<FutarchyConfig>(account);
    let expected_asset_type = futarchy_config::asset_type(config);
    let actual_asset_type = type_name::with_defining_ids<AssetType>().into_string().to_string();
    assert!(expected_asset_type == &actual_asset_type, EWrongAssetType);

    // Get total asset supply from TreasuryCap
    let total_supply = currency::coin_type_supply<AssetType>(account, registry);
    assert!(total_supply > 0, EZeroSupply);

    // Create capability with parameters from DAO config
    let capability = DissolutionCapability {
        id: object::new(ctx),
        dao_address: account.addr(),
        created_at_ms: terminated_at_ms,  // Use termination time, not creation time
        unlock_at_ms,
        total_asset_supply: total_supply,
    };

    let capability_id = object::id(&capability);

    // Emit creation event
    event::emit(DissolutionCapabilityCreated {
        capability_id,
        dao_address: account.addr(),
        created_at_ms: terminated_at_ms,
        unlock_at_ms,
        total_asset_supply: total_supply,
    });

    // Share the capability so anyone can use it for redemption
    transfer::share_object(capability);
}

/// Check if a dissolution capability exists for a DAO
public fun has_capability(dao_address: address): bool {
    // Note: This would require a registry or dynamic field
    // For now, caller must track capability ID
    // Alternative: store capability ID in DAO config
    false // Placeholder - implement registry if needed
}

/// Get capability info for display/verification
public fun capability_info(cap: &DissolutionCapability): (address, u64, u64, u64) {
    (cap.dao_address, cap.created_at_ms, cap.unlock_at_ms, cap.total_asset_supply)
}

/// Check if capability is unlocked and ready for redemption
public fun is_unlocked(cap: &DissolutionCapability, clock: &Clock): bool {
    clock.timestamp_ms() >= cap.unlock_at_ms
}

/// Redeem asset tokens for a specific coin type from a specific vault
///
/// This is the core permissionless redemption function.
/// Users call this to burn their asset tokens and receive pro-rata share
/// of any coin type held in the DAO's vaults.
///
/// Safety:
/// - Verifies capability matches DAO
/// - Checks time lock has passed
/// - Confirms DAO still terminated
/// - Burns asset tokens before withdrawal
/// - Calculates exact pro-rata share
///
/// Note: Users can call this multiple times for different coin types
public fun redeem<Config: store, AssetType, RedeemCoinType: drop>(
    capability: &DissolutionCapability,
    account: &mut Account,
    registry: &PackageRegistry,
    asset_coins: Coin<AssetType>,
    vault_name: String,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<RedeemCoinType> {
    // === Safety Checks ===

    // 1. Verify capability matches this DAO account
    assert!(capability.dao_address == account.addr(), EWrongAccount);

    // 2. Verify time lock has passed
    assert!(clock.timestamp_ms() >= capability.unlock_at_ms, ETooEarly);

    // 3. Verify DAO is still terminated (can't be reactivated)
    verify_terminated(account, registry);

    // 4. Verify non-zero supply (safety check)
    assert!(capability.total_asset_supply > 0, EZeroSupply);

    // === Calculate Pro-Rata Share ===

    let asset_amount = asset_coins.value();

    // Get current vault balance for this coin type
    let vault_balance = vault::balance<Config, RedeemCoinType>(account, registry, vault_name);

    // Calculate user's proportional share using u128 to prevent overflow
    let share_numerator = (asset_amount as u128);
    let share_denominator = (capability.total_asset_supply as u128);
    let vault_balance_u128 = (vault_balance as u128);

    let redeem_amount = (vault_balance_u128 * share_numerator / share_denominator) as u64;

    // === Burn Asset Tokens ===

    // Burn user's asset tokens using permissionless public_burn
    currency::public_burn<Config, AssetType>(account, registry, asset_coins);

    // === Withdraw Pro-Rata Share ===

    // Withdraw from vault using permissionless withdrawal (no Auth required)
    // Pass DAO address for verification
    let redeemed_coin = vault::withdraw_permissionless<Config, RedeemCoinType>(
        account,
        registry,
        capability.dao_address,
        vault_name,
        redeem_amount,
        ctx,
    );

    // === Emit Event ===

    event::emit(Redemption {
        capability_id: object::id(capability),
        user: ctx.sender(),
        asset_amount_burned: asset_amount,
        coin_type_redeemed: type_name::with_defining_ids<RedeemCoinType>().into_string().to_string(),
        coin_amount_received: redeem_amount,
        vault_name,
    });

    redeemed_coin
}

// === Helper Functions ===

/// Verify DAO is in TERMINATED state
/// Aborts if not terminated
fun verify_terminated(account: &Account, registry: &PackageRegistry) {
    let dao_state = account::borrow_managed_data(
        account,
        registry,
        futarchy_config::new_dao_state_key(),
        version::current()
    );
    let operational_state = futarchy_config::operational_state(dao_state);
    let terminated_state = futarchy_config::state_terminated();
    assert!(operational_state == terminated_state, ENotTerminated);
}

// === Action Structs for Proposal System ===

/// Action data for creating a dissolution capability
/// Note: This is typically called permissionlessly AFTER termination,
/// but can also be included in the termination proposal itself
public struct CreateDissolutionCapabilityAction<phantom AssetType> has store, drop, copy {
    // Empty - all parameters come from DAO config set during termination
}

// === Action Constructors ===

/// Create action for proposal system
public fun new_create_dissolution_capability<AssetType>(): CreateDissolutionCapabilityAction<AssetType> {
    CreateDissolutionCapabilityAction {}
}

// === Execution Functions (for Proposal System) ===

/// Execute create dissolution capability action from proposal
/// This allows dissolution capability creation to be bundled with termination proposal
public fun do_create_dissolution_capability<AssetType, Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    _version: VersionWitness,
    _witness: IW,
    ctx: &mut TxContext,
) {
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));
    action_validation::assert_action_type<CreateDissolutionCapability>(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, 0); // EUnsupportedActionVersion

    let action_data = intents::action_spec_data(spec);
    let mut reader = bcs::new(*action_data);

    // No fields to deserialize - empty action
    bcs_validation::validate_all_bytes_consumed(reader);

    // Execute capability creation (permissionless function)
    create_capability_if_terminated<AssetType>(
        account,
        registry,
        ctx,
    );

    executable::increment_action_idx(executable);
}

// === Garbage Collection (Delete Functions for Expired Intents) ===

/// Delete create dissolution capability action from expired intent
public fun delete_create_dissolution_capability<AssetType>(expired: &mut intents::Expired) {
    let action_spec = intents::remove_action_spec(expired);
    let action_data = intents::action_spec_action_data(action_spec);
    let mut reader = bcs::new(action_data);

    // No fields to consume - empty action
    let _ = reader.into_remainder_bytes();
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Quota management action - set recurring proposal quotas for addresses
module futarchy_actions::quota_actions;

use std::vector;
use sui::{clock::Clock, bcs, object};
use account_protocol::{
    account::{Self, Account},
    executable::{Self, Executable},
    version_witness::VersionWitness,
    intents as protocol_intents,
    bcs_validation,
    action_validation,
};
use futarchy_core::{
    futarchy_config::FutarchyConfig,
    proposal_quota_registry::ProposalQuotaRegistry,
};

// === Action Type Markers ===

/// Set quotas for addresses
public struct SetQuotas has drop {}

// === Marker Functions ===

public fun set_quotas_marker(): SetQuotas { SetQuotas {} }

// === Errors ===
const EUnsupportedActionVersion: u64 = 0;

// === Structs ===

/// Action to set quotas for multiple addresses (batch operation)
/// Set quota_amount to 0 to remove quotas
public struct SetQuotasAction has store, drop {
    /// Addresses to set quota for
    users: vector<address>,
    /// N proposals per period (0 to remove)
    quota_amount: u64,
    /// Period in milliseconds (e.g., 30 days = 2_592_000_000)
    quota_period_ms: u64,
    /// Reduced fee (0 for free, ignored if removing)
    reduced_fee: u64,
    /// N sponsorships per period (0 to disable sponsorship for these users)
    sponsor_quota_amount: u64,
}

// === Public Functions ===

/// Execute set quotas action
public fun do_set_quotas<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &mut ProposalQuotaRegistry,
    version: VersionWitness,
    intent_witness: IW,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    // Get action spec
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));

    // CRITICAL - Type check BEFORE deserialization
    action_validation::assert_action_type<SetQuotas>(spec);

    // Get action data
    let action_data = protocol_intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = protocol_intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Deserialize action manually
    let mut reader = bcs::new(*action_data);

    // Deserialize vector<address>
    let users_count = reader.peel_vec_length();
    let mut users = vector::empty<address>();
    let mut i = 0;
    while (i < users_count) {
        users.push_back(reader.peel_address());
        i = i + 1;
    };

    // Deserialize quota parameters
    let quota_amount = reader.peel_u64();
    let quota_period_ms = reader.peel_u64();
    let reduced_fee = reader.peel_u64();
    let sponsor_quota_amount = reader.peel_u64();

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    // Create action struct
    let action = SetQuotasAction {
        users,
        quota_amount,
        quota_period_ms,
        reduced_fee,
        sponsor_quota_amount,
    };

    // Execute internal logic
    do_set_quotas_internal(account, registry, action, version, clock, _ctx);

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Internal version for actual execution
fun do_set_quotas_internal(
    account: &mut Account,
    registry: &mut ProposalQuotaRegistry,
    action: SetQuotasAction,
    _version: VersionWitness,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    // Destructure to consume the action
    let SetQuotasAction { users, quota_amount, quota_period_ms, reduced_fee, sponsor_quota_amount } = action;

    let dao_id = object::id(account);

    // Set proposal quotas with DAO ID check
    futarchy_core::proposal_quota_registry::set_quotas(
        registry,
        dao_id,
        users,
        quota_amount,
        quota_period_ms,
        reduced_fee,
        clock,
    );

    // Set sponsor quotas if quota_amount > 0 (only for active quota holders)
    // If quota_amount is 0, we're removing quotas, so don't set sponsor quota
    if (quota_amount > 0) {
        futarchy_core::proposal_quota_registry::set_sponsor_quotas(
            registry,
            dao_id,
            users,
            sponsor_quota_amount,
            clock,
        );
    };
}

// === Constructor Functions ===

/// Create a set quotas action
public fun new_set_quotas(
    users: vector<address>,
    quota_amount: u64,
    quota_period_ms: u64,
    reduced_fee: u64,
    sponsor_quota_amount: u64,
): SetQuotasAction {
    SetQuotasAction {
        users,
        quota_amount,
        quota_period_ms,
        reduced_fee,
        sponsor_quota_amount,
    }
}

// === Garbage Collection ===

/// Delete a set quotas action from an expired intent
public fun delete_set_quotas(expired: &mut account_protocol::intents::Expired) {
    let action_spec = account_protocol::intents::remove_action_spec(expired);
    // Action spec has drop, so it's automatically cleaned up
    let _ = action_spec;
}

// === Getter Functions ===

public fun users(action: &SetQuotasAction): &vector<address> { &action.users }
public fun quota_amount(action: &SetQuotasAction): u64 { action.quota_amount }
public fun quota_period_ms(action: &SetQuotasAction): u64 { action.quota_period_ms }
public fun reduced_fee(action: &SetQuotasAction): u64 { action.reduced_fee }
public fun sponsor_quota_amount(action: &SetQuotasAction): u64 { action.sponsor_quota_amount }
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Consolidated configuration actions for futarchy DAOs
/// This module combines basic and advanced configuration actions and their execution logic
module futarchy_actions::config_actions;

// === Imports ===
use std::{
    string::{Self, String},
    ascii::{Self, String as AsciiString},
    option::{Self, Option},
    type_name,
};
use sui::{
    url::{Self, Url},
    event,
    object,
    clock::Clock,
    bcs::{Self, BCS},
};
use account_protocol::{
    account::{Self, Account},
    executable::{Self, Executable},
    intents::{Self, Expired, Intent},
    version_witness::VersionWitness,
    bcs_validation,
    package_registry::PackageRegistry,
};
use account_protocol::action_validation;
use futarchy_core::{
    futarchy_config::{Self, FutarchyConfig},
    dao_config,
};
use futarchy_types::signed::{Self as signed, SignedU128};

// === Action Type Markers ===

/// Set proposals enabled/disabled
public struct SetProposalsEnabled has drop {}
/// Terminate the DAO
public struct TerminateDao has drop {}
/// Update DAO name
public struct UpdateName has drop {}
/// Update trading parameters
public struct TradingParamsUpdate has drop {}
/// Update metadata
public struct MetadataUpdate has drop {}
/// Update TWAP configuration
public struct TwapConfigUpdate has drop {}
/// Update governance parameters
public struct GovernanceUpdate has drop {}
/// Update metadata table
public struct MetadataTableUpdate has drop {}
/// Update sponsorship configuration
public struct SponsorshipConfigUpdate has drop {}
/// Update conditional metadata
public struct UpdateConditionalMetadata has drop {}

// === Marker Functions ===

public fun set_proposals_enabled_marker(): SetProposalsEnabled { SetProposalsEnabled {} }
public fun terminate_dao_marker(): TerminateDao { TerminateDao {} }
public fun update_name_marker(): UpdateName { UpdateName {} }
public fun trading_params_update_marker(): TradingParamsUpdate { TradingParamsUpdate {} }
public fun metadata_update_marker(): MetadataUpdate { MetadataUpdate {} }
public fun twap_config_update_marker(): TwapConfigUpdate { TwapConfigUpdate {} }
public fun governance_update_marker(): GovernanceUpdate { GovernanceUpdate {} }
public fun metadata_table_update_marker(): MetadataTableUpdate { MetadataTableUpdate {} }
public fun sponsorship_config_update_marker(): SponsorshipConfigUpdate { SponsorshipConfigUpdate {} }
public fun update_conditional_metadata_marker(): UpdateConditionalMetadata { UpdateConditionalMetadata {} }

// === Aliases ===
use account_protocol::intents as protocol_intents;

// === Errors ===
const EEmptyName: u64 = 1;
const EInvalidParameter: u64 = 2;
const EEmptyString: u64 = 3;
const EMismatchedKeyValueLength: u64 = 4;
const EInvalidConfigType: u64 = 5;
const EWrongAction: u64 = 7;
const EUnsupportedActionVersion: u64 = 8;
const ENotActive: u64 = 9; // DAO must be in ACTIVE state for this operation
const EInvalidRatio: u64 = 10; // Invalid ratio or empty string

// === Witness ===

/// Witness for config module operations
public struct ConfigActionsWitness has drop {}

// === Constants ===
const CONFIG_TYPE_TRADING_PARAMS: u8 = 0;
const CONFIG_TYPE_METADATA: u8 = 1;
const CONFIG_TYPE_TWAP: u8 = 2;
const CONFIG_TYPE_GOVERNANCE: u8 = 3;
const CONFIG_TYPE_METADATA_TABLE: u8 = 4;

// === Events ===

/// Emitted when proposals are enabled or disabled
public struct ProposalsEnabledChanged has copy, drop {
    account_id: ID,
    enabled: bool,
    timestamp: u64,
}

/// Emitted when DAO is terminated (irreversible)
public struct DaoTerminated has copy, drop {
    account_id: ID,
    reason: String,
    timestamp: u64,
}

/// Emitted when DAO name is updated
public struct DaoNameChanged has copy, drop {
    account_id: ID,
    new_name: String,
    timestamp: u64,
}

/// Emitted when trading parameters are updated
public struct TradingParamsChanged has copy, drop {
    account_id: ID,
    timestamp: u64,
}

/// Emitted when metadata is updated
public struct MetadataChanged has copy, drop {
    account_id: ID,
    timestamp: u64,
}

/// Emitted when TWAP config is updated
public struct TwapConfigChanged has copy, drop {
    account_id: ID,
    timestamp: u64,
}

/// Emitted when governance settings are updated
public struct GovernanceSettingsChanged has copy, drop {
    account_id: ID,
    timestamp: u64,
}

/// Emitted when conditional metadata config is updated
public struct ConditionalMetadataChanged has copy, drop {
    account_id: ID,
    has_fallback_metadata: bool,
    use_outcome_index: bool,
    timestamp: u64,
}

/// Emitted when sponsorship config is updated
public struct SponsorshipConfigChanged has copy, drop {
    account_id: ID,
    enabled: bool,
    waive_advancement_fees: bool,
    timestamp: u64,
}

// === Basic Action Structs ===

/// Action to enable or disable proposals
/// This is a protocol-level action that should only be used in emergencies
/// It must go through the normal futarchy governance process
public struct SetProposalsEnabledAction has store, drop, copy {
    enabled: bool,
}

/// Action to permanently terminate the DAO
/// WARNING: This is IRREVERSIBLE - DAO cannot be reactivated after termination
/// Sets operational state to TERMINATED, blocking all new proposals
/// Existing proposals may still complete, but no new ones can be created
/// This must go through the normal futarchy governance process
public struct TerminateDaoAction has store, drop, copy {
    reason: String,  // Why DAO is being terminated (for transparency/audit trail)
    dissolution_unlock_delay_ms: u64,  // Time to wait before redemption opens (allows auctions/settlements)
}

/// Action to update the DAO name
/// This must go through the normal futarchy governance process
public struct UpdateNameAction has store, drop, copy {
    new_name: String,
}

// === Advanced Action Structs ===

/// Trading parameters update action
public struct TradingParamsUpdateAction has store, drop, copy {
    min_asset_amount: Option<u64>,
    min_stable_amount: Option<u64>,
    review_period_ms: Option<u64>,
    trading_period_ms: Option<u64>,
    amm_total_fee_bps: Option<u64>,
}

/// DAO metadata update action
public struct MetadataUpdateAction has store, drop, copy {
    dao_name: Option<AsciiString>,
    icon_url: Option<Url>,
    description: Option<String>,
}

/// TWAP configuration update action
public struct TwapConfigUpdateAction has store, drop, copy {
    start_delay: Option<u64>,
    step_max: Option<u64>,
    initial_observation: Option<u128>,
    threshold: Option<SignedU128>,
}

/// Governance settings update action
public struct GovernanceUpdateAction has store, drop, copy {
    max_outcomes: Option<u64>,
    max_actions_per_outcome: Option<u64>,
    required_bond_amount: Option<u64>,
    max_intents_per_outcome: Option<u64>,
    proposal_intent_expiry_ms: Option<u64>,
    optimistic_challenge_fee: Option<u64>,
    optimistic_challenge_period_ms: Option<u64>,
    proposal_creation_fee: Option<u64>,  // DAO-level proposal creation fee (in StableType)
    proposal_fee_per_outcome: Option<u64>, // DAO-level fee per additional outcome (in StableType)
    accept_new_proposals: Option<bool>,  // Enable/disable proposal creation
    enable_premarket_reservation_lock: Option<bool>, // Enable/disable premarket reservation lock
    show_proposal_details: Option<bool>, // Enable/disable showing proposal details in UI (default: false for security)
}

/// Metadata table update action
public struct MetadataTableUpdateAction has store, drop, copy {
    keys: vector<String>,
    values: vector<String>,
    keys_to_remove: vector<String>,
}

/// Conditional metadata configuration update action
public struct ConditionalMetadataUpdateAction has store, drop, copy {
    use_outcome_index: Option<bool>,
    // If Some(Some(metadata)), set fallback metadata to the inner value
    // If Some(None), remove fallback metadata
    // If None, don't change fallback metadata
    conditional_metadata: Option<Option<dao_config::ConditionalMetadata>>,
}

/// Sponsorship configuration update action
public struct SponsorshipConfigUpdateAction has store, drop, copy {
    enabled: Option<bool>,
    sponsored_threshold: Option<SignedU128>,
    waive_advancement_fees: Option<bool>,
    default_sponsor_quota_amount: Option<u64>,
}

/// Wrapper for different config action types (for batch operations)
public struct ConfigAction has store, drop, copy {
    config_type: u8,
    // Only one of these will be populated
    trading_params: Option<TradingParamsUpdateAction>,
    metadata: Option<MetadataUpdateAction>,
    twap_config: Option<TwapConfigUpdateAction>,
    governance: Option<GovernanceUpdateAction>,
    metadata_table: Option<MetadataTableUpdateAction>,
}

// === Basic Execution Functions ===

/// Execute a set proposals enabled action
public fun do_set_proposals_enabled<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version: VersionWitness,
    intent_witness: IW,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    // Get action spec
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));

    // CRITICAL - Type check BEFORE deserialization
    action_validation::assert_action_type<SetProposalsEnabled>(spec);

    // Get action data
    let action_data = protocol_intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = protocol_intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Safe deserialization with BCS reader
    let mut reader = bcs::new(*action_data);
    let enabled = reader.peel_bool();

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    // Get mutable config using internal function
    let config = futarchy_config::internal_config_mut(account, registry, version);

    // Apply the state change on the FutarchyConfig
    // For now, skip state modification since it requires Account access
    // This would need to be handled at a higher level with Account access
    let _ = enabled;

    // Emit event
    event::emit(ProposalsEnabledChanged {
        account_id: object::id(account),
        enabled,
        timestamp: clock.timestamp_ms(),
    });

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Internal version that works directly with action struct for init actions
public fun do_set_proposals_enabled_internal(
    account: &mut Account,
    registry: &PackageRegistry,
    action: SetProposalsEnabledAction,  // Take by value to consume
    version: VersionWitness,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    let SetProposalsEnabledAction { enabled } = action;  // Destructure to consume

    // Get mutable config using internal function
    let config = futarchy_config::internal_config_mut(account, registry, version);
    
    // Apply the state change on the FutarchyConfig
    // For now, skip state modification since it requires Account access
    // This would need to be handled at a higher level with Account access
    let _ = enabled;
    
    // Emit event
    event::emit(ProposalsEnabledChanged {
        account_id: object::id(account),
        enabled,
        timestamp: clock.timestamp_ms(),
    });
}

/// Execute a terminate DAO action
/// WARNING: This is IRREVERSIBLE - sets operational state to TERMINATED
public fun do_terminate_dao<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version: VersionWitness,
    intent_witness: IW,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    // Get action spec
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));

    // CRITICAL - Type check BEFORE deserialization
    action_validation::assert_action_type<TerminateDao>(spec);

    // Get action data
    let action_data = protocol_intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = protocol_intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Safe deserialization with BCS reader
    let mut reader = bcs::new(*action_data);
    let reason_bytes = reader.peel_vec_u8();
    let reason = string::utf8(reason_bytes);
    let dissolution_unlock_delay_ms = reader.peel_u64();

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    // Validate reason is not empty
    assert!(reason.length() > 0, EInvalidRatio);

    // Get dao state and verify we're currently active
    let dao_state = futarchy_config::state_mut_from_account(account, registry);
    assert!(
        futarchy_config::operational_state(dao_state) == futarchy_config::state_active(),
        ENotActive
    );

    // CRITICAL: This is irreversible - set to TERMINATED
    let terminated_at = clock.timestamp_ms();
    futarchy_config::set_operational_state(dao_state, futarchy_config::state_terminated());

    // Store dissolution parameters for later capability creation
    futarchy_config::set_dissolution_params(dao_state, terminated_at, dissolution_unlock_delay_ms);

    // Note: Proposal creation is disabled via state_terminated() above
    // The GovernanceConfig setters are package-private so we can't call them here

    // Emit event
    event::emit(DaoTerminated {
        account_id: object::id(account),
        reason,
        timestamp: clock.timestamp_ms(),
    });

    let _ = intent_witness;

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Execute an update name action
public fun do_update_name<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version: VersionWitness,
    intent_witness: IW,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    // Get action spec
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));

    // CRITICAL - Type check BEFORE deserialization
    action_validation::assert_action_type<UpdateName>(spec);

    // Get action data
    let action_data = protocol_intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = protocol_intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Safe deserialization with BCS reader
    let mut reader = bcs::new(*action_data);
    let new_name = string::utf8(reader.peel_vec_u8());

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    // Validate
    assert!(new_name.length() > 0, EEmptyName);

    // Get mutable config through Account protocol with witness
    let config = account::config_mut<FutarchyConfig, futarchy_config::ConfigWitness>(account, registry, version, futarchy_config::witness());

    // Update the name - futarchy_config expects a regular String
    futarchy_config::set_dao_name(config, new_name);

    // Emit event
    event::emit(DaoNameChanged {
        account_id: object::id(account),
        new_name,
        timestamp: clock.timestamp_ms(),
    });

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Internal version that works directly with action struct for init actions
public fun do_update_name_internal(
    account: &mut Account,
    registry: &PackageRegistry,
    action: UpdateNameAction,  // Already takes by value
    version: VersionWitness,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    // Destructure to consume the action
    let UpdateNameAction { new_name } = action;
    
    // Validate
    assert!(new_name.length() > 0, EEmptyName);
    
    // Get mutable config through Account protocol with witness
    let config = account::config_mut<FutarchyConfig, futarchy_config::ConfigWitness>(account, registry, version, futarchy_config::witness());
    
    // Update the name directly (set_dao_name handles conversion internally)
    futarchy_config::set_dao_name(config, new_name);
    
    // Emit event
    event::emit(DaoNameChanged {
        account_id: object::id(account),
        new_name,  // Use the destructured variable
        timestamp: clock.timestamp_ms(),
    });
}

// === Advanced Execution Functions ===

/// Execute a trading params update action
public fun do_update_trading_params<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version: VersionWitness,
    intent_witness: IW,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    // Get action spec
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));

    // CRITICAL - Type check BEFORE deserialization
    action_validation::assert_action_type<TradingParamsUpdate>(spec);

    // Get action data
    let action_data = protocol_intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = protocol_intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Safe deserialization with BCS reader
    let mut reader = bcs::new(*action_data);
    let min_asset_amount = reader.peel_option_u64();
    let min_stable_amount = reader.peel_option_u64();
    let review_period_ms = reader.peel_option_u64();
    let trading_period_ms = reader.peel_option_u64();
    let amm_total_fee_bps = reader.peel_option_u64();

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    // Create action struct for validation
    let action = TradingParamsUpdateAction {
        min_asset_amount,
        min_stable_amount,
        review_period_ms,
        trading_period_ms,
        amm_total_fee_bps,
    };

    // Validate parameters
    validate_trading_params_update(&action);

    // Get mutable config through Account protocol with witness
    let config = account::config_mut<FutarchyConfig, futarchy_config::ConfigWitness>(account, registry, version, futarchy_config::witness());

    // Apply updates if provided
    if (action.min_asset_amount.is_some()) {
        futarchy_config::set_min_asset_amount(config, *action.min_asset_amount.borrow());
    };
    if (action.min_stable_amount.is_some()) {
        futarchy_config::set_min_stable_amount(config, *action.min_stable_amount.borrow());
    };
    if (action.review_period_ms.is_some()) {
        futarchy_config::set_review_period_ms(config, *action.review_period_ms.borrow());
    };
    if (action.trading_period_ms.is_some()) {
        futarchy_config::set_trading_period_ms(config, *action.trading_period_ms.borrow());
    };
    if (action.amm_total_fee_bps.is_some()) {
        let fee_bps = (*action.amm_total_fee_bps.borrow() as u16);
        futarchy_config::set_conditional_amm_fee_bps(config, fee_bps);
        futarchy_config::set_spot_amm_fee_bps(config, fee_bps);
    };

    // Emit event
    event::emit(TradingParamsChanged {
        account_id: object::id(account),
        timestamp: clock.timestamp_ms(),
    });

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Execute a metadata update action
public fun do_update_metadata<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version: VersionWitness,
    intent_witness: IW,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    // Get action spec
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));

    // CRITICAL - Type check BEFORE deserialization
    action_validation::assert_action_type<MetadataUpdate>(spec);

    // Get action data
    let action_data = protocol_intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = protocol_intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Safe deserialization with BCS reader
    let mut reader = bcs::new(*action_data);
    let dao_name = if (reader.peel_bool()) {
        option::some(ascii::string(reader.peel_vec_u8()))
    } else {
        option::none()
    };
    let icon_url = if (reader.peel_bool()) {
        option::some(url::new_unsafe_from_bytes(reader.peel_vec_u8()))
    } else {
        option::none()
    };
    let description = if (reader.peel_bool()) {
        option::some(string::utf8(reader.peel_vec_u8()))
    } else {
        option::none()
    };

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    // Create action struct for validation
    let action = MetadataUpdateAction {
        dao_name,
        icon_url,
        description,
    };
    
    // Validate parameters
    validate_metadata_update(&action);
    
    // Get mutable config through Account protocol with witness
    let config = account::config_mut<FutarchyConfig, futarchy_config::ConfigWitness>(account, registry, version, futarchy_config::witness());
    
    // Apply updates if provided - convert types as needed
    if (action.dao_name.is_some()) {
        // Convert AsciiString to String
        let ascii_name = *action.dao_name.borrow();
        futarchy_config::set_dao_name(config, string::from_ascii(ascii_name));
    };
    if (action.icon_url.is_some()) {
        // Convert Url to String
        let url = *action.icon_url.borrow();
        futarchy_config::set_icon_url(config, string::from_ascii(url.inner_url()));
    };
    if (action.description.is_some()) {
        futarchy_config::set_description(config, *action.description.borrow());
    };
    
    // Emit event
    event::emit(MetadataChanged {
        account_id: object::id(account),
        timestamp: clock.timestamp_ms(),
    });

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Execute a TWAP config update action
public fun do_update_twap_config<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version: VersionWitness,
    intent_witness: IW,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    // Get action spec
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));

    // CRITICAL - Type check BEFORE deserialization
    action_validation::assert_action_type<TwapConfigUpdate>(spec);

    // Get action data
    let action_data = protocol_intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = protocol_intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Safe deserialization with BCS reader
    let mut reader = bcs::new(*action_data);
    let start_delay = reader.peel_option_u64();
    let step_max = reader.peel_option_u64();
    let initial_observation = reader.peel_option_u128();
    let threshold = bcs::peel_option!(&mut reader, |r| {
        let magnitude = r.peel_u128();
        let is_negative = r.peel_bool();
        signed::from_parts(magnitude, is_negative)
    });

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    // Create action struct for validation
    let action = TwapConfigUpdateAction {
        start_delay,
        step_max,
        initial_observation,
        threshold,
    };

    // Validate parameters
    validate_twap_config_update(&action);

    // Get mutable config through Account protocol with witness
    let config = account::config_mut<FutarchyConfig, futarchy_config::ConfigWitness>(account, registry, version, futarchy_config::witness());

    // Apply updates if provided
    if (action.start_delay.is_some()) {
        futarchy_config::set_amm_twap_start_delay(config, *action.start_delay.borrow());
    };
    if (action.step_max.is_some()) {
        futarchy_config::set_amm_twap_step_max(config, *action.step_max.borrow());
    };
    if (action.initial_observation.is_some()) {
        futarchy_config::set_amm_twap_initial_observation(config, *action.initial_observation.borrow());
    };
    if (action.threshold.is_some()) {
        futarchy_config::set_twap_threshold(config, *action.threshold.borrow());
    };

    // Emit event
    event::emit(TwapConfigChanged {
        account_id: object::id(account),
        timestamp: clock.timestamp_ms(),
    });

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Execute a governance update action
public fun do_update_governance<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version: VersionWitness,
    intent_witness: IW,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    // Get action spec
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));

    // CRITICAL - Type check BEFORE deserialization
    action_validation::assert_action_type<GovernanceUpdate>(spec);

    // Get action data
    let action_data = protocol_intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = protocol_intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Safe deserialization with BCS reader
    let mut reader = bcs::new(*action_data);
    let max_outcomes = reader.peel_option_u64();
    let max_actions_per_outcome = reader.peel_option_u64();
    let required_bond_amount = reader.peel_option_u64();
    let max_intents_per_outcome = reader.peel_option_u64();
    let proposal_intent_expiry_ms = reader.peel_option_u64();
    let optimistic_challenge_fee = reader.peel_option_u64();
    let optimistic_challenge_period_ms = reader.peel_option_u64();
    let proposal_creation_fee = reader.peel_option_u64();
    let proposal_fee_per_outcome = reader.peel_option_u64();
    let accept_new_proposals = reader.peel_option_bool();
    let enable_premarket_reservation_lock = reader.peel_option_bool();

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    // Create action struct for validation
    let action = GovernanceUpdateAction {
        max_outcomes,
        max_actions_per_outcome,
        required_bond_amount,
        max_intents_per_outcome,
        proposal_intent_expiry_ms,
        optimistic_challenge_fee,
        optimistic_challenge_period_ms,
        proposal_creation_fee,
        proposal_fee_per_outcome,
        accept_new_proposals,
        enable_premarket_reservation_lock,
        show_proposal_details: option::none(),
    };

    // Validate parameters
    validate_governance_update(&action);

    // Get mutable config through Account protocol with witness
    let config = account::config_mut<FutarchyConfig, futarchy_config::ConfigWitness>(account, registry, version, futarchy_config::witness());

    // Apply updates if provided
    if (action.max_outcomes.is_some()) {
        futarchy_config::set_max_outcomes(config, *action.max_outcomes.borrow());
    };
    if (action.max_actions_per_outcome.is_some()) {
        futarchy_config::set_max_actions_per_outcome(config, *action.max_actions_per_outcome.borrow());
    };
    // Note: set_required_bond_amount doesn't exist yet in futarchy_config
    // if (action.required_bond_amount.is_some()) {
    //     futarchy_config::set_required_bond_amount(config, *action.required_bond_amount.borrow());
    // };
    let _ = action.required_bond_amount;
    if (action.max_intents_per_outcome.is_some()) {
        futarchy_config::set_max_intents_per_outcome(config, *action.max_intents_per_outcome.borrow());
    };
    if (action.proposal_intent_expiry_ms.is_some()) {
        futarchy_config::set_proposal_intent_expiry_ms(config, *action.proposal_intent_expiry_ms.borrow());
    };
    // Note: optimistic_challenge_fee and optimistic_challenge_period_ms setters don't exist yet
    // These would need to be added to futarchy_config
    // For now, we skip these fields
    let _ = action.optimistic_challenge_fee;
    let _ = action.optimistic_challenge_period_ms;

    // Apply proposal fee updates if provided
    if (action.proposal_creation_fee.is_some()) {
        futarchy_config::set_proposal_creation_fee(config, *action.proposal_creation_fee.borrow());
    };
    if (action.proposal_fee_per_outcome.is_some()) {
        futarchy_config::set_proposal_fee_per_outcome(config, *action.proposal_fee_per_outcome.borrow());
    };
    if (action.accept_new_proposals.is_some()) {
        futarchy_config::set_accept_new_proposals(config, *action.accept_new_proposals.borrow());
    };
    if (action.enable_premarket_reservation_lock.is_some()) {
        futarchy_config::set_enable_premarket_reservation_lock(config, *action.enable_premarket_reservation_lock.borrow());
    };
    if (action.show_proposal_details.is_some()) {
        futarchy_config::set_show_proposal_details(config, *action.show_proposal_details.borrow());
    };

    // Emit event
    event::emit(GovernanceSettingsChanged {
        account_id: object::id(account),
        timestamp: clock.timestamp_ms(),
    });

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Execute a metadata table update action
/// Note: This requires metadata table support in futarchy_config which may not exist yet
public fun do_update_metadata_table<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version: VersionWitness,
    intent_witness: IW,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    // Get action spec
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));

    // CRITICAL - Type check BEFORE deserialization
    action_validation::assert_action_type<MetadataTableUpdate>(spec);

    // Get action data
    let action_data = protocol_intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = protocol_intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Safe deserialization with BCS reader
    let mut reader = bcs::new(*action_data);
    let keys = {
        let len = reader.peel_vec_length();
        let mut result = vector[];
        let mut i = 0;
        while (i < len) {
            result.push_back(string::utf8(reader.peel_vec_u8()));
            i = i + 1;
        };
        result
    };
    let values = {
        let len = reader.peel_vec_length();
        let mut result = vector[];
        let mut i = 0;
        while (i < len) {
            result.push_back(string::utf8(reader.peel_vec_u8()));
            i = i + 1;
        };
        result
    };
    let keys_to_remove = {
        let len = reader.peel_vec_length();
        let mut result = vector[];
        let mut i = 0;
        while (i < len) {
            result.push_back(string::utf8(reader.peel_vec_u8()));
            i = i + 1;
        };
        result
    };

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    // Create action struct for validation
    let action = MetadataTableUpdateAction {
        keys,
        values,
        keys_to_remove,
    };

    // Validate parameters
    assert!(action.keys.length() == action.values.length(), EMismatchedKeyValueLength);

    // Get mutable config through Account protocol with witness
    let config = account::config_mut<FutarchyConfig, futarchy_config::ConfigWitness>(account, registry, version, futarchy_config::witness());

    // Metadata table operations would be implemented here when available in futarchy_config
    // Currently, futarchy_config doesn't have a metadata table, so we validate the action
    // and emit the event to track the attempted change
    let _ = config;
    let _ = action;

    // Emit event
    event::emit(MetadataChanged {
        account_id: object::id(account),
        timestamp: clock.timestamp_ms(),
    });

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Update conditional metadata configuration
/// This controls how conditional token metadata is derived during proposal creation
public fun do_update_conditional_metadata<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version: VersionWitness,
    intent_witness: IW,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    // Get action spec
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));

    // CRITICAL - Type check BEFORE deserialization
    action_validation::assert_action_type<UpdateConditionalMetadata>(spec);

    // Get action data
    let action_data = protocol_intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = protocol_intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Safe deserialization with BCS reader
    let mut reader = bcs::new(*action_data);
    let use_outcome_index_opt = bcs::peel_option!(&mut reader, |r| r.peel_bool());
    let conditional_metadata_opt = bcs::peel_option!(&mut reader, |r| {
        bcs::peel_option!(r, |r2| {
            let decimals = r2.peel_u8();
            let coin_name_prefix = r2.peel_vec_u8().to_ascii_string();
            let icon_url_bytes = r2.peel_vec_u8().to_ascii_string();
            let coin_icon_url = url::new_unsafe(icon_url_bytes);
            dao_config::new_conditional_metadata(decimals, coin_name_prefix, coin_icon_url)
        })
    });

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    // Get account ID first before taking mutable borrows
    let account_id = object::id(account);

    // Get mutable config through Account protocol with witness
    let config = account::config_mut<FutarchyConfig, futarchy_config::ConfigWitness>(account, registry, version, futarchy_config::witness());

    // Apply updates using futarchy_config setters (standard pattern)
    if (use_outcome_index_opt.is_some()) {
        futarchy_config::set_use_outcome_index(config, use_outcome_index_opt.destroy_some());
    };

    if (conditional_metadata_opt.is_some()) {
        futarchy_config::set_conditional_metadata(config, conditional_metadata_opt.destroy_some());
    };

    // Get final values after updates
    let dao_cfg = futarchy_config::dao_config(config);
    let coin_cfg = dao_config::conditional_coin_config(dao_cfg);
    let final_use_outcome_index = dao_config::use_outcome_index(coin_cfg);
    let final_has_fallback = dao_config::conditional_metadata(coin_cfg).is_some();

    // Emit event
    event::emit(ConditionalMetadataChanged {
        account_id,
        has_fallback_metadata: final_has_fallback,
        use_outcome_index: final_use_outcome_index,
        timestamp: clock.timestamp_ms(),
    });

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Execute a sponsorship config update action
public fun do_update_sponsorship_config<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version: VersionWitness,
    intent_witness: IW,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    // Get action spec
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));

    // CRITICAL - Type check BEFORE deserialization
    action_validation::assert_action_type<SponsorshipConfigUpdate>(spec);

    // Get action data
    let action_data = protocol_intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = protocol_intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Safe deserialization with BCS reader
    let mut reader = bcs::new(*action_data);
    let enabled = reader.peel_option_bool();
    let sponsored_threshold = bcs::peel_option!(&mut reader, |r| {
        let magnitude = r.peel_u128();
        let is_negative = r.peel_bool();
        signed::from_parts(magnitude, is_negative)
    });
    let waive_advancement_fees = reader.peel_option_bool();
    let default_sponsor_quota_amount = reader.peel_option_u64();

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    // Get account ID first before taking mutable borrows
    let account_id = object::id(account);

    // Get mutable config through Account protocol with witness
    let config = account::config_mut<FutarchyConfig, futarchy_config::ConfigWitness>(account, registry, version, futarchy_config::witness());
    let dao_cfg = futarchy_config::dao_config_mut(config);
    let sponsorship_cfg = dao_config::sponsorship_config_mut(dao_cfg);

    // Apply updates if provided
    if (enabled.is_some()) {
        dao_config::set_sponsorship_enabled(sponsorship_cfg, enabled.destroy_some());
    };
    if (sponsored_threshold.is_some()) {
        dao_config::set_sponsored_threshold(sponsorship_cfg, sponsored_threshold.destroy_some());
    };
    if (waive_advancement_fees.is_some()) {
        dao_config::set_waive_advancement_fees(sponsorship_cfg, waive_advancement_fees.destroy_some());
    };
    if (default_sponsor_quota_amount.is_some()) {
        dao_config::set_default_sponsor_quota_amount(sponsorship_cfg, default_sponsor_quota_amount.destroy_some());
    };

    // Get final values after updates
    let final_enabled = dao_config::sponsorship_enabled(sponsorship_cfg);
    let final_waive_fees = dao_config::waive_advancement_fees(sponsorship_cfg);

    // Emit event
    event::emit(SponsorshipConfigChanged {
        account_id,
        enabled: final_enabled,
        waive_advancement_fees: final_waive_fees,
        timestamp: clock.timestamp_ms(),
    });

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Execute a batch config action that can contain any type of config update
/// This delegates to the appropriate handler based on config_type
public fun do_batch_config<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    _version: VersionWitness,
    intent_witness: IW,
    _clock: &Clock,
    _ctx: &mut TxContext,
) {
    // Get action spec
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));

    // CRITICAL - Type check BEFORE deserialization
    // Note: ConfigAction is a wrapper type that may not be in action_types
    // Using a generic config type check here
    // action_validation::assert_action_type<ConfigAction>(spec);

    // Get action data
    let action_data = protocol_intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = protocol_intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Deserialize the action
    let action = config_action_from_bytes(*action_data);

    // Note: config_action_from_bytes internally validates all bytes consumed
    // by delegating to specific deserialization functions for each config type

    // Validate that the correct field is populated for the config_type
    if (action.config_type == CONFIG_TYPE_TRADING_PARAMS) {
        assert!(action.trading_params.is_some(), EInvalidConfigType);
    } else if (action.config_type == CONFIG_TYPE_METADATA) {
        assert!(action.metadata.is_some(), EInvalidConfigType);
    } else if (action.config_type == CONFIG_TYPE_TWAP) {
        assert!(action.twap_config.is_some(), EInvalidConfigType);
    } else if (action.config_type == CONFIG_TYPE_GOVERNANCE) {
        assert!(action.governance.is_some(), EInvalidConfigType);
    } else if (action.config_type == CONFIG_TYPE_METADATA_TABLE) {
        assert!(action.metadata_table.is_some(), EInvalidConfigType);
    } else {
        abort EInvalidConfigType
    };

    // Note: The actual config updates should be handled by the individual
    // do_ functions for each action type. This wrapper provides type safety.

    // Increment action index
    executable::increment_action_idx(executable);
}

// === Destruction Functions ===

/// Destroy a SetProposalsEnabledAction
public fun destroy_set_proposals_enabled(action: SetProposalsEnabledAction) {
    let SetProposalsEnabledAction { enabled: _ } = action;
}

/// Destroy an UpdateNameAction
public fun destroy_update_name(action: UpdateNameAction) {
    let UpdateNameAction { new_name: _ } = action;
}

/// Destroy a TradingParamsUpdateAction
public fun destroy_trading_params_update(action: TradingParamsUpdateAction) {
    let TradingParamsUpdateAction {
        min_asset_amount: _,
        min_stable_amount: _,
        review_period_ms: _,
        trading_period_ms: _,
        amm_total_fee_bps: _,
    } = action;
}

/// Destroy a MetadataUpdateAction
public fun destroy_metadata_update(action: MetadataUpdateAction) {
    let MetadataUpdateAction {
        dao_name: _,
        icon_url: _,
        description: _,
    } = action;
}

/// Destroy a TwapConfigUpdateAction
public fun destroy_twap_config_update(action: TwapConfigUpdateAction) {
    let TwapConfigUpdateAction {
        start_delay: _,
        step_max: _,
        initial_observation: _,
        threshold: _,
    } = action;
}

/// Destroy a GovernanceUpdateAction
public fun destroy_governance_update(action: GovernanceUpdateAction) {
    let GovernanceUpdateAction {
        max_outcomes: _,
        max_actions_per_outcome: _,
        required_bond_amount: _,
        max_intents_per_outcome: _,
        proposal_intent_expiry_ms: _,
        optimistic_challenge_fee: _,
        optimistic_challenge_period_ms: _,
        proposal_creation_fee: _,
        proposal_fee_per_outcome: _,
        accept_new_proposals: _,
        enable_premarket_reservation_lock: _,
        show_proposal_details: _,
    } = action;
}

/// Destroy a MetadataTableUpdateAction
public fun destroy_metadata_table_update(action: MetadataTableUpdateAction) {
    let MetadataTableUpdateAction {
        keys: _,
        values: _,
        keys_to_remove: _,
    } = action;
}

/// Destroy a SponsorshipConfigUpdateAction
public fun destroy_sponsorship_config_update(action: SponsorshipConfigUpdateAction) {
    let SponsorshipConfigUpdateAction {
        enabled: _,
        sponsored_threshold: _,
        waive_advancement_fees: _,
        default_sponsor_quota_amount: _,
    } = action;
}

// === Cleanup Functions ===

/// Delete a set proposals enabled action from an expired intent
public fun delete_set_proposals_enabled<Config>(expired: &mut Expired) {
    let action_spec = intents::remove_action_spec(expired);
    let action_data = intents::action_spec_action_data(action_spec);
    let mut reader = bcs::new(action_data);
    reader.peel_bool();
    let _ = reader.into_remainder_bytes();
}

/// Delete an update name action from an expired intent
public fun delete_update_name<Config>(expired: &mut Expired) {
    let action_spec = intents::remove_action_spec(expired);
    let action_data = intents::action_spec_action_data(action_spec);
    let mut reader = bcs::new(action_data);
    reader.peel_vec_u8();
    let _ = reader.into_remainder_bytes();
}

/// Delete a trading params update action from an expired intent
public fun delete_trading_params_update<Config>(expired: &mut Expired) {
    let action_spec = intents::remove_action_spec(expired);
    let action_data = intents::action_spec_action_data(action_spec);
    let mut reader = bcs::new(action_data);
    reader.peel_option_u64();
    reader.peel_option_u64();
    reader.peel_option_u64();
    reader.peel_option_u64();
    reader.peel_option_u64();
    let _ = reader.into_remainder_bytes();
}

/// Delete a metadata update action from an expired intent
public fun delete_metadata_update<Config>(expired: &mut Expired) {
    let action_spec = intents::remove_action_spec(expired);
    let action_data = intents::action_spec_action_data(action_spec);
    let mut reader = bcs::new(action_data);
    // Read optional dao_name
    if (reader.peel_bool()) {
        reader.peel_vec_u8();
    };
    // Read optional icon_url
    if (reader.peel_bool()) {
        reader.peel_vec_u8();
    };
    // Read optional description
    if (reader.peel_bool()) {
        reader.peel_vec_u8();
    };
    let _ = reader.into_remainder_bytes();
}

/// Delete a TWAP config update action from an expired intent
public fun delete_twap_config_update<Config>(expired: &mut Expired) {
    let action_spec = intents::remove_action_spec(expired);
    let action_data = intents::action_spec_action_data(action_spec);
    let mut reader = bcs::new(action_data);
    reader.peel_option_u64();
    reader.peel_option_u64();
    reader.peel_option_u128();
    // Peel Option<SignedU128> - magnitude: u128, is_negative: bool
    let _ = bcs::peel_option!(&mut reader, |r| {
        r.peel_u128();
        r.peel_bool()
    });
    let _ = reader.into_remainder_bytes();
}

/// Delete a governance update action from an expired intent
public fun delete_governance_update<Config>(expired: &mut Expired) {
    let action_spec = intents::remove_action_spec(expired);
    let action_data = intents::action_spec_action_data(action_spec);
    let mut reader = bcs::new(action_data);
    reader.peel_option_bool();
    reader.peel_option_u64();
    reader.peel_option_u64();
    reader.peel_option_u64();
    reader.peel_option_u64();
    reader.peel_option_u64();
    reader.peel_option_u64();
    reader.peel_option_u64();
    let _ = reader.into_remainder_bytes();
}

/// Delete a metadata table update action from an expired intent
public fun delete_metadata_table_update<Config>(expired: &mut Expired) {
    let action_spec = intents::remove_action_spec(expired);
    let action_data = intents::action_spec_action_data(action_spec);
    let mut reader = bcs::new(action_data);
    // Read keys vector
    let keys_len = reader.peel_vec_length();
    let mut i = 0;
    while (i < keys_len) {
        reader.peel_vec_u8();
        i = i + 1;
    };
    // Read values vector
    let values_len = reader.peel_vec_length();
    i = 0;
    while (i < values_len) {
        reader.peel_vec_u8();
        i = i + 1;
    };
    // Read keys_to_remove vector
    let remove_len = reader.peel_vec_length();
    i = 0;
    while (i < remove_len) {
        reader.peel_vec_u8();
        i = i + 1;
    };
    let _ = reader.into_remainder_bytes();
}

/// Delete a queue params update action from an expired intent
public fun delete_queue_params_update<Config>(expired: &mut Expired) {
    let action_spec = intents::remove_action_spec(expired);
    let action_data = intents::action_spec_action_data(action_spec);
    let mut reader = bcs::new(action_data);
    reader.peel_option_u64();
    reader.peel_option_u64();
    reader.peel_option_u64();
    reader.peel_option_u64();
    let _ = reader.into_remainder_bytes();
}

/// Delete a sponsorship config update action from an expired intent
public fun delete_sponsorship_config_update<Config>(expired: &mut Expired) {
    let action_spec = intents::remove_action_spec(expired);
    let action_data = intents::action_spec_action_data(action_spec);
    let mut reader = bcs::new(action_data);
    reader.peel_option_bool();
    // Peel Option<SignedU128> - magnitude: u128, is_negative: bool
    let _ = bcs::peel_option!(&mut reader, |r| {
        r.peel_u128();
        r.peel_bool()
    });
    reader.peel_option_bool();
    reader.peel_option_u64();
    let _ = reader.into_remainder_bytes();
}

/// Delete a config action from an expired intent
public fun delete_config_action<Config>(expired: &mut Expired) {
    let action_spec = intents::remove_action_spec(expired);
    // Consume the action data without parsing
    let _action_data = intents::action_spec_action_data(action_spec);
}

// === Constructor Functions ===

/// Create a set proposals enabled action
public fun new_set_proposals_enabled_action(enabled: bool): SetProposalsEnabledAction {
    SetProposalsEnabledAction { enabled }
}

/// Create an update name action
public fun new_update_name_action(new_name: String): UpdateNameAction {
    assert!(new_name.length() > 0, EEmptyName);
    UpdateNameAction { new_name }
}

/// Create a trading params update action
public fun new_trading_params_update_action(
    min_asset_amount: Option<u64>,
    min_stable_amount: Option<u64>,
    review_period_ms: Option<u64>,
    trading_period_ms: Option<u64>,
    amm_total_fee_bps: Option<u64>,
): TradingParamsUpdateAction {
    let action = TradingParamsUpdateAction {
        min_asset_amount,
        min_stable_amount,
        review_period_ms,
        trading_period_ms,
        amm_total_fee_bps,
    };
    validate_trading_params_update(&action);
    action
}

/// Create a metadata update action
public fun new_metadata_update_action(
    dao_name: Option<AsciiString>,
    icon_url: Option<Url>,
    description: Option<String>,
): MetadataUpdateAction {
    let action = MetadataUpdateAction {
        dao_name,
        icon_url,
        description,
    };
    validate_metadata_update(&action);
    action
}

/// Create a TWAP config update action
public fun new_twap_config_update_action(
    start_delay: Option<u64>,
    step_max: Option<u64>,
    initial_observation: Option<u128>,
    threshold: Option<SignedU128>,
): TwapConfigUpdateAction {
    let action = TwapConfigUpdateAction {
        start_delay,
        step_max,
        initial_observation,
        threshold,
    };
    validate_twap_config_update(&action);
    action
}

/// Create a governance update action
public fun new_governance_update_action(
    max_outcomes: Option<u64>,
    max_actions_per_outcome: Option<u64>,
    required_bond_amount: Option<u64>,
    max_intents_per_outcome: Option<u64>,
    proposal_intent_expiry_ms: Option<u64>,
    optimistic_challenge_fee: Option<u64>,
    optimistic_challenge_period_ms: Option<u64>,
    proposal_creation_fee: Option<u64>,
    proposal_fee_per_outcome: Option<u64>,
    accept_new_proposals: Option<bool>,
    enable_premarket_reservation_lock: Option<bool>,
    show_proposal_details: Option<bool>,
): GovernanceUpdateAction {
    let action = GovernanceUpdateAction {
        max_outcomes,
        max_actions_per_outcome,
        required_bond_amount,
        max_intents_per_outcome,
        proposal_intent_expiry_ms,
        optimistic_challenge_fee,
        optimistic_challenge_period_ms,
        proposal_creation_fee,
        proposal_fee_per_outcome,
        accept_new_proposals,
        enable_premarket_reservation_lock,
        show_proposal_details,
    };
    validate_governance_update(&action);
    action
}

/// Create a metadata table update action
public fun new_metadata_table_update_action(
    keys: vector<String>,
    values: vector<String>,
    keys_to_remove: vector<String>,
): MetadataTableUpdateAction {
    assert!(keys.length() == values.length(), EMismatchedKeyValueLength);
    MetadataTableUpdateAction {
        keys,
        values,
        keys_to_remove,
    }
}

/// Create a conditional metadata update action
public fun new_conditional_metadata_update_action(
    use_outcome_index: Option<bool>,
    conditional_metadata: Option<Option<dao_config::ConditionalMetadata>>,
): ConditionalMetadataUpdateAction {
    ConditionalMetadataUpdateAction {
        use_outcome_index,
        conditional_metadata,
    }
}

/// Create a sponsorship config update action
public fun new_sponsorship_config_update_action(
    enabled: Option<bool>,
    sponsored_threshold: Option<SignedU128>,
    waive_advancement_fees: Option<bool>,
    default_sponsor_quota_amount: Option<u64>,
): SponsorshipConfigUpdateAction {
    SponsorshipConfigUpdateAction {
        enabled,
        sponsored_threshold,
        waive_advancement_fees,
        default_sponsor_quota_amount,
    }
}

// === Intent Creation Functions (with serialize-then-destroy pattern) ===

/// Add a SetProposalsEnabled action to an intent
public fun new_set_proposals_enabled<Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    enabled: bool,
    intent_witness: IW,
) {
    // Create, serialize, add, destroy
    let action = SetProposalsEnabledAction { enabled };
    let action_data = bcs::to_bytes(&action);
    intent.add_typed_action(
        type_name::get<SetProposalsEnabled>().into_string().to_string(),
        action_data,
        intent_witness
    );
    destroy_set_proposals_enabled(action);
}

/// Add an UpdateName action to an intent
public fun new_update_name<Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    new_name: String,
    intent_witness: IW,
) {
    assert!(new_name.length() > 0, EEmptyName);
    let action = UpdateNameAction { new_name };
    let action_data = bcs::to_bytes(&action);
    intent.add_typed_action(
        type_name::get<UpdateName>().into_string().to_string(),
        action_data,
        intent_witness
    );
    destroy_update_name(action);
}

/// Add a TradingParamsUpdate action to an intent
public fun new_trading_params_update<Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    min_asset_amount: Option<u64>,
    min_stable_amount: Option<u64>,
    review_period_ms: Option<u64>,
    trading_period_ms: Option<u64>,
    amm_total_fee_bps: Option<u64>,
    intent_witness: IW,
) {
    let action = TradingParamsUpdateAction {
        min_asset_amount,
        min_stable_amount,
        review_period_ms,
        trading_period_ms,
        amm_total_fee_bps,
    };
    validate_trading_params_update(&action);
    let action_data = bcs::to_bytes(&action);
    intent.add_typed_action(
        type_name::get<TradingParamsUpdate>().into_string().to_string(),
        action_data,
        intent_witness
    );
    destroy_trading_params_update(action);
}

/// Add a MetadataUpdate action to an intent
public fun new_metadata_update<Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    dao_name: Option<AsciiString>,
    icon_url: Option<Url>,
    description: Option<String>,
    intent_witness: IW,
) {
    let action = MetadataUpdateAction {
        dao_name,
        icon_url,
        description,
    };
    validate_metadata_update(&action);
    let action_data = bcs::to_bytes(&action);
    intent.add_typed_action(
        type_name::get<MetadataUpdate>().into_string().to_string(),
        action_data,
        intent_witness
    );
    destroy_metadata_update(action);
}

/// Add a TwapConfigUpdate action to an intent
public fun new_twap_config_update<Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    start_delay: Option<u64>,
    step_max: Option<u64>,
    initial_observation: Option<u128>,
    threshold: Option<SignedU128>,
    intent_witness: IW,
) {
    let action = TwapConfigUpdateAction {
        start_delay,
        step_max,
        initial_observation,
        threshold,
    };
    validate_twap_config_update(&action);
    let action_data = bcs::to_bytes(&action);
    intent.add_typed_action(
        type_name::get<TwapConfigUpdate>().into_string().to_string(),
        action_data,
        intent_witness
    );
    destroy_twap_config_update(action);
}

/// Add a GovernanceUpdate action to an intent
public fun new_governance_update<Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    max_outcomes: Option<u64>,
    max_actions_per_outcome: Option<u64>,
    required_bond_amount: Option<u64>,
    max_intents_per_outcome: Option<u64>,
    proposal_intent_expiry_ms: Option<u64>,
    optimistic_challenge_fee: Option<u64>,
    optimistic_challenge_period_ms: Option<u64>,
    proposal_creation_fee: Option<u64>,
    proposal_fee_per_outcome: Option<u64>,
    accept_new_proposals: Option<bool>,
    enable_premarket_reservation_lock: Option<bool>,
    intent_witness: IW,
) {
    let action = GovernanceUpdateAction {
        max_outcomes,
        max_actions_per_outcome,
        required_bond_amount,
        max_intents_per_outcome,
        proposal_intent_expiry_ms,
        optimistic_challenge_fee,
        optimistic_challenge_period_ms,
        proposal_creation_fee,
        proposal_fee_per_outcome,
        accept_new_proposals,
        enable_premarket_reservation_lock,
        show_proposal_details: option::none(),
    };
    validate_governance_update(&action);
    let action_data = bcs::to_bytes(&action);
    intent.add_typed_action(
        type_name::get<GovernanceUpdate>().into_string().to_string(),
        action_data,
        intent_witness
    );
    destroy_governance_update(action);
}

/// Add a MetadataTableUpdate action to an intent
public fun new_metadata_table_update<Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    keys: vector<String>,
    values: vector<String>,
    keys_to_remove: vector<String>,
    intent_witness: IW,
) {
    assert!(keys.length() == values.length(), EMismatchedKeyValueLength);
    let action = MetadataTableUpdateAction {
        keys,
        values,
        keys_to_remove,
    };
    let action_data = bcs::to_bytes(&action);
    intent.add_typed_action(
        type_name::get<UpdateConditionalMetadata>().into_string().to_string(),
        action_data,
        intent_witness
    );
    destroy_metadata_table_update(action);
}

// === Getter Functions ===

/// Get proposals enabled field
public fun get_proposals_enabled(action: &SetProposalsEnabledAction): bool {
    action.enabled
}

/// Get new name field
public fun get_new_name(action: &UpdateNameAction): String {
    action.new_name
}

/// Get trading params update fields
public fun get_trading_params_fields(update: &TradingParamsUpdateAction): (
    &Option<u64>,
    &Option<u64>,
    &Option<u64>,
    &Option<u64>,
    &Option<u64>
) {
    (
        &update.min_asset_amount,
        &update.min_stable_amount,
        &update.review_period_ms,
        &update.trading_period_ms,
        &update.amm_total_fee_bps
    )
}

/// Get metadata update fields
public fun get_metadata_fields(update: &MetadataUpdateAction): (
    &Option<AsciiString>,
    &Option<Url>,
    &Option<String>
) {
    (
        &update.dao_name,
        &update.icon_url,
        &update.description
    )
}

/// Get TWAP config update fields
public fun get_twap_config_fields(update: &TwapConfigUpdateAction): (
    &Option<u64>,
    &Option<u64>,
    &Option<u128>,
    &Option<SignedU128>
) {
    (
        &update.start_delay,
        &update.step_max,
        &update.initial_observation,
        &update.threshold
    )
}

/// Get governance update fields
public fun get_governance_fields(update: &GovernanceUpdateAction): (
    &Option<u64>,
    &Option<u64>,
    &Option<u64>,
    &Option<u64>,
    &Option<u64>
) {
    (
        &update.max_outcomes,
        &update.max_actions_per_outcome,
        &update.required_bond_amount,
        &update.max_intents_per_outcome,
        &update.proposal_intent_expiry_ms
    )
}

/// Get metadata table update fields
public fun get_metadata_table_fields(update: &MetadataTableUpdateAction): (
    &vector<String>,
    &vector<String>,
    &vector<String>
) {
    (
        &update.keys,
        &update.values,
        &update.keys_to_remove
    )
}

/// Create a config action for trading params updates
public fun new_config_action_trading_params(
    params: TradingParamsUpdateAction
): ConfigAction {
    ConfigAction {
        config_type: CONFIG_TYPE_TRADING_PARAMS,
        trading_params: option::some(params),
        metadata: option::none(),
        twap_config: option::none(),
        governance: option::none(),
        metadata_table: option::none(),
    }
}

/// Create a config action for metadata updates  
public fun new_config_action_metadata(
    metadata: MetadataUpdateAction
): ConfigAction {
    ConfigAction {
        config_type: CONFIG_TYPE_METADATA,
        trading_params: option::none(),
        metadata: option::some(metadata),
        twap_config: option::none(),
        governance: option::none(),
        metadata_table: option::none(),
    }
}

/// Create a config action for TWAP config updates
public fun new_config_action_twap(
    twap: TwapConfigUpdateAction
): ConfigAction {
    ConfigAction {
        config_type: CONFIG_TYPE_TWAP,
        trading_params: option::none(),
        metadata: option::none(),
        twap_config: option::some(twap),
        governance: option::none(),
        metadata_table: option::none(),
    }
}

/// Create a config action for governance updates
public fun new_config_action_governance(
    gov: GovernanceUpdateAction
): ConfigAction {
    ConfigAction {
        config_type: CONFIG_TYPE_GOVERNANCE,
        trading_params: option::none(),
        metadata: option::none(),
        twap_config: option::none(),
        governance: option::some(gov),
        metadata_table: option::none(),
    }
}

/// Create a config action for metadata table updates
public fun new_config_action_metadata_table(
    table: MetadataTableUpdateAction
): ConfigAction {
    ConfigAction {
        config_type: CONFIG_TYPE_METADATA_TABLE,
        trading_params: option::none(),
        metadata: option::none(),
        twap_config: option::none(),
        governance: option::none(),
        metadata_table: option::some(table),
    }
}

// === Internal Validation Functions ===

/// Validate trading params update
fun validate_trading_params_update(action: &TradingParamsUpdateAction) {
    if (action.min_asset_amount.is_some()) {
        assert!(*action.min_asset_amount.borrow() > 0, EInvalidParameter);
    };
    if (action.min_stable_amount.is_some()) {
        assert!(*action.min_stable_amount.borrow() > 0, EInvalidParameter);
    };
    if (action.review_period_ms.is_some()) {
        assert!(*action.review_period_ms.borrow() > 0, EInvalidParameter);
    };
    if (action.trading_period_ms.is_some()) {
        assert!(*action.trading_period_ms.borrow() > 0, EInvalidParameter);
    };
    if (action.amm_total_fee_bps.is_some()) {
        assert!(*action.amm_total_fee_bps.borrow() <= 10000, EInvalidParameter); // Max 100%
    };
}

/// Validate metadata update
fun validate_metadata_update(action: &MetadataUpdateAction) {
    if (action.dao_name.is_some()) {
        assert!(action.dao_name.borrow().length() > 0, EEmptyString);
    };
    if (action.description.is_some()) {
        assert!(action.description.borrow().length() > 0, EEmptyString);
    };
}

/// Validate TWAP config update
fun validate_twap_config_update(action: &TwapConfigUpdateAction) {
    if (action.step_max.is_some()) {
        assert!(*action.step_max.borrow() > 0, EInvalidParameter);
    };
}

/// Validate governance update
fun validate_governance_update(action: &GovernanceUpdateAction) {
    if (action.max_outcomes.is_some()) {
        assert!(*action.max_outcomes.borrow() >= 2, EInvalidParameter); // At least YES/NO
    };
    if (action.max_intents_per_outcome.is_some()) {
        assert!(*action.max_intents_per_outcome.borrow() > 0, EInvalidParameter);
    };
}

// === Aliases for backwards compatibility ===

/// Alias for do_update_twap_config for compatibility
public fun do_update_twap_params<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    version: VersionWitness,
    iw: IW,
    clock: &Clock,
    ctx: &mut TxContext
) {
    do_update_twap_config<Outcome, IW>(executable, account, registry, version, iw, clock, ctx);
}

// === Deserialization Constructors ===

/// Deserialize SetProposalsEnabledAction from bytes
public(package) fun set_proposals_enabled_action_from_bytes(bytes: vector<u8>): SetProposalsEnabledAction {
    let mut bcs = bcs::new(bytes);
    SetProposalsEnabledAction {
        enabled: bcs.peel_bool(),
    }
}

/// Deserialize UpdateNameAction from bytes
public(package) fun update_name_action_from_bytes(bytes: vector<u8>): UpdateNameAction {
    let mut bcs = bcs::new(bytes);
    UpdateNameAction {
        new_name: string::utf8(bcs.peel_vec_u8()),
    }
}

/// Deserialize MetadataUpdateAction from bytes
public(package) fun metadata_update_action_from_bytes(bytes: vector<u8>): MetadataUpdateAction {
    let mut bcs = bcs::new(bytes);
    MetadataUpdateAction {
        dao_name: if (bcs.peel_bool()) {
            option::some(ascii::string(bcs.peel_vec_u8()))
        } else {
            option::none()
        },
        icon_url: if (bcs.peel_bool()) {
            option::some(url::new_unsafe_from_bytes(bcs.peel_vec_u8()))
        } else {
            option::none()
        },
        description: if (bcs.peel_bool()) {
            option::some(string::utf8(bcs.peel_vec_u8()))
        } else {
            option::none()
        },
    }
}

/// Deserialize TradingParamsUpdateAction from bytes
public(package) fun trading_params_update_action_from_bytes(bytes: vector<u8>): TradingParamsUpdateAction {
    let mut bcs = bcs::new(bytes);
    TradingParamsUpdateAction {
        min_asset_amount: bcs.peel_option_u64(),
        min_stable_amount: bcs.peel_option_u64(),
        review_period_ms: bcs.peel_option_u64(),
        trading_period_ms: bcs.peel_option_u64(),
        amm_total_fee_bps: bcs.peel_option_u64(),
    }
}

/// Deserialize TwapConfigUpdateAction from bytes
public(package) fun twap_config_update_action_from_bytes(bytes: vector<u8>): TwapConfigUpdateAction {
    let mut bcs = bcs::new(bytes);
    TwapConfigUpdateAction {
        start_delay: bcs.peel_option_u64(),
        step_max: bcs.peel_option_u64(),
        initial_observation: bcs.peel_option_u128(),
        threshold: bcs::peel_option!(&mut bcs, |r| {
            let magnitude = r.peel_u128();
            let is_negative = r.peel_bool();
            signed::from_parts(magnitude, is_negative)
        }),
    }
}

/// Deserialize GovernanceUpdateAction from bytes
public(package) fun governance_update_action_from_bytes(bytes: vector<u8>): GovernanceUpdateAction {
    let mut bcs = bcs::new(bytes);
    GovernanceUpdateAction {
        max_outcomes: bcs.peel_option_u64(),
        max_actions_per_outcome: bcs.peel_option_u64(),
        required_bond_amount: bcs.peel_option_u64(),
        max_intents_per_outcome: bcs.peel_option_u64(),
        proposal_intent_expiry_ms: bcs.peel_option_u64(),
        optimistic_challenge_fee: bcs.peel_option_u64(),
        optimistic_challenge_period_ms: bcs.peel_option_u64(),
        proposal_creation_fee: bcs.peel_option_u64(),
        proposal_fee_per_outcome: bcs.peel_option_u64(),
        accept_new_proposals: bcs.peel_option_bool(),
        enable_premarket_reservation_lock: bcs.peel_option_bool(),
        show_proposal_details: bcs.peel_option_bool(),
    }
}

/// Deserialize MetadataTableUpdateAction from bytes
public(package) fun metadata_table_update_action_from_bytes(bytes: vector<u8>): MetadataTableUpdateAction {
    let mut bcs = bcs::new(bytes);
    MetadataTableUpdateAction {
        keys: {
            let len = bcs.peel_vec_length();
            let mut result = vector[];
            let mut i = 0;
            while (i < len) {
                result.push_back(string::utf8(bcs.peel_vec_u8()));
                i = i + 1;
            };
            result
        },
        values: {
            let len = bcs.peel_vec_length();
            let mut result = vector[];
            let mut i = 0;
            while (i < len) {
                result.push_back(string::utf8(bcs.peel_vec_u8()));
                i = i + 1;
            };
            result
        },
        keys_to_remove: {
            let len = bcs.peel_vec_length();
            let mut result = vector[];
            let mut i = 0;
            while (i < len) {
                result.push_back(string::utf8(bcs.peel_vec_u8()));
                i = i + 1;
            };
            result
        },
    }
}

/// Deserialize SponsorshipConfigUpdateAction from bytes
public(package) fun sponsorship_config_update_action_from_bytes(bytes: vector<u8>): SponsorshipConfigUpdateAction {
    let mut bcs = bcs::new(bytes);
    SponsorshipConfigUpdateAction {
        enabled: bcs.peel_option_bool(),
        sponsored_threshold: bcs::peel_option!(&mut bcs, |r| {
            let magnitude = r.peel_u128();
            let is_negative = r.peel_bool();
            signed::from_parts(magnitude, is_negative)
        }),
        waive_advancement_fees: bcs.peel_option_bool(),
        default_sponsor_quota_amount: bcs.peel_option_u64(),
    }
}

/// Deserialize ConfigAction from bytes
public(package) fun config_action_from_bytes(bytes: vector<u8>): ConfigAction {
    let mut bcs = bcs::new(bytes);
    let config_type = bcs.peel_u8();

    ConfigAction {
        config_type,
        trading_params: if (config_type == CONFIG_TYPE_TRADING_PARAMS) {
            option::some(trading_params_update_action_from_bytes(bcs.into_remainder_bytes()))
        } else {
            option::none()
        },
        metadata: if (config_type == CONFIG_TYPE_METADATA) {
            option::some(metadata_update_action_from_bytes(bcs.into_remainder_bytes()))
        } else {
            option::none()
        },
        twap_config: if (config_type == CONFIG_TYPE_TWAP) {
            option::some(twap_config_update_action_from_bytes(bcs.into_remainder_bytes()))
        } else {
            option::none()
        },
        governance: if (config_type == CONFIG_TYPE_GOVERNANCE) {
            option::some(governance_update_action_from_bytes(bcs.into_remainder_bytes()))
        } else {
            option::none()
        },
        metadata_table: if (config_type == CONFIG_TYPE_METADATA_TABLE) {
            option::some(metadata_table_update_action_from_bytes(bcs.into_remainder_bytes()))
        } else {
            option::none()
        },
    }
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Init wrappers for liquidity actions during DAO creation
///
/// This module provides public functions for creating AMM pools during init.
/// These functions work with unshared Account objects before DAO is shared.
module futarchy_actions::liquidity_init_actions;

use account_actions::{vault, init_actions, version};
use account_protocol::{
    account::{Self as account_mod, Account},
    package_registry::PackageRegistry,
    executable::{Self as executable_mod, Executable},
    intents,
    version_witness::VersionWitness,
    bcs_validation,
    action_validation,
};
use futarchy_core::futarchy_config;
use futarchy_markets_core::unified_spot_pool::{Self, UnifiedSpotPool};
use std::option;
use std::string::{Self, String};
use sui::bcs;
use sui::clock::Clock;
use sui::coin::{Self, Coin};
use sui::object::{Self, ID};
use sui::tx_context::TxContext;

// === Constants ===
const DEFAULT_VAULT_NAME: vector<u8> = b"treasury";

// === Errors ===
const EInvalidAmount: u64 = 1;
const EInvalidRatio: u64 = 2;
const EUnsupportedActionVersion: u64 = 3;

// === Marker Types (for action validation) ===

/// Marker type for CreatePoolWithMintAction validation
public struct CreatePoolWithMint has drop {}

// === Action Structs (for staging/dispatching) ===

/// Action to create AMM pool with minted asset and vault stable
/// Stored directly as typed object (no BCS serialization needed!)
public struct CreatePoolWithMintAction has store, copy, drop {
    vault_name: String,
    asset_amount: u64,
    stable_amount: u64,
    fee_bps: u64,
}

// === Spec Builders (for staging in InitActionSpecs) ===

/// Add CreatePoolWithMintAction to InitActionSpecs
/// Used for staging actions in launchpad raises
public fun add_create_pool_with_mint_spec(
    specs: &mut account_actions::init_action_specs::InitActionSpecs,
    vault_name: String,
    asset_amount: u64,
    stable_amount: u64,
    fee_bps: u64,
) {
    use std::type_name;
    use sui::bcs;

    // Create action struct
    let action = CreatePoolWithMintAction {
        vault_name,
        asset_amount,
        stable_amount,
        fee_bps,
    };

    // Serialize
    let action_data = bcs::to_bytes(&action);

    // CRITICAL: Use marker type (not action struct type) for validation
    account_actions::init_action_specs::add_action(
        specs,
        type_name::with_defining_ids<CreatePoolWithMint>(),
        action_data
    );
}

// === Dispatchers ===

/// Execute init_create_pool_with_mint from a staged action
/// Accepts typed action directly (zero deserialization cost!)
public fun dispatch_create_pool_with_mint<Config: store, AssetType: drop, StableType: drop, W: copy + drop>(
    account: &mut Account,
    registry: &PackageRegistry,
    action: &CreatePoolWithMintAction,
    witness: W,
    clock: &Clock,
    ctx: &mut TxContext,
): ID {
    // Execute with the exact parameters from the staged action
    init_create_pool_with_mint<Config, AssetType, StableType, W>(
        account,
        registry,
        action.vault_name,
        action.asset_amount,
        action.stable_amount,
        action.fee_bps,
        witness,
        clock,
        ctx,
    )
}

// === Intent Execution (for PTB executor pattern) ===

/// Execute pool creation from Intent during launchpad initialization
/// Follows 3-layer action execution pattern (see IMPORTANT_ACTION_EXECUTION_PATTERN.md)
///
/// This function is called from PTB executor after begin_execution:
/// 1. begin_execution() creates Executable hot potato
/// 2. PTB calls do_init_* functions in sequence (including this one)
/// 3. finalize_execution() confirms the executable
public fun do_init_create_pool_with_mint<Config: store, Outcome: store, AssetType: drop, StableType: drop, IW: copy + drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    clock: &Clock,
    _version_witness: VersionWitness,
    _intent_witness: IW,
    ctx: &mut TxContext,
): ID {
    // 1. Assert account ownership
    executable.intent().assert_is_account(account.addr());

    // 2. Get current ActionSpec from Executable
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // 3. CRITICAL: Validate action type (using marker type)
    action_validation::assert_action_type<CreatePoolWithMint>(spec);

    // 4. Check version
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // 5. Deserialize CreatePoolWithMintAction from BCS bytes
    let action_data = intents::action_spec_data(spec);
    let mut reader = bcs::new(*action_data);
    let vault_name = string::utf8(bcs::peel_vec_u8(&mut reader));
    let asset_amount = bcs::peel_u64(&mut reader);
    let stable_amount = bcs::peel_u64(&mut reader);
    let fee_bps = bcs::peel_u64(&mut reader);

    // 6. Validate all bytes consumed (security check)
    bcs_validation::validate_all_bytes_consumed(reader);

    // 7. Execute with deserialized params
    let pool_id = init_create_pool_with_mint<Config, AssetType, StableType, IW>(
        account,
        registry,
        vault_name,
        asset_amount,
        stable_amount,
        fee_bps,
        _intent_witness,
        clock,
        ctx,
    );

    // 8. Increment action index
    executable_mod::increment_action_idx(executable);

    pool_id
}

// === Init Actions ===

/// Create AMM pool during DAO init (before account is shared)
///
/// This function:
/// 1. Creates a new UnifiedSpotPool
/// 2. Adds initial liquidity
/// 3. Shares the pool (makes it public)
/// 4. Deposits LP token to custody AUTOMATICALLY
/// 5. Returns excess coins to treasury vault
///
/// Returns: pool_id for use in subsequent init actions
public fun init_create_pool<Config: store, AssetType: drop, StableType: drop, W: copy + drop>(
    account: &mut Account,
    registry: &PackageRegistry,
    asset_coin: Coin<AssetType>,
    stable_coin: Coin<StableType>,
    fee_bps: u64,
    witness: W,
    clock: &Clock,
    ctx: &mut TxContext,
): ID {
    // Validate inputs
    assert!(coin::value(&asset_coin) > 0, EInvalidAmount);
    assert!(coin::value(&stable_coin) > 0, EInvalidAmount);
    assert!(fee_bps <= 10000, EInvalidRatio); // Max 100%

    // 1. Get DAO config to read conditional_liquidity_ratio_percent
    let config = account_mod::config(account);
    let conditional_liquidity_ratio_percent = futarchy_config::conditional_liquidity_ratio_percent(config);

    // 2. Create pool with FULL FUTARCHY FEATURES
    let mut pool = unified_spot_pool::new<AssetType, StableType>(
        fee_bps,
        option::none(), // No dynamic fee schedule
        5000, // oracle_conditional_threshold_bps (50%)
        conditional_liquidity_ratio_percent, // From DAO config!
        clock,
        ctx
    );

    // 2. Add initial liquidity (returns LP token + any excess coins)
    let (lp_token, excess_asset, excess_stable) =
        unified_spot_pool::add_liquidity_and_return(
            &mut pool,
            asset_coin,
            stable_coin,
            0, // min_lp_out = 0 for initial liquidity (no slippage)
            ctx
        );

    // Get pool ID before sharing
    let pool_id = object::id(&pool);

    // 3. Share the pool so it can be accessed by anyone
    unified_spot_pool::share(pool);

    // 4. Store LP token in account as managed asset (AUTOMATIC STORAGE!)
    let token_id = object::id(&lp_token);
    account_mod::add_managed_asset(
        account,
        registry,
        token_id, // Use token_id directly as key
        lp_token,
        version::current(),
    );

    // 5. Return any excess coins to treasury vault
    let vault_name = string::utf8(DEFAULT_VAULT_NAME);

    if (coin::value(&excess_asset) > 0) {
        vault::deposit_approved<Config, AssetType>(
            account,
            registry,
            vault_name,
            excess_asset,
        );
    } else {
        coin::destroy_zero(excess_asset);
    };

    if (coin::value(&excess_stable) > 0) {
        vault::deposit_approved<Config, StableType>(
            account,
            registry,
            vault_name,
            excess_stable,
        );
    } else {
        coin::destroy_zero(excess_stable);
    };

    pool_id
}

/// Create AMM pool during DAO init with minted asset and stable from vault
///
/// This function:
/// 1. Mints new asset tokens using the DAO's treasury cap
/// 2. Withdraws stable coins from the DAO's vault (raised from launchpad)
/// 3. Creates a new UnifiedSpotPool
/// 4. Adds initial liquidity
/// 5. Shares the pool (makes it public)
/// 6. Deposits LP token to custody AUTOMATICALLY (DAO-owned LP!)
/// 7. Returns excess coins to treasury vault
///
/// Returns: pool_id for use in subsequent init actions
public fun init_create_pool_with_mint<Config: store, AssetType: drop, StableType: drop, W: copy + drop>(
    account: &mut Account,
    registry: &PackageRegistry,
    vault_name: string::String,
    asset_amount: u64,
    stable_amount: u64,
    fee_bps: u64,
    witness: W,
    clock: &Clock,
    ctx: &mut TxContext,
): ID {
    // Validate inputs
    assert!(asset_amount > 0, EInvalidAmount);
    assert!(stable_amount > 0, EInvalidAmount);
    assert!(fee_bps <= 10000, EInvalidRatio); // Max 100%

    // 1. Mint asset tokens from DAO treasury cap
    let asset_coin = account_actions::init_actions::init_mint_to_coin<Config, AssetType>(
        account,
        registry,
        asset_amount,
        ctx
    );

    // 2. Withdraw stable coins from DAO vault (raised funds from launchpad)
    let stable_coin = account_actions::init_actions::init_vault_spend<Config, StableType>(
        account,
        registry,
        vault_name,
        stable_amount,
        ctx
    );

    // 3. Get DAO config to read conditional_liquidity_ratio_percent
    let config = account_mod::config(account);
    let conditional_liquidity_ratio_percent = futarchy_config::conditional_liquidity_ratio_percent(config);

    // 4. Create pool with FULL FUTARCHY FEATURES
    let mut pool = unified_spot_pool::new<AssetType, StableType>(
        fee_bps,
        option::none(), // No dynamic fee schedule
        5000, // oracle_conditional_threshold_bps (50%)
        conditional_liquidity_ratio_percent, // From DAO config!
        clock,
        ctx
    );

    // 4. Add initial liquidity (returns LP token + any excess coins)
    let (lp_token, excess_asset, excess_stable) =
        unified_spot_pool::add_liquidity_and_return(
            &mut pool,
            asset_coin,
            stable_coin,
            0, // min_lp_out = 0 for initial liquidity (no slippage)
            ctx
        );

    // Get pool ID before sharing
    let pool_id = object::id(&pool);

    // 5. Share the pool so it can be accessed by anyone
    unified_spot_pool::share(pool);

    // 6. Store LP token in account as managed asset (DAO OWNS THE LP!)
    let token_id = object::id(&lp_token);
    account_mod::add_managed_asset(
        account,
        registry,
        token_id, // Use token_id directly as key
        lp_token,
        version::current(),
    );

    // 7. Return any excess coins to treasury vault
    if (coin::value(&excess_asset) > 0) {
        vault::deposit_approved<Config, AssetType>(
            account,
            registry,
            vault_name,
            excess_asset,
        );
    } else {
        coin::destroy_zero(excess_asset);
    };

    if (coin::value(&excess_stable) > 0) {
        vault::deposit_approved<Config, StableType>(
            account,
            registry,
            vault_name,
            excess_stable,
        );
    } else {
        coin::destroy_zero(excess_stable);
    };

    pool_id
}

/// Add liquidity to an existing pool during DAO init
///
/// Similar to init_create_pool but for adding to existing pools.
/// LP token is automatically deposited to custody.
public fun init_add_liquidity<Config: store, AssetType: drop, StableType: drop, W: copy + drop>(
    account: &mut Account,
    registry: &PackageRegistry,
    pool: &mut UnifiedSpotPool<AssetType, StableType>,
    asset_coin: Coin<AssetType>,
    stable_coin: Coin<StableType>,
    min_lp_out: u64,
    witness: W,
    ctx: &mut TxContext,
) {
    // Validate inputs
    assert!(coin::value(&asset_coin) > 0, EInvalidAmount);
    assert!(coin::value(&stable_coin) > 0, EInvalidAmount);

    let pool_id = object::id(pool);

    // Add liquidity (returns LP token + excess coins)
    let (lp_token, excess_asset, excess_stable) =
        unified_spot_pool::add_liquidity_and_return(
            pool,
            asset_coin,
            stable_coin,
            min_lp_out,
            ctx
        );

    // Store LP token in account as managed asset
    let token_id = object::id(&lp_token);
    account_mod::add_managed_asset(
        account,
        registry,
        token_id, // Use token_id directly as key
        lp_token,
        version::current(),
    );

    // Return excess to vault
    let vault_name = string::utf8(DEFAULT_VAULT_NAME);

    if (coin::value(&excess_asset) > 0) {
        vault::deposit_approved<Config, AssetType>(
            account,
            registry,
            vault_name,
            excess_asset,
        );
    } else {
        coin::destroy_zero(excess_asset);
    };

    if (coin::value(&excess_stable) > 0) {
        vault::deposit_approved<Config, StableType>(
            account,
            registry,
            vault_name,
            excess_stable,
        );
    } else {
        coin::destroy_zero(excess_stable);
    };
}
// Copyright (c) Govex DAO LLC
// SPDX-License-Identifier: BUSL-1.1

/// Liquidity-related actions for futarchy DAOs
/// This module defines action structs and execution logic for liquidity management
module futarchy_actions::liquidity_actions;

// === Imports ===
use std::string::{Self, String};
use std::option::{Self, Option};
use sui::{
    coin::{Self, Coin},
    object::{Self, ID},
    clock::Clock,
    tx_context::TxContext,
    balance::{Self, Balance},
    transfer,
    bcs::{Self, BCS},
};
use account_protocol::{
    account::{Self, Account},
    executable::{Self, Executable},
    intents::{Self, Expired, ActionSpec},
    version_witness::VersionWitness,
    bcs_validation,
    action_validation,
    package_registry::PackageRegistry,
};
use account_actions::vault;
// === Action Type Markers ===

/// Create a liquidity pool
public struct CreatePool has drop {}
/// Update pool parameters
public struct UpdatePoolParams has drop {}
/// Add liquidity to pool
public struct AddLiquidity has drop {}
/// Withdraw LP tokens
public struct WithdrawLpToken has drop {}
/// Remove liquidity from pool
public struct RemoveLiquidity has drop {}
/// Swap tokens
public struct Swap has drop {}
/// Collect trading fees
public struct CollectFees has drop {}
/// Withdraw collected fees
public struct WithdrawFees has drop {}

// === Marker Functions ===

public fun create_pool_marker(): CreatePool { CreatePool {} }
public fun update_pool_params_marker(): UpdatePoolParams { UpdatePoolParams {} }
public fun add_liquidity_marker(): AddLiquidity { AddLiquidity {} }
public fun withdraw_lp_token_marker(): WithdrawLpToken { WithdrawLpToken {} }
public fun remove_liquidity_marker(): RemoveLiquidity { RemoveLiquidity {} }
public fun swap_marker(): Swap { Swap {} }
public fun collect_fees_marker(): CollectFees { CollectFees {} }
public fun withdraw_fees_marker(): WithdrawFees { WithdrawFees {} }

use futarchy_core::{
    futarchy_config::{Self, FutarchyConfig},
    version,
};
use futarchy_core::resource_requests::{Self, ResourceRequest, ResourceReceipt};
use futarchy_markets_core::unified_spot_pool::{Self, UnifiedSpotPool, LPToken};
use futarchy_markets_operations::lp_token_custody;
// AddLiquidityAction defined locally since futarchy_one_shot_utils module doesn't exist

// === Friend Modules === (deprecated in 2024 edition, using public(package) instead)

// === Errors ===
const EInvalidAmount: u64 = 1;
const EInvalidRatio: u64 = 2;
const EEmptyPool: u64 = 4;
const EInsufficientVaultBalance: u64 = 5;
const EWrongToken: u64 = 6;
const EBypassNotAllowed: u64 = 7;
const EUnsupportedActionVersion: u64 = 8;

// === Constants ===
const DEFAULT_VAULT_NAME: vector<u8> = b"treasury";

// === Action Structs ===

/// Action to add liquidity to a pool
public struct AddLiquidityAction<phantom AssetType, phantom StableType> has store, drop, copy {
    pool_id: ID,
    asset_amount: u64,
    stable_amount: u64,
    min_lp_out: u64, // Slippage protection
}

/// Action to withdraw an LP token from custody
public struct WithdrawLpTokenAction<phantom AssetType, phantom StableType> has store, drop, copy {
    pool_id: ID,
    token_id: ID,
}

/// Action to remove liquidity from a pool
public struct RemoveLiquidityAction<phantom AssetType, phantom StableType> has store, drop, copy {
    pool_id: ID,
    token_id: ID,
    lp_amount: u64,
    min_asset_amount: u64, // Slippage protection
    min_stable_amount: u64, // Slippage protection
    bypass_minimum: bool,
}

/// Action to perform a swap in the pool
public struct SwapAction<phantom AssetType, phantom StableType> has store, drop {
    pool_id: ID,
    swap_asset: bool, // true = swap asset for stable, false = swap stable for asset
    amount_in: u64,
    min_amount_out: u64, // Slippage protection
}

/// Action to collect fees from the pool
public struct CollectFeesAction<phantom AssetType, phantom StableType> has store, drop {
    pool_id: ID,
}

/// Action to withdraw accumulated fees to treasury
public struct WithdrawFeesAction<phantom AssetType, phantom StableType> has store, drop {
    pool_id: ID,
    asset_amount: u64,
    stable_amount: u64,
}

/// Action to create a new liquidity pool
public struct CreatePoolAction<phantom AssetType, phantom StableType> has store, drop, copy {
    initial_asset_amount: u64,
    initial_stable_amount: u64,
    fee_bps: u64,
    minimum_liquidity: u64,
    conditional_liquidity_ratio_percent: u64, // From DAO config
}

/// Action to update pool parameters
public struct UpdatePoolParamsAction has store, drop, copy {
    pool_id: ID,           // Direct pool ID
    new_fee_bps: u64,
    new_minimum_liquidity: u64,
}


// === Execution Functions ===

/// Execute a create pool action with type validation
/// Creates a hot potato ResourceRequest that must be fulfilled with coins and pool
public fun do_create_pool<AssetType: drop, StableType: drop, Outcome: store, IW: copy + drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    _version: VersionWitness,
    witness: IW,
    ctx: &mut TxContext,
): resource_requests::ResourceRequest<CreatePoolAction<AssetType, StableType>> {
    // Get spec and validate type BEFORE deserialization
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));
    action_validation::assert_action_type<CreatePool>(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    let action_data = intents::action_spec_data(spec);

    // Safe BCS deserialization
    let mut reader = bcs::new(*action_data);
    let initial_asset_amount = bcs::peel_u64(&mut reader);
    let initial_stable_amount = bcs::peel_u64(&mut reader);
    let fee_bps = bcs::peel_u64(&mut reader);
    let minimum_liquidity = bcs::peel_u64(&mut reader);
    let conditional_liquidity_ratio_percent = bcs::peel_u64(&mut reader);
    bcs_validation::validate_all_bytes_consumed(reader);

    // Create action struct
    let action = CreatePoolAction<AssetType, StableType> {
        initial_asset_amount,
        initial_stable_amount,
        fee_bps,
        minimum_liquidity,
        conditional_liquidity_ratio_percent,
    };

    // Validate parameters
    assert!(action.initial_asset_amount > 0, EInvalidAmount);
    assert!(action.initial_stable_amount > 0, EInvalidAmount);
    assert!(action.fee_bps <= 10000, EInvalidRatio);
    assert!(action.minimum_liquidity > 0, EInvalidAmount);
    assert!(action.conditional_liquidity_ratio_percent > 0 && action.conditional_liquidity_ratio_percent <= 99, EInvalidRatio);

    // Create resource request with pool creation parameters
    let mut request = resource_requests::new_request<CreatePoolAction<AssetType, StableType>>(ctx);
    resource_requests::add_context(&mut request, string::utf8(b"initial_asset_amount"), action.initial_asset_amount);
    resource_requests::add_context(&mut request, string::utf8(b"initial_stable_amount"), action.initial_stable_amount);
    resource_requests::add_context(&mut request, string::utf8(b"fee_bps"), action.fee_bps);
    resource_requests::add_context(&mut request, string::utf8(b"minimum_liquidity"), action.minimum_liquidity);
    resource_requests::add_context(&mut request, string::utf8(b"conditional_liquidity_ratio_percent"), action.conditional_liquidity_ratio_percent);
    resource_requests::add_context(&mut request, string::utf8(b"account_id"), object::id(account));

    request
}

/// Execute an update pool params action with type validation
/// Updates fee and minimum liquidity requirements for a pool
public fun do_update_pool_params<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    _version: VersionWitness,
    witness: IW,
    _ctx: &mut TxContext,
) {
    // Get spec and validate type BEFORE deserialization
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));
    action_validation::assert_action_type<UpdatePoolParams>(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    let action_data = intents::action_spec_data(spec);

    // Safe BCS deserialization - simplified without placeholders
    let mut reader = bcs::new(*action_data);
    let pool_id = object::id_from_address(bcs::peel_address(&mut reader));
    let new_fee_bps = bcs::peel_u64(&mut reader);
    let new_minimum_liquidity = bcs::peel_u64(&mut reader);
    bcs_validation::validate_all_bytes_consumed(reader);
    
    // Validate parameters
    assert!(new_fee_bps <= 10000, EInvalidRatio);
    assert!(new_minimum_liquidity > 0, EInvalidAmount);
    
    // Verify this pool belongs to the DAO
    let _config = account::config<FutarchyConfig>(account);
    // Pool validation would be done against stored pools in the Account
    // For now, just validate pool_id is not zero
    assert!(pool_id != object::id_from_address(@0x0), EEmptyPool);

    // Note: The pool object must be passed by the caller since it's a shared object
    // This function just validates the action - actual update happens in dispatcher
    // which has access to the pool object

    // Execute and increment
    executable::increment_action_idx(executable);
}


/// Fulfill pool creation request with coins from vault
/// For initial liquidity, all provided coins are used (no excess)
/// Any excess is returned to treasury vault
public fun fulfill_create_pool<AssetType: drop, StableType: drop, IW: copy + drop>(
    request: ResourceRequest<CreatePoolAction<AssetType, StableType>>,
    account: &mut Account,
    registry: &PackageRegistry,
    asset_coin: Coin<AssetType>,
    stable_coin: Coin<StableType>,
    clock: &Clock,
    witness: IW,
    ctx: &mut TxContext,
): (ResourceReceipt<CreatePoolAction<AssetType, StableType>>, ID) {
    // Extract parameters from request
    let initial_asset_amount: u64 = resource_requests::get_context(&request, string::utf8(b"initial_asset_amount"));
    let initial_stable_amount: u64 = resource_requests::get_context(&request, string::utf8(b"initial_stable_amount"));
    let fee_bps: u64 = resource_requests::get_context(&request, string::utf8(b"fee_bps"));
    let _minimum_liquidity: u64 = resource_requests::get_context(&request, string::utf8(b"minimum_liquidity"));
    let conditional_liquidity_ratio_percent: u64 = resource_requests::get_context(&request, string::utf8(b"conditional_liquidity_ratio_percent"));

    // Verify coins match requested amounts
    assert!(coin::value(&asset_coin) >= initial_asset_amount, EInvalidAmount);
    assert!(coin::value(&stable_coin) >= initial_stable_amount, EInvalidAmount);

    // Create the pool with FULL FUTARCHY FEATURES (TWAP oracle, escrow tracking, etc.)
    // oracle_conditional_threshold_bps: 5000 = 50% (use conditional oracle when conditional markets have >50% liquidity)
    let mut pool = unified_spot_pool::new<AssetType, StableType>(
        fee_bps,
        option::none(), // No dynamic fee schedule
        5000, // oracle_conditional_threshold_bps (50%)
        conditional_liquidity_ratio_percent, // From action!
        clock,
        ctx
    );

    // Add initial liquidity to the pool (returns LP token + any excess coins)
    // For initial liquidity, there should be no excess (all coins used)
    let (lp_token, excess_asset, excess_stable) = unified_spot_pool::add_liquidity_and_return(
        &mut pool,
        asset_coin,
        stable_coin,
        0, // min_lp_out - 0 for initial liquidity
        ctx
    );

    // Get pool ID before sharing
    let pool_id = object::id(&pool);

    // Share the pool so it can be accessed by anyone (must share before depositing LP)
    unified_spot_pool::share(pool);

    // Deposit LP token to custody (using witness for auth)
    lp_token_custody::deposit_lp_token(
        account,
        registry,
        pool_id,
        lp_token,
        witness,
        ctx
    );

    // Return any excess coins to treasury vault
    // For initial liquidity, excess should be zero, but handle it defensively
    let vault_name = string::utf8(DEFAULT_VAULT_NAME);

    if (coin::value(&excess_asset) > 0) {
        vault::deposit_approved<FutarchyConfig, AssetType>(
            account,
            registry,
            vault_name,
            excess_asset,
        );
    } else {
        coin::destroy_zero(excess_asset);
    };

    if (coin::value(&excess_stable) > 0) {
        vault::deposit_approved<FutarchyConfig, StableType>(
            account,
            registry,
            vault_name,
            excess_stable,
        );
    } else {
        coin::destroy_zero(excess_stable);
    };

    // Return receipt and pool ID
    (resource_requests::fulfill(request), pool_id)
}

/// Execute add liquidity with type validation - creates request for vault coins
public fun do_add_liquidity<AssetType: drop, StableType: drop, Outcome: store, IW: copy + drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    _version: VersionWitness,
    witness: IW,
    ctx: &mut TxContext,
): ResourceRequest<AddLiquidityAction<AssetType, StableType>> {
    // Get spec and validate type BEFORE deserialization
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));
    action_validation::assert_action_type<AddLiquidity>(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    let action_data = intents::action_spec_data(spec);

    // Safe BCS deserialization
    let mut reader = bcs::new(*action_data);
    let pool_id = object::id_from_address(bcs::peel_address(&mut reader));
    let asset_amount = bcs::peel_u64(&mut reader);
    let stable_amount = bcs::peel_u64(&mut reader);
    let min_lp_out = bcs::peel_u64(&mut reader);
    bcs_validation::validate_all_bytes_consumed(reader);

    // Create action struct
    let action = AddLiquidityAction<AssetType, StableType> {
        pool_id,
        asset_amount,
        stable_amount,
        min_lp_out
    };
    
    // Check vault has sufficient balance
    let vault_name = string::utf8(DEFAULT_VAULT_NAME);
    let vault = vault::borrow_vault(account, registry, vault_name);
    assert!(vault::coin_type_exists<AssetType>(vault), EInsufficientVaultBalance);
    assert!(vault::coin_type_exists<StableType>(vault), EInsufficientVaultBalance);
    assert!(vault::coin_type_value<AssetType>(vault) >= action.asset_amount, EInsufficientVaultBalance);
    assert!(vault::coin_type_value<StableType>(vault) >= action.stable_amount, EInsufficientVaultBalance);
    
    // Create resource request with action details (make a copy since action has copy ability)
    let mut request = resource_requests::new_request<AddLiquidityAction<AssetType, StableType>>(ctx);
    // Context not needed for typed requests
    // resource_requests::add_context(&mut request, string::utf8(b"action"), action);
    resource_requests::add_context(&mut request, string::utf8(b"account_id"), object::id(account));

    request
}

/// Fulfill add liquidity request with vault coins and pool
/// Deposits LP token to custody automatically
/// Returns excess coins back to treasury vault to prevent value donation to existing LPs
public fun fulfill_add_liquidity<AssetType: drop, StableType: drop, Outcome: store, IW: copy + drop>(
    request: ResourceRequest<AddLiquidityAction<AssetType, StableType>>,
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    pool: &mut UnifiedSpotPool<AssetType, StableType>,
    witness: IW,
    ctx: &mut TxContext,
): ResourceReceipt<AddLiquidityAction<AssetType, StableType>> {
    // Extract action from request (this consumes the request)
    let action: AddLiquidityAction<AssetType, StableType> =
        resource_requests::extract_action(request);

    // Get action parameters
    let pool_id = action.pool_id;
    let min_lp_amount = action.min_lp_out;

    // Verify pool ID matches
    assert!(pool_id == object::id(pool), EEmptyPool);

    // Use vault::do_spend to withdraw coins (this is the proper way)
    // Requires proper action setup in the executable
    let asset_coin = vault::do_spend<FutarchyConfig, Outcome, AssetType, IW>(
        executable,
        account,
        registry,
        version::current(),
        witness,
        ctx
    );

    let stable_coin = vault::do_spend<FutarchyConfig, Outcome, StableType, IW>(
        executable,
        account,
        registry,
        version::current(),
        witness,
        ctx
    );

    // Add liquidity to pool and get LP token + excess coins
    let (lp_token, excess_asset, excess_stable) = unified_spot_pool::add_liquidity_and_return(
        pool,
        asset_coin,
        stable_coin,
        min_lp_amount,
        ctx
    );

    // Deposit LP token to custody (using witness for auth)
    lp_token_custody::deposit_lp_token(
        account,
        registry,
        pool_id,
        lp_token,
        witness,
        ctx
    );

    // Return excess coins to treasury vault (permissionless deposit of approved coin types)
    // NOTE: Vault must have these coin types approved for permissionless deposits
    // This is typically done during DAO initialization
    let vault_name = string::utf8(DEFAULT_VAULT_NAME);

    // Only deposit if there's excess (non-zero)
    if (coin::value(&excess_asset) > 0) {
        vault::deposit_approved<FutarchyConfig, AssetType>(
            account,
            registry,
            vault_name,
            excess_asset,
        );
    } else {
        coin::destroy_zero(excess_asset);
    };

    if (coin::value(&excess_stable) > 0) {
        vault::deposit_approved<FutarchyConfig, StableType>(
            account,
            registry,
            vault_name,
            excess_stable,
        );
    } else {
        coin::destroy_zero(excess_stable);
    };

    // Create and return receipt
    resource_requests::create_receipt(action)
}

/// Execute withdraw LP token action with type validation
/// Returns a hot potato that must be fulfilled to obtain the LP token
public fun do_withdraw_lp_token<AssetType: drop, StableType: drop, Outcome: store, IW: copy + drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    registry: &PackageRegistry,
    _version: VersionWitness,
    _witness: IW,
    ctx: &mut TxContext,
): resource_requests::ResourceRequest<WithdrawLpTokenAction<AssetType, StableType>> {
    // Get spec and validate type BEFORE deserialization
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));
    action_validation::assert_action_type<WithdrawLpToken>(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    let action_data = intents::action_spec_data(spec);

    // Safe BCS deserialization
    let mut reader = bcs::new(*action_data);
    let pool_id = object::id_from_address(bcs::peel_address(&mut reader));
    let token_id = object::id_from_address(bcs::peel_address(&mut reader));
    bcs_validation::validate_all_bytes_consumed(reader);

    // Create action struct
    let action = WithdrawLpTokenAction<AssetType, StableType> {
        pool_id,
        token_id,
    };

    // Ensure the token exists in custody before fulfillment
    let token_amount = lp_token_custody::get_token_amount(account, registry, token_id);
    assert!(token_amount > 0, EWrongToken);

    // Execute and increment
    executable::increment_action_idx(executable);

    resource_requests::new_resource_request(action, ctx)
}

/// Fulfill withdraw LP token request by releasing the LP from custody
public fun fulfill_withdraw_lp_token<AssetType: drop, StableType: drop, W: copy + drop>(
    request: resource_requests::ResourceRequest<WithdrawLpTokenAction<AssetType, StableType>>,
    account: &mut Account,
    registry: &PackageRegistry,
    witness: W,
    ctx: &mut TxContext,
): (LPToken<AssetType, StableType>, resource_requests::ResourceReceipt<WithdrawLpTokenAction<AssetType, StableType>>) {
    let action = resource_requests::extract_action(request);

    let lp_token = lp_token_custody::withdraw_lp_token<AssetType, StableType, W>(
        account,
        registry,
        action.pool_id,
        action.token_id,
        witness,
        ctx
    );

    let receipt = resource_requests::create_receipt(action);
    (lp_token, receipt)
}

/// Execute remove liquidity with type validation
/// Returns a hot potato that must be fulfilled with the released LP token
public fun do_remove_liquidity<AssetType: drop, StableType: drop, Outcome: store, IW: copy + drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    _version: VersionWitness,
    witness: IW,
    ctx: &mut TxContext,
): resource_requests::ResourceRequest<RemoveLiquidityAction<AssetType, StableType>> {
    // Get spec and validate type BEFORE deserialization
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));
    action_validation::assert_action_type<RemoveLiquidity>(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    let action_data = intents::action_spec_data(spec);

    // Safe BCS deserialization
    let mut reader = bcs::new(*action_data);
    let pool_id = object::id_from_address(bcs::peel_address(&mut reader));
    let token_id = object::id_from_address(bcs::peel_address(&mut reader));
    let lp_amount = bcs::peel_u64(&mut reader);
    let min_asset_amount = bcs::peel_u64(&mut reader);
    let min_stable_amount = bcs::peel_u64(&mut reader);
    let bypass_minimum = bcs::peel_bool(&mut reader);
    bcs_validation::validate_all_bytes_consumed(reader);

    assert!(lp_amount > 0, EInvalidAmount);
    assert!(!bypass_minimum, EBypassNotAllowed);

    let action = RemoveLiquidityAction<AssetType, StableType> {
        pool_id,
        token_id,
        lp_amount,
        min_asset_amount,
        min_stable_amount,
        bypass_minimum: false,
    };

    let _ = account;
    let _ = witness;

    // Execute and increment
    executable::increment_action_idx(executable);

    resource_requests::new_resource_request(action, ctx)
}

/// Fulfill remove liquidity request with released LP token and pool reference
public fun fulfill_remove_liquidity<AssetType: drop, StableType: drop, W: copy + drop>(
    request: resource_requests::ResourceRequest<RemoveLiquidityAction<AssetType, StableType>>,
    account: &mut Account,
    registry: &PackageRegistry,
    pool: &mut UnifiedSpotPool<AssetType, StableType>,
    lp_token: LPToken<AssetType, StableType>,
    witness: W,
    ctx: &mut TxContext,
): (Coin<AssetType>, Coin<StableType>, resource_requests::ResourceReceipt<RemoveLiquidityAction<AssetType, StableType>>) {
    let action = resource_requests::extract_action(request);

    assert!(action.pool_id == object::id(pool), EEmptyPool);
    assert!(action.token_id == object::id(&lp_token), EWrongToken);

    // Verify the DAO authorization before burning the LP token
    let auth = account::new_auth<FutarchyConfig, W>(account, registry, version::current(), witness);
    account::verify(account, auth);

    let actual_lp_amount = unified_spot_pool::lp_token_amount(&lp_token);
    assert!(actual_lp_amount >= action.lp_amount, EInvalidAmount);

    let (asset_coin, stable_coin) = if (action.bypass_minimum) {
        {
            let dao_state = futarchy_config::state_mut_from_account(account, registry);
            assert!(
                futarchy_config::operational_state(dao_state) == futarchy_config::state_terminated(),
                EBypassNotAllowed
            );
        };

        let (asset_coin, stable_coin) = unified_spot_pool::remove_liquidity_for_dissolution(
            pool,
            lp_token,
            true,
            ctx
        );

        assert!(coin::value(&asset_coin) >= action.min_asset_amount, EInvalidAmount);
        assert!(coin::value(&stable_coin) >= action.min_stable_amount, EInvalidAmount);

        (asset_coin, stable_coin)
    } else {
        unified_spot_pool::remove_liquidity(
            pool,
            lp_token,
            action.min_asset_amount,
            action.min_stable_amount,
            ctx
        )
    };

    let receipt = resource_requests::create_receipt(action);

    (asset_coin, stable_coin, receipt)
}

/// Execute a swap action with type validation
public fun do_swap<AssetType: drop, StableType: drop, Outcome: store, IW: copy + drop>(
    executable: &mut Executable<Outcome>,
    _account: &mut Account,
    _version: VersionWitness,
    witness: IW,
    _ctx: &mut TxContext,
): ResourceRequest<SwapAction<AssetType, StableType>> {
    // Get spec and validate type BEFORE deserialization
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));
    action_validation::assert_action_type<Swap>(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    let action_data = intents::action_spec_data(spec);

    // Safe BCS deserialization
    let mut reader = bcs::new(*action_data);
    let pool_id = object::id_from_address(bcs::peel_address(&mut reader));
    let swap_asset = bcs::peel_bool(&mut reader);
    let amount_in = bcs::peel_u64(&mut reader);
    let min_amount_out = bcs::peel_u64(&mut reader);
    bcs_validation::validate_all_bytes_consumed(reader);

    // Create action struct
    let action = SwapAction<AssetType, StableType> {
        pool_id,
        swap_asset,
        amount_in,
        min_amount_out,
    };

    // Validate parameters
    assert!(action.amount_in > 0, EInvalidAmount);
    assert!(action.min_amount_out > 0, EInvalidAmount);

    // Create resource request
    let mut request = resource_requests::new_request<SwapAction<AssetType, StableType>>(_ctx);
    resource_requests::add_context(&mut request, string::utf8(b"pool_id"), pool_id);
    resource_requests::add_context(&mut request, string::utf8(b"swap_asset"), if (swap_asset) 1 else 0);
    resource_requests::add_context(&mut request, string::utf8(b"amount_in"), amount_in);
    resource_requests::add_context(&mut request, string::utf8(b"min_amount_out"), min_amount_out);

    request
}

/// Execute collect fees action with type validation
public fun do_collect_fees<AssetType: drop, StableType: drop, Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    _version: VersionWitness,
    witness: IW,
    _ctx: &mut TxContext,
) {
    // Get spec and validate type BEFORE deserialization
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));
    action_validation::assert_action_type<CollectFees>(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    let action_data = intents::action_spec_data(spec);

    // Safe BCS deserialization
    let mut reader = bcs::new(*action_data);
    let pool_id = object::id_from_address(bcs::peel_address(&mut reader));
    bcs_validation::validate_all_bytes_consumed(reader);

    // Verify this pool belongs to the DAO
    let _config = account::config<FutarchyConfig>(account);
    // Pool validation would be done against stored pools in the Account
    // For now, just validate pool_id is not zero
    assert!(pool_id != object::id_from_address(@0x0), EEmptyPool);

    // Note: Actual fee collection happens in dispatcher with pool access

    // Execute and increment
    executable::increment_action_idx(executable);
}

/// Execute withdraw fees action with type validation
public fun do_withdraw_fees<AssetType: drop, StableType: drop, Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account,
    _version: VersionWitness,
    witness: IW,
    _ctx: &mut TxContext,
) {
    // Get spec and validate type BEFORE deserialization
    let specs = executable::intent(executable).action_specs();
    let spec = specs.borrow(executable::action_idx(executable));
    action_validation::assert_action_type<WithdrawFees>(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    let action_data = intents::action_spec_data(spec);

    // Safe BCS deserialization
    let mut reader = bcs::new(*action_data);
    let pool_id = object::id_from_address(bcs::peel_address(&mut reader));
    let asset_amount = bcs::peel_u64(&mut reader);
    let stable_amount = bcs::peel_u64(&mut reader);
    bcs_validation::validate_all_bytes_consumed(reader);

    // Verify this pool belongs to the DAO
    let _config = account::config<FutarchyConfig>(account);
    // Pool validation would be done against stored pools in the Account
    // For now, just validate pool_id is not zero
    assert!(pool_id != object::id_from_address(@0x0), EEmptyPool);

    // Validate amounts
    assert!(asset_amount > 0 || stable_amount > 0, EInvalidAmount);

    // Note: Actual withdrawal happens in dispatcher with pool access
    let _ = asset_amount;
    let _ = stable_amount;

    // Execute and increment
    executable::increment_action_idx(executable);
}

// === Cleanup Functions ===

/// Delete an add liquidity action from an expired intent
public fun delete_add_liquidity<AssetType, StableType>(expired: &mut Expired) {
    let action_spec = intents::remove_action_spec(expired);
    // Action spec data will be dropped automatically
    // Expired intent is automatically destroyed when it goes out of scope
}

/// Delete a withdraw LP token action from an expired intent
public fun delete_withdraw_lp_token<AssetType, StableType>(expired: &mut Expired) {
    let action_spec = intents::remove_action_spec(expired);
    // Action spec data will be dropped automatically
    // Expired intent is automatically destroyed when it goes out of scope
}

/// Delete a remove liquidity action from an expired intent
public fun delete_remove_liquidity<AssetType, StableType>(expired: &mut Expired) {
    let action_spec = intents::remove_action_spec(expired);
    // Action spec data will be dropped automatically
    // Expired intent is automatically destroyed when it goes out of scope
}

/// Delete a create pool action from an expired intent
public fun delete_create_pool<AssetType, StableType>(expired: &mut Expired) {
    let action_spec = intents::remove_action_spec(expired);
    // Action spec data will be dropped automatically
    // Expired intent is automatically destroyed when it goes out of scope
}

/// Delete an update pool params action from an expired intent
public fun delete_update_pool_params(expired: &mut Expired) {
    let action_spec = intents::remove_action_spec(expired);
    // Action spec data will be dropped automatically
    // Expired intent is automatically destroyed when it goes out of scope
}


/// Delete a swap action from an expired intent
public fun delete_swap<AssetType, StableType>(expired: &mut Expired) {
    let action_spec = intents::remove_action_spec(expired);
    // Action spec data will be dropped automatically
    // Expired intent is automatically destroyed when it goes out of scope
}

/// Delete a collect fees action from an expired intent
public fun delete_collect_fees<AssetType, StableType>(expired: &mut Expired) {
    let action_spec = intents::remove_action_spec(expired);
    // Action spec data will be dropped automatically
    // Expired intent is automatically destroyed when it goes out of scope
}

/// Delete a withdraw fees action from an expired intent
public fun delete_withdraw_fees<AssetType, StableType>(expired: &mut Expired) {
    let action_spec = intents::remove_action_spec(expired);
    // Action spec data will be dropped automatically
    // Expired intent is automatically destroyed when it goes out of scope
}

// === Helper Functions ===

/// Create a new add liquidity action with serialization
public fun new_add_liquidity_action<AssetType, StableType>(
    pool_id: ID,
    asset_amount: u64,
    stable_amount: u64,
    min_lp_out: u64,
): AddLiquidityAction<AssetType, StableType> {
    assert!(asset_amount > 0, EInvalidAmount);
    assert!(stable_amount > 0, EInvalidAmount);
    assert!(min_lp_out > 0, EInvalidAmount);

    let action = AddLiquidityAction {
        pool_id,
        asset_amount,
        stable_amount,
        min_lp_out,
    };
    action
}

/// Create a new remove liquidity action with serialization
public fun new_remove_liquidity_action<AssetType, StableType>(
    pool_id: ID,
    token_id: ID,
    lp_amount: u64,
    min_asset_amount: u64,
    min_stable_amount: u64,
): RemoveLiquidityAction<AssetType, StableType> {
    assert!(lp_amount > 0, EInvalidAmount);

    RemoveLiquidityAction<AssetType, StableType> {
        pool_id,
        token_id,
        lp_amount,
        min_asset_amount,
        min_stable_amount,
        bypass_minimum: false,
    }
}

/// Create a new withdraw LP token action
public fun new_withdraw_lp_token_action<AssetType, StableType>(
    pool_id: ID,
    token_id: ID,
): WithdrawLpTokenAction<AssetType, StableType> {
    WithdrawLpTokenAction<AssetType, StableType> {
        pool_id,
        token_id,
    }
}

/// Enable bypass mode for a remove liquidity request (restricted to dissolution state)
public fun enable_remove_liquidity_bypass<AssetType, StableType>(
    request: &mut resource_requests::ResourceRequest<RemoveLiquidityAction<AssetType, StableType>>,
    account: &mut Account,
    registry: &PackageRegistry,
) {
    {
        let dao_state = futarchy_config::state_mut_from_account(account, registry);
        assert!(
            futarchy_config::operational_state(dao_state) == futarchy_config::state_terminated(),
            EBypassNotAllowed
        );
    };

    let key = string::utf8(b"action");
    let action: RemoveLiquidityAction<AssetType, StableType> = resource_requests::take_context(request, key);

    let RemoveLiquidityAction {
        pool_id,
        token_id,
        lp_amount,
        min_asset_amount,
        min_stable_amount,
        bypass_minimum,
    } = action;
    assert!(!bypass_minimum, EBypassNotAllowed);

    let updated_action = RemoveLiquidityAction<AssetType, StableType> {
        pool_id,
        token_id,
        lp_amount,
        min_asset_amount,
        min_stable_amount,
        bypass_minimum: true,
    };

    resource_requests::add_context(
        request,
        string::utf8(b"action"),
        updated_action,
    );
}

/// Create a new create pool action with serialization
public fun new_create_pool_action<AssetType, StableType>(
    initial_asset_amount: u64,
    initial_stable_amount: u64,
    fee_bps: u64,
    minimum_liquidity: u64,
    conditional_liquidity_ratio_percent: u64,
): CreatePoolAction<AssetType, StableType> {
    assert!(initial_asset_amount > 0, EInvalidAmount);
    assert!(initial_stable_amount > 0, EInvalidAmount);
    assert!(fee_bps <= 10000, EInvalidRatio); // Max 100%
    assert!(minimum_liquidity > 0, EInvalidAmount);
    assert!(conditional_liquidity_ratio_percent > 0 && conditional_liquidity_ratio_percent <= 99, EInvalidRatio);

    let action = CreatePoolAction<AssetType, StableType> {
        initial_asset_amount,
        initial_stable_amount,
        fee_bps,
        minimum_liquidity,
        conditional_liquidity_ratio_percent,
    };
    action
}

/// Create a new update pool params action with serialization
public fun new_update_pool_params_action(
    pool_id: ID,
    new_fee_bps: u64,
    new_minimum_liquidity: u64,
): UpdatePoolParamsAction {
    assert!(new_fee_bps <= 10000, EInvalidRatio); // Max 100%
    assert!(new_minimum_liquidity > 0, EInvalidAmount);

    let action = UpdatePoolParamsAction {
        pool_id,
        new_fee_bps,
        new_minimum_liquidity,
    };
    action
}


/// Create a new swap action with serialization
public fun new_swap_action<AssetType, StableType>(
    pool_id: ID,
    swap_asset: bool,
    amount_in: u64,
    min_amount_out: u64,
): SwapAction<AssetType, StableType> {
    assert!(amount_in > 0, EInvalidAmount);
    assert!(min_amount_out > 0, EInvalidAmount);

    let action = SwapAction<AssetType, StableType> {
        pool_id,
        swap_asset,
        amount_in,
        min_amount_out,
    };
    action
}

/// Create a new collect fees action with serialization
public fun new_collect_fees_action<AssetType, StableType>(
    pool_id: ID,
): CollectFeesAction<AssetType, StableType> {
    let action = CollectFeesAction<AssetType, StableType> {
        pool_id,
    };
    action
}

/// Create a new withdraw fees action with serialization
public fun new_withdraw_fees_action<AssetType, StableType>(
    pool_id: ID,
    asset_amount: u64,
    stable_amount: u64,
): WithdrawFeesAction<AssetType, StableType> {
    assert!(asset_amount > 0 || stable_amount > 0, EInvalidAmount);

    let action = WithdrawFeesAction<AssetType, StableType> {
        pool_id,
        asset_amount,
        stable_amount,
    };
    action
}

// === Getter Functions ===

/// Get pool ID from AddLiquidityAction (alias for action_data_structs)
public fun get_pool_id<AssetType, StableType>(action: &AddLiquidityAction<AssetType, StableType>): ID {
    action.pool_id
}

/// Get asset amount from AddLiquidityAction (alias for action_data_structs)
public fun get_asset_amount<AssetType, StableType>(action: &AddLiquidityAction<AssetType, StableType>): u64 {
    action.asset_amount
}

/// Get stable amount from AddLiquidityAction (alias for action_data_structs)
public fun get_stable_amount<AssetType, StableType>(action: &AddLiquidityAction<AssetType, StableType>): u64 {
    action.stable_amount
}

/// Get minimum LP amount from AddLiquidityAction (alias for action_data_structs)
public fun get_min_lp_amount<AssetType, StableType>(action: &AddLiquidityAction<AssetType, StableType>): u64 {
    action.min_lp_out
}

/// Get pool ID from RemoveLiquidityAction
public fun get_remove_pool_id<AssetType, StableType>(action: &RemoveLiquidityAction<AssetType, StableType>): ID {
    action.pool_id
}

/// Get token ID from RemoveLiquidityAction
public fun get_remove_token_id<AssetType, StableType>(action: &RemoveLiquidityAction<AssetType, StableType>): ID {
    action.token_id
}

/// Get LP amount from RemoveLiquidityAction
public fun get_lp_amount<AssetType, StableType>(action: &RemoveLiquidityAction<AssetType, StableType>): u64 {
    action.lp_amount
}

/// Get minimum asset amount from RemoveLiquidityAction
public fun get_min_asset_amount<AssetType, StableType>(action: &RemoveLiquidityAction<AssetType, StableType>): u64 {
    action.min_asset_amount
}

/// Get minimum stable amount from RemoveLiquidityAction
public fun get_min_stable_amount<AssetType, StableType>(action: &RemoveLiquidityAction<AssetType, StableType>): u64 {
    action.min_stable_amount
}

/// Get bypass flag from RemoveLiquidityAction
public fun get_bypass_minimum<AssetType, StableType>(action: &RemoveLiquidityAction<AssetType, StableType>): bool {
    action.bypass_minimum
}

/// Get pool ID from WithdrawLpTokenAction
public fun get_withdraw_pool_id<AssetType, StableType>(action: &WithdrawLpTokenAction<AssetType, StableType>): ID {
    action.pool_id
}

/// Get token ID from WithdrawLpTokenAction
public fun get_withdraw_token_id<AssetType, StableType>(action: &WithdrawLpTokenAction<AssetType, StableType>): ID {
    action.token_id
}

/// Get initial asset amount from CreatePoolAction
public fun get_initial_asset_amount<AssetType, StableType>(action: &CreatePoolAction<AssetType, StableType>): u64 {
    action.initial_asset_amount
}

/// Get initial stable amount from CreatePoolAction
public fun get_initial_stable_amount<AssetType, StableType>(action: &CreatePoolAction<AssetType, StableType>): u64 {
    action.initial_stable_amount
}

/// Get fee basis points from CreatePoolAction
public fun get_fee_bps<AssetType, StableType>(action: &CreatePoolAction<AssetType, StableType>): u64 {
    action.fee_bps
}

/// Get minimum liquidity from CreatePoolAction
public fun get_minimum_liquidity<AssetType, StableType>(action: &CreatePoolAction<AssetType, StableType>): u64 {
    action.minimum_liquidity
}

/// Get pool ID from UpdatePoolParamsAction
public fun get_update_pool_id(action: &UpdatePoolParamsAction): ID {
    action.pool_id
}

/// Get new fee basis points from UpdatePoolParamsAction
public fun get_new_fee_bps(action: &UpdatePoolParamsAction): u64 {
    action.new_fee_bps
}

/// Get new minimum liquidity from UpdatePoolParamsAction
public fun get_new_minimum_liquidity(action: &UpdatePoolParamsAction): u64 {
    action.new_minimum_liquidity
}


/// Get LP token value helper
public fun lp_value<AssetType, StableType>(lp_token: &LPToken<AssetType, StableType>): u64 {
    unified_spot_pool::lp_token_amount(lp_token)
}

// === Destruction Functions ===

/// Destroy CreatePoolAction after use
public fun destroy_create_pool_action<AssetType, StableType>(action: CreatePoolAction<AssetType, StableType>) {
    let CreatePoolAction {
        initial_asset_amount: _,
        initial_stable_amount: _,
        fee_bps: _,
        minimum_liquidity: _,
        conditional_liquidity_ratio_percent: _,
    } = action;
}

/// Destroy UpdatePoolParamsAction after use
public fun destroy_update_pool_params_action(action: UpdatePoolParamsAction) {
    let UpdatePoolParamsAction {
        pool_id: _,
        new_fee_bps: _,
        new_minimum_liquidity: _,
    } = action;
}

/// Destroy AddLiquidityAction after use (delegate to action_data_structs)
public fun destroy_add_liquidity_action<AssetType, StableType>(action: AddLiquidityAction<AssetType, StableType>) {
    // AddLiquidityAction has drop ability, so it will be automatically dropped
    let _ = action;
}

/// Destroy RemoveLiquidityAction after use
public fun destroy_remove_liquidity_action<AssetType, StableType>(action: RemoveLiquidityAction<AssetType, StableType>) {
    let RemoveLiquidityAction {
        pool_id: _,
        token_id: _,
        lp_amount: _,
        min_asset_amount: _,
        min_stable_amount: _,
        bypass_minimum: _,
    } = action;
}

/// Destroy WithdrawLpTokenAction after use
public fun destroy_withdraw_lp_token_action<AssetType, StableType>(action: WithdrawLpTokenAction<AssetType, StableType>) {
    let WithdrawLpTokenAction {
        pool_id: _,
        token_id: _,
    } = action;
}


/// Destroy SwapAction after use
public fun destroy_swap_action<AssetType, StableType>(action: SwapAction<AssetType, StableType>) {
    let SwapAction {
        pool_id: _,
        swap_asset: _,
        amount_in: _,
        min_amount_out: _,
    } = action;
}

/// Destroy CollectFeesAction after use
public fun destroy_collect_fees_action<AssetType, StableType>(action: CollectFeesAction<AssetType, StableType>) {
    let CollectFeesAction {
        pool_id: _,
    } = action;
}

/// Destroy WithdrawFeesAction after use
public fun destroy_withdraw_fees_action<AssetType, StableType>(action: WithdrawFeesAction<AssetType, StableType>) {
    let WithdrawFeesAction {
        pool_id: _,
        asset_amount: _,
        stable_amount: _,
    } = action;
}

// === Public Exports for External Access ===

// Export action structs for decoder and other modules
// Note: use fun declarations removed due to incorrect syntax

// Export destroy functions for cleanup
public use fun destroy_create_pool_action as CreatePoolAction.destroy;
public use fun destroy_update_pool_params_action as UpdatePoolParamsAction.destroy;
// Destroy functions for actions with drop ability are not needed
// Actions are automatically dropped when they go out of scope

// === Deserialization Constructors ===

/// Deserialize AddLiquidityAction from bytes (alias for action_data_structs)
public(package) fun add_liquidity_action_from_bytes<AssetType, StableType>(bytes: vector<u8>): AddLiquidityAction<AssetType, StableType> {
    // Deserialize from bytes
    let mut bcs = bcs::new(bytes);
    AddLiquidityAction {
        pool_id: object::id_from_address(bcs::peel_address(&mut bcs)),
        asset_amount: bcs::peel_u64(&mut bcs),
        stable_amount: bcs::peel_u64(&mut bcs),
        min_lp_out: bcs::peel_u64(&mut bcs),
    }
}

/// Deserialize RemoveLiquidityAction from bytes
public(package) fun remove_liquidity_action_from_bytes<AssetType, StableType>(bytes: vector<u8>): RemoveLiquidityAction<AssetType, StableType> {
    let mut bcs = bcs::new(bytes);
    RemoveLiquidityAction {
        pool_id: object::id_from_address(bcs::peel_address(&mut bcs)),
        token_id: object::id_from_address(bcs::peel_address(&mut bcs)),
        lp_amount: bcs::peel_u64(&mut bcs),
        min_asset_amount: bcs::peel_u64(&mut bcs),
        min_stable_amount: bcs::peel_u64(&mut bcs),
        bypass_minimum: bcs::peel_bool(&mut bcs),
    }
}

/// Deserialize WithdrawLpTokenAction from bytes
public(package) fun withdraw_lp_token_action_from_bytes<AssetType, StableType>(bytes: vector<u8>): WithdrawLpTokenAction<AssetType, StableType> {
    let mut bcs = bcs::new(bytes);
    WithdrawLpTokenAction {
        pool_id: object::id_from_address(bcs::peel_address(&mut bcs)),
        token_id: object::id_from_address(bcs::peel_address(&mut bcs)),
    }
}

/// Deserialize CreatePoolAction from bytes
public(package) fun create_pool_action_from_bytes<AssetType, StableType>(bytes: vector<u8>): CreatePoolAction<AssetType, StableType> {
    let mut bcs = bcs::new(bytes);
    CreatePoolAction {
        initial_asset_amount: bcs::peel_u64(&mut bcs),
        initial_stable_amount: bcs::peel_u64(&mut bcs),
        fee_bps: bcs::peel_u64(&mut bcs),
        minimum_liquidity: bcs::peel_u64(&mut bcs),
        conditional_liquidity_ratio_percent: bcs::peel_u64(&mut bcs),
    }
}

/// Deserialize UpdatePoolParamsAction from bytes
public(package) fun update_pool_params_action_from_bytes(bytes: vector<u8>): UpdatePoolParamsAction {
    let mut bcs = bcs::new(bytes);
    UpdatePoolParamsAction {
        pool_id: object::id_from_address(bcs::peel_address(&mut bcs)),
        new_fee_bps: bcs::peel_u64(&mut bcs),
        new_minimum_liquidity: bcs::peel_u64(&mut bcs),
    }
}


/// Deserialize SwapAction from bytes
public(package) fun swap_action_from_bytes<AssetType, StableType>(bytes: vector<u8>): SwapAction<AssetType, StableType> {
    let mut bcs = bcs::new(bytes);
    SwapAction {
        pool_id: object::id_from_address(bcs::peel_address(&mut bcs)),
        swap_asset: bcs::peel_bool(&mut bcs),
        amount_in: bcs::peel_u64(&mut bcs),
        min_amount_out: bcs::peel_u64(&mut bcs),
    }
}

/// Deserialize CollectFeesAction from bytes
public(package) fun collect_fees_action_from_bytes<AssetType, StableType>(bytes: vector<u8>): CollectFeesAction<AssetType, StableType> {
    let mut bcs = bcs::new(bytes);
    CollectFeesAction {
        pool_id: object::id_from_address(bcs::peel_address(&mut bcs)),
    }
}

/// Deserialize WithdrawFeesAction from bytes
public(package) fun withdraw_fees_action_from_bytes<AssetType, StableType>(bytes: vector<u8>): WithdrawFeesAction<AssetType, StableType> {
    let mut bcs = bcs::new(bytes);
    WithdrawFeesAction {
        pool_id: object::id_from_address(bcs::peel_address(&mut bcs)),
        asset_amount: bcs::peel_u64(&mut bcs),
        stable_amount: bcs::peel_u64(&mut bcs),
    }
}
